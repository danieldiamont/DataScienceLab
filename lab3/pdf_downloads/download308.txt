StingyCD

A. Proof of Theorem 2.1
Theorem 2.1 (Safeness of StingyCD). In Algorithm 2, every skipped update would, if computed, result in Î´ = 0. That is,
(tâˆ’1)
if q (tâˆ’1) â‰¤ Ï„i and xi
= 0, then
)
(



Ai , b âˆ’ Ax(tâˆ’1) âˆ’ Î»
(tâˆ’1)
= 0.
max âˆ’xi
,
2
kAi k
(tâˆ’1)

Proof. Since xi

= 0, we need to prove that if q (tâˆ’1) â‰¤ Ï„i , then
E
D
Ai , r(tâˆ’1) âˆ’ Î» â‰¤ 0,

(3)

where we have used the definition r(tâˆ’1) = b âˆ’ Ax(tâˆ’1) .

2
We show by induction that q (t) = rr âˆ’ r(t)  . The base case is that q (tâˆ’1) = 0 whenever StingyCD performs the update
rr â† r(tâˆ’1) . The inductive step is that
D
E
2
q (t) = q (tâˆ’1) âˆ’ 2Î´ Ai , r(tâˆ’1) âˆ’ rr + Î´ 2 kAi k
(4)

2
D
E


2
= r(tâˆ’1) âˆ’ rr âˆ’ 2Î´ Ai , r(tâˆ’1) âˆ’ rr + Î´ 2 kAi k
(5)

2


(6)
= r(tâˆ’1) âˆ’ Î´Ai âˆ’ rr

2


(7)
= r(t) âˆ’ rr .
g2

Recall the definition Ï„i = sign (gi ) kAi k2 , where gi = âˆ’ hAi , rri + Î». It follows that
i

q (tâˆ’1) â‰¤ Ï„i

â‡’
â‡’
â‡’
â‡’
â‡’


2
gi2
 (tâˆ’1)

âˆ’ rr â‰¤ sign (gi )
r
2
kAi k


gi
 (tâˆ’1)

âˆ’ rr â‰¤
r
kAi k


 (tâˆ’1)

kAi k r
âˆ’ rr â‰¤ âˆ’ hAi , rri + Î»




hAi , rri + kAi k r(tâˆ’1) âˆ’ rr âˆ’ Î» â‰¤ 0
D
E
Ai , r(tâˆ’1) âˆ’ Î» â‰¤ 0 .

(8)
(9)
(10)
(11)
(12)

B. Proof of Theorem 2.2
Theorem 2.2 (Per iteration time complexity of StingyCD). Algorithm 2 can be implemented so that iteration t requires
(tâˆ’1)

â€¢ Less time than an identical iteration of Algorithm 1 if q (tâˆ’1) â‰¤ Ï„i and xi
= 0 (the update is skipped) and rr is
not updated. Specifically, StingyCD requires O(1) time, while CD requires O(NNZ (Ai )) time.
â€¢ The same amount of time (up to an O(1) term) as a CD iteration if the update is not skipped and rr is not updated.
In particular, both algorithms require the same number of O(NNZ (Ai )) operations.
â€¢ More time than a CD iteration if rr is updated. In this case, StingyCD requires O(NNZ (A)) time.
Proof. Note that at each iteration, CD computes a dot product of length NNZ (Ai ) to compute Î´. If Î´ 6= 0, an additional
O(NNZ (Ai )) operation is required to update r(t) .

StingyCD

Case 1: the update is skipped and rr is not updated In this case, the only computation StingyCD performs during this
iteration is (i.) deciding not to update the reference vector, (ii.) choosing a coordinate to update, and (iii.) checking whether
(tâˆ’1)
q (tâˆ’1) â‰¤ Ï„i and xi
= 0. Steps (i.) and (ii.) can be easily be defined so that they require O(1) time, and checking the
conditions for (iii.) also requires constant time.
Case 2: the update is not skipped and rr is not updated In this case, the only additional operation that we have not
already considered
is the update to q (t) . This update can be performed in constant time by caching previous computations
of




2
(tâˆ’1)
hAi , rri, Ai , r
, and kAi k . The value of hAi , rri was computed when computing the threshold Ï„i , and Ai , r(tâˆ’1)
2
and kAi k are necessary to compute Î´.
Case 3: rr is updated In this case, computing Ï„i for all i requires computing hAi , rri for all columns in A. This is a
matrix-vector multiply that requires O(NNZ (Ai )) operations.

C. Proof of Theorem 3.2
(tâˆ’1)

Theorem 3.2 (Equation for P (U (t) )). Assume xi
(
P (U (t) ) =

1âˆ’

= 0 and Ï„i âˆˆ (âˆ’q (tâˆ’1) , q (tâˆ’1) ). Then Assumption 3.1 implies

1
nâˆ’1
2 I(1âˆ’Ï„i /q (tâˆ’1) ) ( 2 ,
nâˆ’1
1
2 I(1+Ï„i /q (tâˆ’1) ) ( 2 ,

1
2)
1
2)

if Ï„i â‰¥ 0,
otherwise,

where Ix (a, b) is the regularized incomplete beta function.
Proof. Recall the illustration form Figure 2:

Because we assume r(tâˆ’1) is uniformly distributed on the boundary of S (t) , the probability that r(tâˆ’1) âˆˆ Ai is given by
dividing the area of Ai âˆ© bd(S (t) ) by the area of bd(S (t) ). The region Ai âˆ© bd(S (t) ) is a hyperspherical cap. In the case
that rr âˆˆ
/ Ai , we know from (Li, 2011) that the area of Ai âˆ© bd(S (t) ) is given by
(t)
1
1
)Isin(Î¸)2 ( nâˆ’1
2 area(S
2 , 2) ,

(13)

where area(S (t) ) is the surface area of S (t) and Î¸ is the angle indicated in the diagram.
When Ï„i â‰¥ 0, note that by definition of Ï„i , we have rr âˆˆ
/ Ai . It follows then that when Ï„i â‰¥ 0, we have
P (Ut ) =

1
1
(t)
)Isin(Î¸)2 ( nâˆ’1
2 area(S
2 , 2)
area(S (t) )

1
= 12 I(1âˆ’cos(Î¸)2 ) ( nâˆ’1
2 , 2)

=

1
nâˆ’1 1
2 I(1âˆ’Ï„i /q (tâˆ’1) ) ( 2 , 2 ) .

(14)
(15)
(16)

In the case that Ï„i < 0, we have rr âˆˆ Ai , and we can use symmetry to see that
1
P (Ut ) = 1 âˆ’ 12 I(1+Ï„i /q(tâˆ’1) ) ( nâˆ’1
2 , 2) .

(17)

StingyCD

D. Details of estimating P (U (t) ) in StingyCD+
In Â§3.1, we defined the probability P (U (t) ). Assuming Ï„i âˆˆ (âˆ’q (tâˆ’1) , q (tâˆ’1) ), we have
(
nâˆ’1 1
1
2 I(1âˆ’Ï„i /q (tâˆ’1) ) ( 2 , 2 ) if Ï„i â‰¥ 0,
(t)
P (U ) =
1
1 âˆ’ 12 I(1+Ï„i /q(tâˆ’1) ) ( nâˆ’1
2 , 2 ) otherwise,

(18)

where Ix (a, b) is the regularized incomplete beta function.
In our implementation of StingyCD+, we compute P (U (t) ) approximately using a lookup table. First, we make use of the
approximation
q

1
nâˆ’1 1
(tâˆ’1) .
I
(
,
)
â‰ˆ
1
âˆ’
Î¦
Ï„
(n
âˆ’
1)/q
(19)
(tâˆ’1)
i
)
2 (1âˆ’Ï„i /q
2
2
Above, Î¦ is the standard normal CDF.
Using (19) is not strictly necessary. Using (19) leads to a simpler implementation, however, since we no longer need to
compute the regularized incomplete beta function. Instead we only need to define a lookup table for the standard normal
CDF. We expect this approximation has negligible effect on StingyCD+, since (19) is a very close approximation for
moderately large n.
âˆš
are spaced
Using (19), our StingyCD+ implementation uses a lookup table of 128 values for 1 âˆ’ Î¦( x).
âˆš Values of x âˆš
uniformly
between
0
and
32
inclusive,
meaning
the
table
stores
the
values
1
âˆ’
Î¦(0),
1
âˆ’
Î¦(
0.25),
1
âˆ’
Î¦(
0.5), . . .,
âˆš
1 âˆ’ Î¦( 32).
To estimate P (U (t) ) during each iteration, StingyCD+ first computes Ï„i (nâˆ’1)/q (tâˆ’1) and then reads the closest value from
(t)
the table that
). For example, if Ï„i (n âˆ’ 1)/q (tâˆ’1) = 0.2, our approximation
of P (U (t) )
âˆš results in an upper bound for P (U
âˆš
(tâˆ’1)
(t)
is 1 âˆ’ Î¦( 0.25) = 0.308 . . .. If Ï„i (n âˆ’ 1)/q
= âˆ’0.2, then our approximation of P (U ) is Î¦( 0.5) = 0.760 . . ..

E. Proof of Theorem 3.3

Theorem 3.3 (StingyCD+ converges to a solution of (P)). In StingyCD+, assume Î¾ (t) â‰¤ NNZ x(tâˆ’1) for all t > 0.
Also, for each i âˆˆ [m], assume the largest number of consecutive iterations during which get next coordinate() does
not return i is bounded as t â†’ âˆ. Then
lim f (x(t) ) = f (x? ) .
tâ†’âˆ

Before proving the theorem, we introduce and prove a few lemmas.
Lemma E.1. Given the assumptions of Theorem 3.3, let M be a number larger than the maximum number of consecutive
iterations get next coordinate() does not return coordinate i for all i âˆˆ [m] as t â†’ âˆ. Consider any iteration t > 0 of
(tâˆ’1)
StingyCD+ and any i âˆˆ [m] such that xi
6= 0. Then there exists an iteration t0 â‰¥ t during which StingyCD+ computes
an update to coordinate i. Furthermore, we have t0 â‰¤ t + mM .
Proof. Define C (tâˆ’1) as the set of coordinates that correspond to nonzero entries in x(tâˆ’1) :
(tâˆ’1)

C (tâˆ’1) = {i : xi

6= 0}.

(20)

(t)

Let idelayed denote the unique coordinate in C (tâˆ’1) such that the delay Di is largest:
(t)

idelayed = argmax Di .

(21)

iâˆˆC (tâˆ’1)

This coordinate is unique because tlast
differs for all i âˆˆ C (tâˆ’1) â€”StingyCD+ updates at most one coordinate during each
i
iteration.


(t)
We must have Didelayed â‰¥ NNZ x(tâˆ’1) , since the NNZ x(tâˆ’1) âˆ’ 1 coordinates in C (tâˆ’1) not equal to idelayed were
updated before idelayed was last updated (otherwise (21) would not hold). Thus, counting these updates, as well as the

(t)
(tâˆ’1)
update to weight idelayed during iteration tlast
.
idelayed , we must have Didelayed â‰¥ NNZ x

StingyCD

Now let k â‰¥ 0 be the smallest such k for which get next coordinate() returns idelayed during iteration t + k. Note that

(t+k)
(t)
k < M . We must have Didelayed â‰¥ NNZ x(t+kâˆ’1) , since (i) until an update for coordinate i is computed, Di is nonde




0
0
(t)
creasing with t for all i, (ii) we have Didelayed â‰¥ NNZ x(tâˆ’1) , and (iii) whenever NNZ x(t ) = NNZ x(t âˆ’1) + 1
(t0 +1)

(t0 )

for t0 âˆˆ {t, t + 1, . . . , t + k âˆ’ 1}, we must also have Didelayed = Didelayed + 1â€”an update to a zero entry of x increases
the delay for all coordinates by 1.
(t+kâˆ’1)

In addition, since idelayed âˆˆ C (tâˆ’1) and idelayed has not been updated since before iteration t, we must have xidelayed 6= 0.

Thus, by definition of P (U (t+k) ), we must have P (U (t+k) ) = 1. Applying the assumption that Î¾ (t+k) â‰¤ NNZ x(t+kâˆ’1) ,
it follows that


(t+k)
(t+k)
P (U (t+k) )Didelayed = Didelayed â‰¥ NNZ x(t+k)âˆ’1 â‰¥ Î¾ (t+k) .
(22)
Thus, the condition for skipping update t + k in StingyCD+ is not satisfied. That is, during iteration t + k, StingyCD+
(t+k+1)
computes an update to coordinate idelayed . It follows that Didelayed = 1. That is, idelayed now corresponds to the weight
with smallest delay among nonzero weights.
(tâˆ’1)

Now consider any i such that xi
6= 0. This coordinate was last updated during iteration tlast
i . It follows that if
+ (m âˆ’ 1)M , then i corresponds to the weight with largest delay among
coordinate i is not updated by iteration tlast
i
nonzero weights. This is because we have shown that the nonzero weight with maximum delay is updated within M
iterations, after which it becomes the nonzero weight with smallest delay. Thus, before coordinate i is updated again, at
most (m âˆ’ 1) other coordinates correspond to the nonzero weight with largest delay, each of which requires at most M
iterations to update. It follows that after an additional M iterationsâ€”that is, by iteration tlast
+ mM â€”coordinate i must
i
be updated.
Lemma E.2. Given the assumptions of Theorem 3.3, then for some set F, StingyCD+ converges to a solution of the
problem
2
minimize
f (x) := 12 kAx âˆ’ bk + Î» h1, xi
xâˆˆRm
(Pâ€™)
s.t.
xâ‰¥0
xi = 0 âˆ€i âˆˆ F
.
Proof. First note that f (x(t) ) is nonincreasing with t. This is because whenever x(t) 6= x(tâˆ’1) , we can write
x(t) = x(tâˆ’1) + Î´ei

(23)

for some coordinate i, where
Î´=

argmin
(tâˆ’1)

Î´ 0 : xi

(tâˆ’1)

f (x



0

+ Î´ ei ) = max

+Î´ 0 â‰¥0

(tâˆ’1)
iâˆ’Î»
(tâˆ’1) hAi ,bâˆ’Ax
âˆ’xi
,
kAi k2


.

(24)

Second, note that for all t, x(t) â‰¥ 0. From the definition of f , it follows that f (x(t) ) â‰¥ 0 for all t.
Thus, f (x(t) ) is a bounded monotone sequence, which implies that lim f (x(t) ) exists.
tâ†’âˆ

(t)

Now let us assume that x does not converge to a solution of (Pâ€™) for some set F. Then there exists a value Î½ > 0 for
(tâˆ’1)
which the following holds: for all t0 > 0, there exists an iteration t > t0 such that for some i where xi
6= 0, we have

)
(




Ai , r(tâˆ’1) âˆ’ Î» 

(tâˆ’1)
(25)
|Î´| = max âˆ’xi
,
â‰¥Î½.
2


kAi k
In other words, if StingyCD+ updated coordinate i (corresponding to a nonzero weight) during iteration t, the magnitude
of the update would be at least positive value Î½.
Also, note that after any update Î´ to a coordinate i during iteration t of StingyCD+, we have (by Taylor expansion)

D
E
2
f (x(t) ) âˆ’ f (x(tâˆ’1) ) = Î» âˆ’ Ai , r(tâˆ’1) Î´ + 12 kAi k Î´ 2
2

â‰¤ âˆ’ 21 kAi k Î´ 2 .

(26)
(27)

StingyCD
0
Now define fË† = lim f (x(t) ). Consider an iteration t0 such that f (x(t ) ) â‰¤ fË† + , where we define  > 0 later.

tâ†’âˆ

(tâˆ’1)

According to (25), there exists an iteration t > t0 such that for some i for which xi

(
)




Ai , r(tâˆ’1) âˆ’ Î» 

(tâˆ’1)
,
max âˆ’xi
â‰¥Î½.
2


kAi k

> 0, we have
(28)

According to Lemma E.1, StingyCD+ will compute at least one update to coordinate i between iterations t and t + mM .
During each of the iterations between iteration t and t + mM , suppose that coordinate i0 is updated by an amount Î´ 0 . It
must be the case then that
âˆš
2
0
Î´ â‰¤
.
(29)
kAi0 k
Otherwise the fact that fË† = lim f (x(t) ) would be violated due to (27).
tâ†’âˆ

Now let T denote the iteration during which coordinate i is next updated. From the triangle inequality and (29), it follows
that


âˆš
 (tâˆ’1)

(30)
âˆ’ r(T âˆ’1)  â‰¤ mM 2 .
r
This implies that



Ai , r(T âˆ’1)
2

kAi k





âˆ’

Ai , r(tâˆ’1)
2

kAi k



h
âˆš
âˆš i
2
mM 2
âˆˆ âˆ’ mM
.
,
+
kAi k
kAi k

Now let Î´ be the update to coordinate i during iteration T . It follows that

(
)




Ai , r(T âˆ’1) âˆ’ Î» 

(T âˆ’1)
|Î´| = max xi
,

2


kAi k

(
)



âˆš

Ai , r(tâˆ’1) âˆ’ Î»  mM 2

(tâˆ’1)
,
â‰¥ max xi
âˆ’
2


kAi k
kAi k
âˆš
mM 2
â‰¥Î½âˆ’
.
kAi k
Now let us define s =

min

i0 : kAi0 k>0

(31)

(32)

(33)
(34)

kAi0 k.
=

1
8

 Î½s 2
mM

(35)

Then it follows that
|Î´| > 21 Î½ .

(36)

From (27), it follows that
f (x(T ) ) â‰¤ f (x(T âˆ’1) ) âˆ’

1
2

2

kAi k Î´ 2 â‰¤ fË† +  âˆ’ 12 s2 Î½ 2 < fË† ,

which violates the assumption that lim f (x(t) ) = fË† .
tâ†’âˆ

Thus, StingyCD+ must converge to a solution of (Pâ€™) for some set F.

Proof of Theorem 3.3. Suppose that StingyCD+ does not converge to a solution to (P).
Now define fË† = lim f (x(t) ). Also define rÌ‚ = lim r(t) and xÌ‚ = lim x(t) .
tâ†’âˆ

tâ†’âˆ

tâ†’âˆ

(37)

StingyCD

Lemma E.2 guarantees that the algorithm at least converges to a solution of (Pâ€™) for some set F. Using this assumption, if
StingyCD+ does not converge to (P)â€™s solution then there exists a Î½ > 0 such that for some i such that xÌ‚i 6= 0, we have
hAi , rÌ‚i âˆ’ Î» â‰¥ Î½ .

(38)

0
Consider an iteration t0 such that f (x(t âˆ’1) ) â‰¤ fË† + , where we define  > 0 later. By Taylor expansion, we have for any
t â‰¥ t0 ,

D
E
f (x(t) ) = f (xÌ‚) + âˆ‡f (xÌ‚), x(t) âˆ’ xÌ‚ +

2


â‰¥ fË† + 12 rÌ‚ âˆ’ r(tâˆ’1)  .
This implies that for any t â‰¥ t0 , we have

Define  =

i0

Î½2
2.
8kA
i0 k
: kAi0 k6=0

min

1
2

2


 (t)
Ax âˆ’ AxÌ‚

(39)
(40)


 âˆš


rÌ‚ âˆ’ r(tâˆ’1)  â‰¤ 2 .

(41)

It follows then that for all t â‰¥ t0 ,

D
E
âˆš
âˆš
Ai , r(tâˆ’1) âˆ’ Î» â‰¥ hAi , rÌ‚i âˆ’ kAi k 2 âˆ’ Î» â‰¥ Î½ âˆ’ kAi k 2 â‰¥ 21 Î½ .

(42)

Also, if we assume âˆ’ hAi , rri + Î» > 0, we must have
2

Ï„i =

(âˆ’ hAi , rri + Î»)

â‰¤

(43)

2

kAi k


2



âˆ’ Ai , r(tâˆ’1) + Î» + kAi k r(tâˆ’1) âˆ’ rr
2

kAi k

â‰¤ (q (tâˆ’1) âˆ’ 12 Î½)2
<q

(tâˆ’1)

(44)
(45)

.

(46)

Otherwise, we must have âˆ’ hAi , rri + Î» < 0, which ensures Ï„i â‰¤ 0 â‰¤ q (tâˆ’1) . In addition, q (tâˆ’1) is bounded as t â†’ âˆ
due to (41). As a result, whenever i is returned by get next coordinate() during an iteration t > t0 , then P (U (t) ) is
(t)
bounded away from zero. As t â†’ âˆ, the delay Di increases as, at a minimum, nonzero-valued coorinates are updated.
Thus, for an eventual iteration T , we have
(t)

P (U (t) )Di â‰¥ Î¾ (t) .

(47)

At this point, an update to coordinate i is computed. From (42), it follows that
Î´â‰¥

1
2

Î½
kAi k

,

2

(48)

which ensures that
f (x(T ) ) â‰¤ f (x(T âˆ’1) ) âˆ’
â‰¤ f (xÌ‚) +  âˆ’
â‰¤ f (xÌ‚) âˆ’

1
2

2

kAi k Î´ 2
2

1 Î½
2 kAi k2
2

3 Î½
8 kAi k2

.

(49)
(50)
(51)

This contradicts the definition of xÌ‚. Thus, our assumption that x(t) does not converge to a solution of (P ) is incorrect.

StingyCD

F. Generalizing StingyCD to Linear SVMs
In this section, we briefly describe how to apply StingyCD to the problem
minimize
n
xâˆˆR

s.t.

1
2

2

kMxk âˆ’ h1, xi

x âˆˆ [0, C]n

.

(PSVM)

We note that (PSVM) is very similar to (P). If not for the constraint that x â‰¤ C1, in fact, (PSVM) would be an instance of
(P)â€”we could solve (PSVM) by defining A = M, b = 0, and Î» = âˆ’1 and then running Algorithm 2.
To incorporate the new constraint, our CD update becomes
n
o
(tâˆ’1)
Î´SVM = min C âˆ’ xi
,Î´ .
In this case, StingyCDâ€™s same rule applies for guaranteeing coordinate i remains 0 during iteration t. With a minor change,
(tâˆ’1)
(tâˆ’1)
we can also check if xi
is guaranteed to remain C during iteration t. Specifically, if xi
= C and q (tâˆ’1) â‰¤ âˆ’Ï„i ,
then it is guaranteed that Î´SVM = 0.

StingyCD

G. Additional comparisons for Lasso problems
This section contains results using additional values of Î» for the experiments in Â§6.1. In general, we find the results to be
quite consistent, regardless of Î». Only â€œCD + Safe Screeningâ€ seems to be greatly affected by this parameter.
G.1. Full results for finance dataset
Number of examples: 1.6 Ã— 104 . Number of features: 5.5 Ã— 105 .

0.5

1.0

1.5

1.00

1.00

0.95

0.95

Support set recall

10
10âˆ’2
10âˆ’3
10âˆ’4
10âˆ’5
10âˆ’6
10âˆ’7
10âˆ’8
10âˆ’9
0.0

Support set precision

Relative suboptimality

finance, Î» = 0.1Î»max , kx? k0 = 375
âˆ’1

0.90
0.85
0.80
0.75
0.0

2.0

0.2

Time (min)

0.4

0.6

0.8

0.90
0.85
0.80
0.75
0.70
0.0

1.0

0.2

Time (min)

0.4

0.6

0.8

1.0

2.0

2.5

Time (min)

0

1

2

3

4

1.00

1.00

0.95

0.95

Support set recall

Support set precision

Relative suboptimality

finance, Î» = 0.05Î»max , kx? k0 = 1746
10âˆ’1
10âˆ’2
10âˆ’3
10âˆ’4
10âˆ’5
10âˆ’6
10âˆ’7
10âˆ’8
10âˆ’9

0.90
0.85
0.80
0.75
0.0

5

0.5

Time (min)

1.0

1.5

2.0

0.90
0.85
0.80
0.75
0.70
0.0

2.5

0.5

Time (min)

1.0

1.5

Time (min)

0

2

4

6

8

1.00

1.00

0.95

0.95

0.90
0.85
0.80
0.75

10 12 14 16

Support set recall

10
10âˆ’2
10âˆ’3
10âˆ’4
10âˆ’5
10âˆ’6
10âˆ’7
10âˆ’8
10âˆ’9

Support set precision

Relative suboptimality

finance, Î» = 0.02Î»max , kx? k0 = 6591
âˆ’1

0

1

2

Time (min)

3

4

5

6

7

0.90
0.85
0.80
0.75
0.70

8

0

1

2

Time (min)

3

4

5

6

7

8

Time (min)

0

10

20

30

40

50

1.00

1.00

0.95

0.95

Support set recall

Support set precision

Relative suboptimality

finance, Î» = 0.01Î»max , kx? k0 = 10276
10âˆ’1
10âˆ’2
10âˆ’3
10âˆ’4
10âˆ’5
10âˆ’6
10âˆ’7
10âˆ’8
10âˆ’9

0.90
0.85
0.80
0.75

0

5

Time (min)

10

15

20

25

0.90
0.85
0.80
0.75
0.70

0

Time (min)
StingyCD+

StingyCD

CD + Safe Screening

5

10

15

Time (min)
CD

20

25

StingyCD

G.2. Full results for allstate dataset
Number of examples: 2.5 Ã— 105 . Number of features: 1.5 Ã— 104 .

0

1.00

1.00

0.95

0.95

0.90
0.85
0.80
0.75

5 10 15 20 25 30 35 40 45

Support set recall

10
10âˆ’2
10âˆ’3
10âˆ’4
10âˆ’5
10âˆ’6
10âˆ’7
10âˆ’8
10âˆ’9

Support set precision

Relative suboptimality

allstate, Î» = 0.1Î»max , kx? k0 = 176
âˆ’1

0

5

10

Time (s)

15

0.90
0.85
0.80
0.75
0.70

20

0

5

10

Time (s)

15

20

Time (s)

0

10

20

30

40

1.00

1.00

0.95

0.95

0.90
0.85
0.80
0.75

50

Support set recall

10
10âˆ’2
10âˆ’3
10âˆ’4
10âˆ’5
10âˆ’6
10âˆ’7
10âˆ’8
10âˆ’9

Support set precision

Relative suboptimality

allstate, Î» = 0.05Î»max , kx? k0 = 1404
âˆ’1

0

5

10

Time (s)

15

20

0.90
0.85
0.80
0.75
0.70

25

0

5

10

Time (s)

15

20

25

Time (s)

0

20

40

60

1.00

1.00

0.95

0.95

0.90
0.85
0.80
0.75

80 100 120 140

Support set recall

10
10âˆ’2
10âˆ’3
10âˆ’4
10âˆ’5
10âˆ’6
10âˆ’7
10âˆ’8
10âˆ’9

Support set precision

Relative suboptimality

allstate, Î» = 0.02Î»max , kx? k0 = 4821
âˆ’1

0

10

20

Time (s)

30

40

50

60

0.90
0.85
0.80
0.75
0.70

70

0

10

20

Time (s)

30

40

50

60

70

Time (s)

0

50

100

150

200

250

1.00

1.00

0.95

0.95

Support set recall

10
10âˆ’2
10âˆ’3
10âˆ’4
10âˆ’5
10âˆ’6
10âˆ’7
10âˆ’8
10âˆ’9

Support set precision

Relative suboptimality

allstate, Î» = 0.01Î»max , kx? k0 = 6828
âˆ’1

0.90
0.85
0.80
0.75

0

20

40

Time (s)

60

80

100

120

0.90
0.85
0.80
0.75
0.70

0

Time (s)
StingyCD+

StingyCD

CD + Safe Screening

20

40

60

80

Time (s)
CD

100

120

StingyCD

H. Additional comparisons for logistic regression problems
H.1. Full results for lending club dataset
Number of examples: 1.1 Ã— 105 . Number of features: 3.1 Ã— 104 .

10âˆ’2
10

âˆ’3

10âˆ’4
10âˆ’5
0

2

4

6

8

10

12

1.00

1.00

0.95

0.95

0.90
0.85
0.80
0.75
0.70

14

Support set recall

Support set precision

Relative suboptimality

lending club, Î» = 0.05Î»max , kx? k0 = 272

0

2

4

6

Time (s)

8

10

12

0.90
0.85
0.80
0.75
0.70

14

0

2

4

6

Time (s)

8

10

12

20

25

14

Time (s)

10âˆ’2
10âˆ’3
10âˆ’4
10âˆ’5
0

5

10

15

20

25

1.00

1.00

0.95

0.95

0.90
0.85
0.80
0.75
0.70

30

Support set recall

Support set precision

Relative suboptimality

lending club, Î» = 0.02Î»max , kx? k0 = 878

0

5

Time (s)

10

15

20

25

0.90
0.85
0.80
0.75
0.70

30

0

5

10

Time (s)

15

30

Time (s)

10âˆ’2
10

âˆ’3

10âˆ’4
10âˆ’5

1.00

1.00

0.95

0.95

0.90
0.85
0.80
0.75
0.70

0 10 20 30 40 50 60 70 80 90

Support set recall

Support set precision

Relative suboptimality

lending club, Î» = 0.01Î»max , kx? k0 = 1937

0

0.85
0.80
0.75
0.70

10 20 30 40 50 60 70 80 90

Time (s)

0.90

0

10 20 30 40 50 60 70 80 90

Time (s)

Time (s)

10âˆ’2
10

âˆ’3

10âˆ’4
10

âˆ’5

0

50

100

150

200

250

Time (s)
StingyCD+ ProxNewton with Working Sets

1.00

1.00

0.95

0.95

Support set recall

Support set precision

Relative suboptimality

lending club, Î» = 0.005Î»max , kx? k0 = 3780

0.90
0.85
0.80
0.75
0.70

0

50

100

150

200

250

0.90
0.85
0.80
0.75
0.70

0

50

Time (s)
CD ProxNewton with Working Sets

100

150

200

250

Time (s)
StingyCD+ ProxNewton

CD ProxNewton

StingyCD

H.2. Full results for kdda dataset

kdda, Î» = 0.02Î»max , kx? k0 = 195

10âˆ’3
10

âˆ’4

10âˆ’5

1.00

1.00

0.95

0.95

Support set recall

10âˆ’2

Support set precision

Relative suboptimality

Number of examples: 8.4 Ã— 106 . Number of features: 2.2 Ã— 106 .

0.90
0.85
0.80
0.75
0.70
0.0 0.5 1.0 1.5 2.0 2.5 3.0 3.5 4.0

0.0 0.5 1.0 1.5 2.0 2.5 3.0 3.5 4.0

âˆ’4

10âˆ’5
0

1

2

3

4

1.00

0.95

0.95

0.90
0.85
0.80
0.75
0.70

5

0

1

2

4

0.85
0.80
0.75
0.70

5

0

1

2

3

4

5

Time (min)

kdda, Î» = 0.005Î»max , kx? k0 = 692

10âˆ’3
âˆ’4

10âˆ’5
1

2

3

4

5

6

7

1.00

1.00

0.95

0.95

0.90
0.85
0.80
0.75
0.70

8

Support set recall

Support set precision

Relative suboptimality

3

0.90

Time (min)

10âˆ’2

0

0

1

2

Time (min)

3

4

5

6

7

0.90
0.85
0.80
0.75
0.70

8

0

1

2

Time (min)

3

4

5

6

7

8

Time (min)

kdda, Î» = 0.002Î»max , kx? k0 = 1616

10âˆ’3
10âˆ’4
10âˆ’5
0

2

4

6

8

10

12

14

Time (min)
StingyCD+ ProxNewton with Working Sets

1.00

1.00

0.95

0.95

Support set recall

10âˆ’2

Support set precision

Relative suboptimality

Time (min)

1.00

Time (min)

10

0.75

kdda, Î» = 0.01Î»max , kx? k0 = 383

âˆ’2

10âˆ’3
10

0.80

0.70
0.0 0.5 1.0 1.5 2.0 2.5 3.0 3.5 4.0

Support set recall

10

0.85

Time (min)

Support set precision

Relative suboptimality

Time (min)

0.90

0.90
0.85
0.80
0.75
0.70

0

2

4

6

8

10

12

14

0.90
0.85
0.80
0.75
0.70

0

2

4

Time (min)
CD ProxNewton with Working Sets

6

8

10

12

14

Time (min)
StingyCD+ ProxNewton

CD ProxNewton

