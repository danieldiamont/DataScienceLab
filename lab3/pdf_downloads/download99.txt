Practical Gauss-Newton Optimisation for Deep Learning

A. Derivation of the Block-Diagonal Hessian Recursion
The diagonal blocks of the pre-activation Hessian of a feedforward neural network can be related to each other via the
recursion in (8). Starting from its definition in (6) we can derive the recursion:
!
λ+1
λ
X ∂
∂E
∂ ∂E
∂ X ∂E ∂hλ+1
∂h
∂a
a
i
i
Hλ =
=
=
λ
λ+1 ∂aλ ∂hλ
∂hλa
∂hλb ∂hλa
∂hλb i ∂hλ+1
∂h
∂h
a
a
b
i
i
i
!
!
X
X
∂2E
∂E ∂aλa
∂aλa
∂E
∂ 2 aλa
λ+1
λ+1 ∂
=
Wi,a
=
Wi,a
+
∂hλa
∂hλa ∂hλb ∂hλ+1
∂hλb ∂hλ+1
∂hλa ∂hλb
∂hλ+1
i
i
i
i
i


λ X
X
∂hλ+1
∂E
∂2E
∂ 2 aλa 
j
λ+1  ∂aa
+
=
Wi,a
δa,b
(28)
2
∂hλa j ∂hλ+1
∂hλb
∂hλ+1
∂hλ+1
∂hλa
j
i
i
i
!
λ
λ
X
∂ 2 aλa X λ+1 ∂E
∂2E
λ+1 ∂aa
λ+1 ∂ab
= δa,b
W
+
W
W
i,a
i,a
j,b
2
∂hλa ∂hλ+1
∂hλb
∂hλ+1
∂hλ+1
∂hλa
i
j
i
i
i,j
= δa,b

λ
X
∂ 2 aλa ∂E
∂2E
∂aλb λ+1
λ+1 ∂aa
W
+
W
i,a
2
∂hλa ∂hλ+1
∂hλb j,b
∂hλ+1
∂hλa ∂aλa
j
i
i,j

Hence the pre-activation Hessian can be written in matrix notation as
T
Hλ = Bλ Wλ+1
Hλ+1 Wλ+1 Bλ + Dλ

(29)

where we define the diagonal matrices
∂aλa
= δa,a0 f 0 (hλa )
∂hλa
∂ 2 aλa ∂E
00 λ ∂E
0
= δa,a0
2 ∂xλ = δa,a f (ha ) ∂xλ
λ
∂ha
a
a

[Bλ ]a,a0 = δa,a0

(30)

[Dλ ]a,a0

(31)

f 0 and f 00 are the first and second derivatives of the transfer function f respectively.
Note that this is a special case of a more general recursion for calculating a Hessian (Gower & Gower, 2016).

B. Implementation Details
Second-order optimisation methods are based on finding some positive semi-definite quadratic approximation to the function of interest around the current value of the parameters. For the rest of the appendix we define fˆ to be a local quadratic
approximation to f given a positive semi-definite curvature matrix C:
1
f (θ + δ) ≈ f (θ) + δ T ∇θ f + δ T Cδ = fˆ(δ; C)
2

(32)

The curvature matrix depends on the specific optimisation method and will often be only an estimate. For notational
simplicity, the dependence of fˆ on θ is omitted. Setting C to the true Hessian matrix of f would make fˆ the exact secondorder Taylor expansion of the function around θ. However, when f is a nonlinear function, the Hessian can be indefinite,
which leads to an ill-conditioned quadratic approximation fˆ. For this reason, C is usually chosen to be positive-semi
definite by construction, such as the Gauss-Newton or the Fisher matrix. In the experiments discussed in the paper, C
can be either the full Gauss-Newton matrix Ḡ, obtained from running Conjugate Gradient as in (Martens, 2010), or a
e The analysis below is independent of whether this approximation is
block diagonal approximation to it, denoted by G.
based on KFLR, KFRA, KFAC or if it is the exact block-diagonal part of Ḡ, hence there will be no reference to a specific
approximation.
Damping plays an important role in second-order optimisation methods. It can improve the numerical stability of the
quadratic approximation and can also be related to trust region methods. Hence, we will introduce two damping coefficients
e In practice, an additional weight decay term is often applied to neural network models. As a
- one for Ḡ and one for G.
result and following the presentation in (Martens & Grosse, 2015), a total of three extra parameters are introduced:

Practical Gauss-Newton Optimisation for Deep Learning

e
• A L2 regularisation on θ with weight η2 , which implies an additive diagonal term to both Ḡ and G
• A damping parameter τ added to the full Gauss-Newton matrix Ḡ
e
• A separate damping parameter γ added to the approximation matrix G
Subsequently, for notational convenience, we define C̄ = Ḡ + (τ + η)I, which is the curvature matrix obtained when using
e=G
e + (γ + η)I is the curvature matrix
the full Gauss-Newton matrix in the quadratic approximation (32). Similarly, C
obtained when using any of the block-diagonal approximations.
B.1. Inverting the Approximate Curvature Matrix
The Gauss-Newton method calculates its step direction by multiplying the gradient with the inverse of the curvature matrix,
e This gives the unmodified step direction:
in this case C.
e −1 ∇θ f
δe = C

(33)

e is a block diagonal matrix (each block corresponds to the parameters of a single layer) the problem naturally
Since C
factorises to solving L independent linear systems:
e −1 ∇W f
δeλ = C
λ
λ

(34)

e λ have a
For all of the approximate methods under consideration – KFLR, KFRA and KFAC – the diagonal blocks G
e
e
e
e
Kronecker factored form Qλ ⊗ G λ , where Qλ = E [Qλ ] and G λ denotes the approximation to E [Gλ ] obtained from the
method of choice. Setting k = (η + γ) implies:
eλ = Q
eλ ⊗ G
e λ + kI ⊗ I
C

(35)

eλ requires the eigen decomposition of both matrices Q
e λ and G
eλ,
The exact calculation of (34) given the structural form of C
−1
−1
−1
see (Martens & Grosse, 2015). However, the well known Kronecker identity (A ⊗ B) vec (V ) = A V B motivates
the following approximation:

√ 
√  
e λ + ω −1 kI
eλ ⊗ G
e λ + kI ⊗ I ≈ Q
e λ + ω kI ⊗ G
Q

(36)

The optimal setting of ω can be found analytically by bounding the norm of the approximation’s residual, namely:

√  
√ 
eλ ⊗ G
e λ + kI ⊗ I − Q
e λ + ω kI ⊗ G
e λ + ω −1 kI
R(ω) = Q
√
√
eλ ⊗ I − ω kG
eλ ⊗ I
= −ω −1 k Q
√
√
e λ ⊗ I|| + ω k||G
e λ ⊗ I||
||R(π)|| ≤ ω −1 k||Q

(37)

Minimising the right hand side with respect to ω gives the solution
s
ω=

e λ ⊗ I||
||Q
fλ ||
||I ⊗ G

(38)

The choice of the norm is arbitrary, but for comparative purposes with previous work on KFAC, we use the trace norm
in all of our experiments. Importantly, this approach is computationally cheaper as it requires solving only two linear
systems per layer, compared to an eigen decomposition and four matrix-matrix multiplications for the exact calculation.
Alternatively, one can consider this approach as a special form of damping for Kronecker factored matrices.

Practical Gauss-Newton Optimisation for Deep Learning

B.2. Choosing the Step Size
The approximate block diagonal Gauss-Newton update can be significantly different from the full Gauss-Newton update.
It is therefore important, in practice, to choose an appropriate step size, especially in cases where the curvature matrices
are estimated from mini-batches rather than the full dataset. The step size is calculated based on the work in (Martens &
Grosse, 2015), using the quadratic approximation fˆ(δ; C̄) from (32), induced by the full Gauss-Newton matrix. Given the
initial step direction δe from (33) a line search is performed along that direction and the resulting optimal step size is used
for the final update.
e C̄) = arg min f (θ) + αδeT ∇f + 1 α2 δeT C̄ δe
α∗ = arg min fˆ(αδ;
2
α
α

(39)

This can be readily solved as
δeT ∇f e
δ
δ∗ = α∗ δe = −
δeT C̄ δe

(40)

where
δeT C̄ δe = δeT Ḡδe + (τ + η)δeT δe

(41)

The term δeT Ḡδ can be calculated efficiently (without explicitly evaluating Ḡ) using the R-operator (Pearlmutter, 1994).
The final update of the approximate GN method is δ∗ . Notably, the damping parameter γ affects the resulting update
e whilst τ affects only the step size along that direction.
direction δ,
B.3. Adaptive Damping
B.3.1. τ
In order to be able to correctly adapt τ to the current curvature of the objective we use a Levenberg-Marquardt heuristic
based on the reduction ratio ρ defined as
ρ=

f (θ + δ∗ ) − f (θ)
ˆ
f (δ∗ ; C̄) − fˆ(0; C̄)

(42)

This quantity measures how well the quadratic approximation matches the true function. When ρ < 1 it means that the
true function f has a lower value at θ + δ∗ (and thus the quadratic underestimates the curvature), while in the other case
the quadratic overestimates the curvature. The Levenberg-Marquardt method introduces the parameter ωτ < 1. When
ρ > 0.75 the τ parameter is multiplied by ωτ , when ρ < 0.75 it is divided by ωτ . In order for this to not introduce a
significant computational overhead (as it requires an additional evaluation of the function – f (θ + δ∗ )) we adapt τ only
every Tτ iterations. For all experiments we used ωτ = 0.95Tτ and Tτ = 5.
B.3.2. γ
e induced by the approximate GaussThe role of γ is to regularise the approximation of the quadratic function fˆ(δ, C)
Newton to that induced by the full Gauss-Newton fˆ(δ, C̄). This is in contrast to τ , which regularises the quality of the
e reflects the full
latter approximation to the true function. γ can be related to how well the approximate curvature matrix C
Gauss-Newton matrix. The main reason for having two parameters is because we have two levels of approximations, and
each parameter independently affects each one of them:
τ

γ

e
f (θ + δ) ≈ fˆ(δ; C̄) ≈ fˆ(δ; C)

(43)

The parameter γ is updated greedily. Every Tγ iterations the algorithm computes the update δ∗ for each of {ωγ γ, γ, ωγ−1 γ, }
and some scaling factor ωγ < 1. From these three values the one that minimises fˆ(δ; C̄) is selected. Similar to the previous
section, we use ωγ = 0.95Tγ and Tγ = 20 across all experiments.

Practical Gauss-Newton Optimisation for Deep Learning

B.4. Parameter Averaging
Compared with stochastic first-order methods (for example stochastic gradient descent), stochastic second-order methods
do not exhibit any implicit averaging. To address this, Martens & Grosse (2015) introduce a separate value θbt which tracks
the moving average of the parameter values θt used for training:
θbt = βt θbt−1 + (1 − βt )θt

(44)

Importantly, θbt has no effect or overhead on training as it is not used for the updates on θt . The extra parameter βt is chosen
such that in the initial stage when t is small, θbt is the exact average of the first t parameter values of θ:
βt = min(0.95, 1 − 1/t)

(45)

Another factor playing an important role in stochastic second-order methods is the mini-batch size m. In Martens & Grosse
(2015), the authors concluded that because of the high signal to noise ratio that arises close to the minimum, in practice
one should use increasingly larger batch sizes for KFAC as the optimisation proceeds. However, our work does not focus
on this aspect and all of the experiments are conducted using a fixed batch size of 1000.

C. The Fisher Matrix and KFAC
C.1. The Fisher Matrix
For a general probability distribution pθ (x) parametrised by θ, the Fisher matrix can be expressed in two equivalent forms
(Martens, 2014):
h
i
F̄ = E ∇θ log pθ (x)∇θ log pθ (x)T
pθ (x)
(46)
= −E [∇∇ log pθ (x)]pθ (x)
By construction the Fisher matrix is positive semi-definite. Using the Fisher matrix in place of the Hessian to form the
parameter update F̄ −1 g is known as Natural Gradient (Amari, 1998).
In the neural network setting, the model specifies a conditional distribution pθ (y|x), and the Fisher matrix is given by
h
i
F̄ = E ∇θ log pθ (x, y)∇θ log pθ (x, y)T
pθ (x,y)
h
i
(47)
= E ∇θ log pθ (y|x)∇θ log pθ (y|x)T
pθ (x,y)

T

Using the chain rule ∇θ log pθ (y|x) = JθhL ∇hL log pθ (y|x) and defining
FL ≡ ∇hL log pθ (y|x)∇hL log pθ (y|x)T

(48)

the Fisher can be calculated as:
h
i
T
F̄ = E JθhL ∇hL log pθ (y|x)∇hL log pθ (y|x)T JθhL
pθ (x,y)
h
i
hL T
hL
= E Jθ FL Jθ

(49)

pθ (x,y)

The equation is reminiscent of (12) and in Appendix C.2 we discuss the conditions under which the Fisher and the GaussNewton matrix are indeed equivalent.
C.2. Equivalence between the Gauss-Newton and Fisher Matrices
The expected Gauss-Newton matrix is given by
i
h
i
h
T
T
Ḡ = E JθhL HL JθhL
= E JθhL E [HL ]p(y|x) JθhL
p(x,y)

p(x)

(50)

Practical Gauss-Newton Optimisation for Deep Learning

Using that E [FL ] = E [HL ] which follows from (46) and the fact that the Jacobian JθhL is independent of y, the Fisher
matrix can be expressed as:
h
i
h
i
h
i
T
T
T
F̄ = E JθhL FL JθhL
= E JθhL E [FL ]pθ (y|x) JθhL
= E JθhL E [HL ]pθ (y|x) JθhL
(51)
pθ (x,y)

p(x)

p(x)

Hence the Fisher and Gauss-Newton matrices matrices are equivalent when E [HL ]p(y|x) = E [HL ]pθ (y|x) . Since the
model distribution pθ (y|x) and the true data distribution p(y|x) are not equal, a sufficient condition for the expectations to
be equal is HL being independent of y. Although this might appear restrictive, if hL parametrises the natural parameters
of an exponential family distribution this independence holds (Martens, 2014). To show this, consider
log p(y|x, θ) = log h(y) + T (y)T η(x, θ) − log Z(x, θ) = log h(y) + T (y)T hL − log Z(hL )

(52)

where h is the base measure, T is the sufficient statistic, Z is the partition function and η are the natural parameters. Taking
the gradient of the log-likelihood with respect to hL
∇hL log p(y|x, θ) = T (y) − ∇hL log Z(hL )

(53)

Assuming that the objective is the negative log-likelihood as in Section 2.1 and differentiating again
HL = ∇∇hL log Z(hL )

(54)

which is indeed independent of y. This demonstrates that in many practical supervised learning problems in Machine
Learning, the Gauss-Newton and Natural Gradient methods are equivalent.
The parameter update for these approaches is then given by computing Ḡ−1 g or F̄ −1 g, where g is the gradient of the
objective with respect to all parameters. However, the size of the linear systems is prohibitively large in the case of neural
networks, thus it is computationally infeasible to solve them exactly. As shown in (Schraudolph, 2002), matrix-vector
products with Ḡ can be computed efficiently using the R-operator (Pearlmutter, 1994). The method does not need to
compute Ḡ explicitly, at the cost of approximately twice the computation time of a standard backward pass. This makes
it suitable for iterative methods such as conjugate gradient for approximately solving the linear system. The resulting
method is called ‘Hessian-free’, with promising results in deep feedforward and recurrent neural networks (Martens, 2010;
Martens & Sutskever, 2011). Nevertheless, the convergence of the conjugate gradient step may require many iterations by
itself, which can significantly increase the computation overhead compared to standard methods. As a result, this approach
can have worse performance per clock time compared to a well-tuned first-order method (Sutskever et al., 2013). This
motivates the usage of approximate Gauss-Newton methods instead.
C.3. The Fisher Approximation to E [Gλ ] and KFAC
The key idea in this approach is to use the fact that the Fisher matrix is an expectation of the outer product of gradients and
that it is equal to the Gauss-Newton matrix (Section C.2). This is independent of whether the Gauss-Newton matrix is with
respect to Wλ or hλ , so we can write the pre-activation Gauss-Newton as

h
i
T
E [Gλ ]p(x,y) = E JhhλL HL JhhλL
p(x)
h
i
T
= E JhhλL E [FL ]pθ (y|x) JhhλL
p(x)
h
i
hL T
hL
= E Jhλ FL Jhλ
pθ (x,y)
h
i
hL T
= E Jhλ ∇hL log pθ (y|x)∇hL log pθ (y|x)T JhhλL
pθ (x,y)
h
i
T
= E ∇hλ log pθ (y|x)∇hλ log pθ (y|x)
pθ (x,y)

where the first equality follows from (54) and the second one from (51) in the supplement.

(55)
(56)
(57)
(58)
(59)

Practical Gauss-Newton Optimisation for Deep Learning

We stress here that the resulting expectation is over the model distribution pθ (x, y) and not the data distribution p(x, y). In
order to approximate (59) the method proceeds by taking Monte Carlo samples of the gradients from the model conditional
distribution pθ (y|x).
The KFAC approximation presented in (Martens & Grosse, 2015) is analogous to the above approach, but it is derived
hλ
in a different way. The authors directly focus on the parameter Fisher matrix. Using the fact that JW
= aTλ−1 ⊗ I and
λ
T

hλ
JW
v = aλ−1 ⊗ v, the blocks of the Fisher matrix become:
λ
i
h
 
F̄ λ,β = E ∇Wλ log pθ (y|x)∇Wβ log pθ (y|x)T
pθ (x,y)
h
T i
= E (aλ−1 ⊗ ∇hλ log pθ (y|x)) aβ−1 ⊗ ∇hβ log pθ (y|x)
pθ (x,y)
i
 
h
T
T
= E aλ−1 aβ−1 ⊗ ∇hλ log pθ (y|x)∇hβ log pθ (y|x)
pθ (x,y)

(60)
(61)
(62)

This equation is equivalent to our result in (16) 13 . In (Martens & Grosse, 2015) the authors similarly approximate the
expectation of the Kronecker products by the product of the individual expectations, which makes the second term equal
to the pre-activation Gauss-Newton as in (59).
C.4. Differences between KFAC and KFRA
It is useful to understand the computational complexity of both KFAC and KFRA and the implications of the approximations. In order to not make any additional assumptions about the underlying hardware or mode (serial or parallel) of
execution, we denote with Omm (m, n, p) the complexity of a matrix matrix multiplication of an m × n and n × p matrices
and with Oel (m, n) the complexity of an elementwise multiplication of two matrices of size m × n.
KFRA We need to backpropagate the matrix E [Gλ ] of size Dλ × Dλ , where Dλ is the dimensionality of the layer.
For each layer, this requires two matrix-matrix multiplications with Wλ and single element wise multiplication (this
is due to Aλ being diagonal, which allows for such a simplification). The overall complexity of the procedure is
2Omm (Dλ , Dλ , Dλ−1 ) + Oel (Dλ−1 , Dλ−1 ).
KFAC We need to draw samples from pθ (y|x) for each datapoint x and backprogate the corresponding gradients through
the network (this is in addition to the gradients of the objective function). This requires backpropagating a matrix of
size Dλ−1 × N S, where S denotes the number of samples taken per datapoint. Per layer, the method requires also two
matrix-matrix multiplications (one with Wλ and the outer product of Cλs ) and a single element wise multiplication.
The overall complexity of the procedure is Omm (N S, Dλ , Dλ−1 ) + Oel (N S, Dλ−1 ) + Omm (Dλ−1 , N S, Dλ−1 ).
There are several observations which we deem important. Firstly, if N = 1, KFRA is no longer an approximate method,
but computes the exact Gλ matrix. Secondly, if S = 1 and Dλ ∼ N then the two methods have similar computational
complexity. If we assume that the complexity scales linearly in S, in the extreme case of S = N and Dλ ∼ N , it is
possible to execute KFRA independently for each datapoint providing the exact value Gλ for the same computational cost,
while KFAC would nevertheless still be an approximation.

D. The Rank of the Monte Carlo Gauss-Newton
Using the definition of the sample Gauss-Newton matrix in (12) we can infer that its rank is bounded by the rank of HL :
T

G ≡ JθhL HL JθhL ⇒ rank(G) ≤ rank(HL )

(63)

This does not provide any bound on the rank of the “true” Gauss-Newton matrix, which is an expectation of the above.
However, for any practical algorithm which approximates the expectations via N Monte Carlo samples as:
Ḡ = E [G] ≈
13

1 X
Gn
N n

Under the condition that the Fisher and Gauss-Newton matrices are equivalent, see Section C.2

(64)

Practical Gauss-Newton Optimisation for Deep Learning

it provides a bound
on the rank of the resulting matrix. Using the sub-additive property of the rank operator, it follows
P
that rank( N1 n Gn ) ≤ rank(HL )N . Similarly, the approximate Fisher matrix computed in KFAC will have a rank
bounded by N S, where S is the number of samples taken per data point (usually one). This provides an explanation for
the results in Section 5.2 for binary classification, since the last layer output in this problem is a scalar, thus its rank is
1. Hence, both the Gauss-Newton and the Fisher for a mini-batch have a rank bounded by the mini-batch size N . This
leads to the conclusion that in such a situation the curvature information provided from a Monte-Carlo estimate is not
sufficient to render the approximate Gauss-Newton methods competitive against well-tuned first order methods, although
we observe that in the initial stages they are still better. In some of the more recent works on KFAC the authors use
momentum terms in conjunction with the second-order updates or do not rescale by the full Gauss-Newton. This leaves
space for exploration and more in depth research on developing techniques that can robustly and consistently improve the
performance of second-order methods for models with a small number of outputs and small batch sizes.

E. Absence of Smooth Local Maxima for Piecewise Linear Transfer Functions
In order to show that the Hessian of a neural network with piecewise linear transfer functions can have no differentiable
strict local maxima, we first establish that all of its diagonal blocks are positive semi-definite.
Lemma 1. Consider a neural network as defined in (1). If the second derivative of all transfer functions fλ for 1 ≤ λ ≤ L
is zero where defined, and if the Hessian of the error function w.r.t. the outputs of the network is positive semi-definite, then
all blocks
∂2E
(65)
Hλ =
∂vec (Wλ )∂vec (Wλ )
on the diagonal of the Hessian — corresponding to the weights Wλ of single layer — are positive semi-definite.
λ
Proof. By the definition in (10) Di,j
= δi,j f 00 (hλi,j ). From the assumption of the lemma, f 00 = 0 for all layers, hence
∀λ Dλ = 0. Using the recursive equation (8) we can analyze the quadratic form v T Hλ v:
T
Hλ = Bλ Wλ+1
Hλ+1 Wλ+1 Bλ + Dλ
T

= (Wλ+1 Bλ ) Hλ+1 (Wλ+1 Bλ )

(66)

where we used the fact that by definition Bλ is a diagonal matrix, thus it is symmetric and Bλ = BλT . Defining
ṽ = Wλ+1 Bλ v

(67)

yields
T

v T Hλ v = (Wλ+1 Bλ v) Hλ+1 (Wλ+1 Bλ v)
= ṽ T Hλ+1 ṽ

(68)

hence
Hλ+1 ≥ 0 ⇒ Hλ ≥ 0

(69)

It follows by induction that if HL is positive semi-definite, all of the pre-activation Hessian matrices are positive semidefinite as well.
Using the proof that the blocks Hλ can be written as a Kronecker product in (7), we can analyze the quadratic form of the
Hessian block diagonals:
h

i
T
T
vec (V ) Hλ vec (V ) = vec (V )
aλ aTλ ⊗ Hλ vec (V )


T
= vec (V ) vec Hλ V aλ aTλ


= trace V T Hλ V aλ aTλ
(70)


T T
= trace aλ V Hλ V aλ
T

= (V aλ ) Hλ (V aλ )
Hλ ≥ 0 ⇒ Hλ ≥ 0

Practical Gauss-Newton Optimisation for Deep Learning


The second line follows from the well known identity (A ⊗ B)vec (V ) = vec BV AT . Similarly, the third line follows

T
from the fact that vec (A) vec (B) = trace AT B . The fourth line uses the fact that trace (AB) = trace (BA) when the
product AB is a square matrix. This concludes the proof of the lemma.

This lemma has two implications:
• If we fix the weights of all layers but one, the error function becomes locally convex, wherever the second derivatives
of all transfer functions in the network are defined.
• The error function can have no differentiable strict local maxima.
We formalise the proof of the second proposition below:
Lemma 2. Under the same assumptions as in Lemma 1, the overall objective function E has no differentiable strict local
maxima with respect to the parameters θ of the network.
Proof. For a point to be a strict local maximum, all eigenvalues of the Hessian at this location would need to be simultaneously negative. However, as the trace of a matrix is equal to the sum of the eigenvalues it is sufficient to prove that
trace (H) ≥ 0.
The trace of the full Hessian matrix is equal to the sum of the diagonal elements, so it is also equal to the sum of the
traces of the diagonal blocks. Under the assumptions in Lemma 1, we showed that all of the diagonal blocks are positive
semi-definite, hence their traces are non-negative. It immediately follows that:
trace (H) =

L
X

trace (Hλ ) ≥ 0

(71)

λ=1

Therefore, it is impossible for all eigenvalues of the Hessian to be simultaneously negative. As a corollary it follows that
all strict local maxima must lie in the non-differentiable boundary points of the nonlinear transfer functions.

Practical Gauss-Newton Optimisation for Deep Learning

F. Additional Figures
F.1. CPU Benchmarks

(a) CURVES

(b) FACES

(c) MNIST
Figure 4. Optimisation performance on the CPU. These timings are obtained with a previous implementation in Arrayfire, different to
the one used for the figures in the main text. For the second-order methods, the asterisk indicates the use of the approximate inversion
as described in Section B.1. The error function on all three datasets is binary cross-entropy.

Practical Gauss-Newton Optimisation for Deep Learning

F.2. Comparison of the Alignment of the Approximate Updates with the Gauss-Newton Update

(a) Block-diagonal Gauss-Newton

(b) Full Gauss-Newton

Figure 5. CURVES: Cosine similarity between the update vector per layer, given by the corresponding approximate method, δeλ with
that for the block-diagonal GN (a) and the full vector with that from the full GN matrix (b). The optimal value is 1.0. The ∗ indicates
approximate inversion in (36). The x-axis is the number of iterations. Layers one to four are in the top; five to eight in the bottom row.
The trajectory of parameters we follow is the one generated by KFRA∗ .

(a) Block-diagonal Gauss-Newton

(b) Full Gauss-Newton

Figure 6. FACES: Cosine similarity between the update vector per layer, given by the corresponding approximate method, δeλ with that
for the block-diagonal GN (a) and the full vector with that from the full GN matrix (b). The optimal value is 1.0. The ∗ indicates
approximate inversion in (36). The x-axis is the number of iterations. Layers one to four are in the top; five to eight in the bottom row.
The trajectory of parameters we follow is the one generated by KFRA∗ .

To gain insight into the quality of the approximations that are made in the second-order methods under consideration, we
compare how well the KFAC and KFRA parameter updates δe are aligned with updates obtained from using the regularised
block diagonal GN and the full GN matrix. Additionally we check how using the approximate inversion of the Kronecker
factored curvature matrices discussed in Appendix B impacts the alignment.
In order to find the updates for the full GN method we use conjugate gradients and the R-operator and solve the linear
system Ḡδ = ∇θ f as in (Martens, 2010). For the block diagonal GN method we use the same strategy, however the
method is applied independently for each separate layer of the network, see Appendix B.
We compared the different approaches for batch sizes of 250, 500 and 1000. However, the results did not differ significantly.
We therefore show results only for a batch size of 1000. In Figures 5 to 7, subfigure 6a plots the cosine similarity between
the update vector δeλ for a specific layer, given by the corresponding approximate method, and the update vector when
using the block diagonal GN matrix on CURVES, FACES and MNIST. Throughout the optimisation, compared to KFAC,
the KFRA update has better alignment with the exact GN update. Subfigure 6b shows the same similarity for the whole
e however in comparison with the update vector given by the full GN update. Additionally, we also show the
update vector δ,
similarity between the update vector of the block diagonal GN and the full GN approach in those plots. There is a decay
in the alignment between the block-diagonal and full GN updates towards the end of training on FACES, however this is
most likely just due to the conjugate gradients being badly conditioned and is not observed on the other two datasets.

Practical Gauss-Newton Optimisation for Deep Learning

(a) Block-diagonal Gauss-Newton

(b) Full Gauss-Newton

Figure 7. MNIST: Cosine similarity between the update vector per layer, given by the corresponding approximate method, δeλ with that
for the block-diagonal GN (a) and the full vector with that from the full GN matrix (b). The optimal value is 1.0. The ∗ indicates
approximate inversion in (36). The x-axis is the number of iterations. Layers one to four are in the top; five to eight in the bottom row.
The trajectory of parameters we follow is the one generated by KFRA∗ .

After observing that KFRA generally outperforms KFAC, it is not surprising to see that its updates are beter aligned with
both the block diagonal and the full GN matrix.
Considering that (for exponential family models) both methods differ only in how they approximate the expected GN
matrix, gaining a better understanding of the impact of the separate approximations on the optimisation performance could
lead to an improved algorithm.

Practical Gauss-Newton Optimisation for Deep Learning

G. Algorithm for a Single Backward Pass
Algorithm 1 Algorithm for KFRA parameter updates excluding heuristic updates for η and γ
Input: minibatch X, weight matrices W1:L , transfer functions f1:L , true outputs Y , parameters η and γ
- Forward Pass a0 = X
for λ = 1 to L do
hλ = Wλ aλ−1
aλ = fλ (hλ )
end for
- Derivative
 and Hessian of the objective ∂E 
dL = ∂hL 
hL 

f
GLλ = E [HL ]
hL

- Backward pass for λ = L to 1 do
- Update for Wλ gλ = N1 dλ aTλ−1 + ηWλ
e λ = 1 aλ−1 aT
Q
λ−1
rN
e λ )∗dim(G
e
T r(Q
ω = T r(Ge )∗dim(Qeλ ))
λ
λ
√
k = γ+η
e λ + ωk)−1 gλ (G
e λ + ω −1 k)−1
δeλ = (Q
if λ > 1 then
- Propagate gradient and approximate pre-activation Gauss-Newton Aλ−1 = f 0 (hλ−1 )
dλ−1 = WλT dλ  Aλ−1

1
T
e λ−1 = (W T G
e
G
λ λ Wλ )  N Aλ−1 Aλ−1
end if
end for
v = JθhL δe
(using the R-op from (Pearlmutter, 1994))
T
T e
e
δ Ḡδ = v HL v
e 2
δeT C̄ δe = δeT Ḡδe + (τ + η)||δ||
2
eT ∇f
δ
α∗ = − eT e
δ C̄ δ
δ∗ = α∗ δe
for λ = 1 to L do
Wλ = Wλ + δ∗λ
end for

