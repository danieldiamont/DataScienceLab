Conditional Accelerated Lazy Stochastic Gradient Descent

Guanghui Lan * 1 Sebastian Pokutta * 1 Yi Zhou * 1 Daniel Zink * 1

Abstract

Compared to most other first-order methods, such as e.g.,
gradient descent algorithms and accelerated gradient algorithms (Nesterov, 1983; 2004), the CG method is computationally cheaper in some cases, since it only requires the
solution of a linear optimization subproblem (3) rather than
an often costly projection onto the feasible region X.

In this work we introduce a conditional accelerated lazy stochastic gradient descent algorithm
with optimal number of calls to a stochastic firstorder oracle and convergence rate O( Îµ12 ) improving over the projection-free, Online Frank-Wolfe
based stochastic gradient descent of (Hazan and
Kale, 2012) with convergence rate O( Îµ14 ).

1. Introduction
The conditional gradient method (also known as: FrankWolfe algorithm) proposed in (Frank and Wolfe, 1956),
gained much popularity in recent years due to its simple
projection-free scheme and fast practical convergence rates.
We consider the basic convex programming (CP) problem
f âˆ— := min f (x),
xâˆˆX

(1)

where X âŠ† Rn is a closed convex set and f : X â†’ R is a
smooth convex function such that âˆƒL > 0,
kf 0 (x) âˆ’ f 0 (y)kâˆ— â‰¤ Lkx âˆ’ yk, âˆ€ x, y âˆˆ X.

(2)

The classic conditional gradient (CG) method solves (1) iteratively by minimizing a series of linear approximations of f
over the feasible set X. More specifically, given xkâˆ’1 âˆˆ X
at the k-th iteration, it updates xk according to the following
steps:
1) Call the first-order (FO) oracle to compute
(f (xkâˆ’1 ), f 0 (xkâˆ’1 )) and set pk = f 0 (xkâˆ’1 ).
2) Call the linear optimization (LO) oracle to compute
yk âˆˆ argminxâˆˆX hpk , xi.

(3)

3) Set xk = (1 âˆ’ Î»k )xkâˆ’1 + Î»k yk for some Î»k âˆˆ [0, 1].
*
Equal contribution 1 ISyE, Georgia Institute of Technology, Atlanta, GA. Correspondence to: Daniel Zink
<daniel.zink@gatech.edu>.

Proceedings of the 34 th International Conference on Machine
Learning, Sydney, Australia, PMLR 70, 2017. Copyright 2017 by
the author(s).

There has been extensive and fruitful research on the general class of linear-optimization-based convex programming (LCP) methods (which covers the CG method and
its variants) and their application in machine learning (e.g.,
(Ahipasaoglu and Todd, 2013; Bach et al., 2012; Beck and
Teboulle, 2004; Cox et al., 2013; Clarkson, 2010; Freund
and Grigas, 2013; Hazan, 2008; Harchaoui et al., 2012;
Jaggi, 2011; 2013; Jaggi and SulovskÃ½, 2010; Luss and
Teboulle, 2013; Shen et al., 2012; Hazan and Kale, 2012;
Lan, 2013; Lan and Zhou, 2014; Braun et al., 2016)). It
should be noted that even the computational cost for LO
oracle to solve the linear optimization subproblem (3) is
high for some complex feasible regions. Recently, several
approaches have been considered to address this issue. Jaggi
demonstrated practical speed up for the CG method by approximately solving (3) in (Jaggi, 2013). Braun, Pokutta,
and Zink in (Braun et al., 2016) proposed a class of modified CG methods, namely the lazy conditional gradient
(LCG) algorithms, which calls a weak separation oracle
rather than solving the linear subproblem (3) in the classical
CG method. In fact, the weak separation oracle is computationally more efficient than approximate minimization
used in (Jaggi, 2013), at the expense of not providing any
guarantee for function value improvement with respect to
(3). Furthermore, as shown in (Jaggi, 2013; Lan, 2013), the
total number of iterations for the LCP methods to find an
-solution of (1) (i.e., a point xÌ„ âˆˆ X, s.t. f (xÌ„) âˆ’ f âˆ— â‰¤ )
cannot be smaller than O(1/), which is not improvable
even when the objective function f is strongly convex.
Improved complexity results can only be obtained under
stronger assumptions on the LO oracle or the feasible set
(see, e.g., (Garber and Hazan, 2013; Lan, 2013)). However,
the O(1/) bound does not preclude the existence of more
efficient LCP algorithms for solving (1). Lan and Zhou in
(Lan and Zhou, 2014) proposed a class of conditional gradient sliding methods (CGS), which significantly improve
the complexity bounds in terms of the number of gradient
evaluations while maintaining optimal complexity bounds

Conditional Accelerated Lazy Stochastic Gradient Descent

for the LO oracle calls required by the LCP methods.

Contributions

Inspired by (Braun et al., 2016) and (Lan and Zhou, 2014),
in this paper we focus on a class of modified LCP methods
that require only improving solutions for a certain separation problem rather than solving the linear optimization
subproblem (3) explicitly through LO oracle calls while
simultaneously minimizing the number of gradient evaluations when performing weak separation over the feasible set
X. At first these two objectives seem to be incompatible as
(Braun et al., 2016) give up the dual guarantee to simplify
the oracle, while the dual guarantee of CG iterations is at the
core of the analysis in (Lan and Zhou, 2014). We overcome
this impasse by carefully modifying both techniques.

Our main contributions can be briefly summarized as follows. We consider stochastic smooth optimization, where
we have only access unbiased estimators of the gradients of
f via a stochastic first-order (SFO) oracle. By incorporating a modified LCG procedure (Braun et al., 2016) into a
modified CGS method (Lan and Zhou, 2014) we obtain a
new conditional accelerated lazy stochastic gradient descent
algorithm (CALSGD) and we show that the number of calls
to the weak separation oracle can be optimally bounded by
O(1/), while the optimal bound of O(1/2 ) on the total
number of calls to the SFO oracle can be maintained. In
addition, if the exact gradients of f can be accessed by a
FO oracle,
âˆš the latter bound can be significantly improved to
O(1/ ). In order to achieve the above we will present a
modified lazy conditional gradient method, and show that
the total number of iterations (or calls to the weak separation
oracle) performed by it can be bounded by O(1/) under
a stronger termination criterion, i.e., the primal-dual gap
function.

It should be mentioned that Hazan and Kale in (Hazan
and Kale, 2012) proposed the online Frank-Wolfe (OFW)
algorithm, which obtains O(1/4 ) rate of convergence for
stochastic problems. Indeed, if we consider the objective
function f (x) := E[F (x, Î¾)] for stochastic optimization,
the OFW method can be applied to solve (1) by viewing the
iteratively observed function ft as the current realization of
the true objective function f , i.e., ft (Â·) = F (Â·, Î¾t ). Without
re-evaluating the (sub)gradients at the updated points, the
OFW obtains O(T âˆ’1/4 ) bound for any (smooth or nonsmooth) objective functions (see Theorem 4.4 in (Hazan and
Kale, 2012)), which implies O(1/4 ) rate of convergence
in terms of the number of (sub)gradient evaluations for
stochastic optimization. However, we can show that our
proposed algorithm obtains O(1/) (resp., O(1/2 )) rate
of convergence for smooth (resp., non-smooth) stochastic
problems, which is much better than the convergence rate of
the OFW method. We would like to stress that the stochastic
optimization bound in (Hazan and Kale, 2012, Theorem 4.1)
which gives a guarantee of O(1/2 ), requires to re-evaluate
all gradients at the current iterate and as such the number
of gradient evaluations required grows quadratically in t.
Moreover, Hazan and Luo (2016) proposed two methods for
solving the special case of Problem (1) of the form
m

1 X
min f (x) = min
fi (x),
xâˆˆX
xâˆˆX m
i=1
which allows for a potentially smaller number of SFO evaluations than O(1/Îµ2 ), the lower bound for the general
problem. The two methods Stochastic Variance-Reduced
Frank-Wolfe (SVRF) and Stochastic Variance-Reduced Conditional Gradient Sliding (STORC) are obtained by applying
the variance reduction idea of Johnson and Zhang (2013)
and Mahdavi et al. (2013) to the CG method and the Stochastic CGS method respectively. Both algorithms however need
a certain number of exact (or full) gradient evaluations leading to a potentially undesirable dependence on the number
of examples m.

We also consider strongly convex and smooth functions and
show that without enforcing any stronger assumptions on the
weak separation oracle or the feasible set X, the total number of calls to the FO (resp., SFO) oracle can be optimally
bounded by O(log 1/) (resp., O(1/)) for variants of the
proposed method to solve deterministic (resp., stochastic)
strongly convex and smooth problems. Furthermore, we
also generalize the proposed algorithms to solve an important class of non-smooth convex programming problems
with a saddle point structure. By adaptively approximating the original non-smooth problem via a class of smooth
functions, we are able to show that the deterministic version
of CALSGD can obtain an -solution within O(1/) number of linear operator evaluations and O(1/2 ) number of
calls to the weak separation oracle, respectively. The former
bound will increase to O(1/2 ) for non-smooth stochastic
optimization.
Finally, we demonstrate practical speed ups of CALSGD
through preliminary numerical experiments for the video
co-localization problem, the structured regression problem
and quadratic optimization over the standard spectrahedron;
an extensive study is beyond the scope of this paper and
left for future work. In all cases we report a substantial
improvements in performance.
In the main body of the paper we focus on the stochastic
smooth case; several other results and their proofs have been
relegated to the Supplementary Material.
1.1. Notation and Terminology
Let X âŠ† Rn be a convex compact set, and k Â· kX be the
norm associated with the inner product in Rn . For the sake

Conditional Accelerated Lazy Stochastic Gradient Descent

of simplicity, we often skip the subscript in the norm k Â· kX .
We define the diameter of the set X as
DX â‰¡ DX,kÂ·k := max kx âˆ’ yk.

(4)

x,yâˆˆX

For a given norm k Â· k, we denote its conjugate by kskâˆ— =
maxkxkâ‰¤1 hs, xi. For a linear operator A : Rn â†’ Rm , we
use kAk to denote its operator norm defined as kAk :=
maxkxkâ‰¤1 kAxk. Let f : X â†’ R be a convex function, we
denote its linear approximation at x by
lf (x; y) := f (x) + hf 0 (x), y âˆ’ xi.

(5)

Clearly, if f satisfies (2), then
f (y) â‰¤ lf (x; y) +

L
2 ky

âˆ’ xk2 , âˆ€ x, y âˆˆ X.

(6)

Notice that the constant L in (2) and (6) depends on k Â· k.
Moreover, we say f is smooth with curvature at most C, if
f (y) â‰¤ lf (x; y) +

C
2,

âˆ€ x, y âˆˆ X.

(7)

2
It is clear that if X is bounded, we have C â‰¤ LDX
. In
the following we also use R++ to denote the set of strictly
positive reals.

2. Conditional Accelerated Lazy Stochastic
Gradient Descent
We now present a new method for stochastic gradient descent that is based on the stochastic conditional gradient
sliding (SCGS) method and the parameter-free lazy conditional gradient (LCG) procedure from Section 2.2, which
we refer to as the Conditional Accelerated Lazy Stochastic
Gradient Descent (CALSGD) method.
We consider the stochastic optimization problem:
f âˆ— := min{f (x) = EÎ¾ [F (x, Î¾)]},

(8)

xâˆˆX

where f (x) is a smooth convex function satisfying (2).

Algorithm 1 Conditional Accelerated Lazy Stochastic Gradient Descent (CALSGD)
Input: Initial point x0 âˆˆ X, iteration limit N , and weak
separation oracle accuracy Î± â‰¥ 1.
Let Î²k âˆˆ R++ , Î³k âˆˆ [0, 1], and Î·k âˆˆ R+ , k = 1, 2, . . .,
be given and set y0 = x0 .
for k = 1, 2, . . . , N do
zk = (1 âˆ’ Î³k )ykâˆ’1 + Î³k xkâˆ’1 ,
PBk 0
gk = B1k j=1
F (zk , Î¾k,j ),

(11)

xk = LCG(gk , Î²k , xkâˆ’1 , Î±, Î·k ),

(13)

yk = (1 âˆ’ Î³k )ykâˆ’1 + Î³k xk ,

(14)

Throughout this section, we assume that there exists a
stochastic first-order (SFO) oracle, which for a search point
zk âˆˆ X outputs a stochastic gradient F 0 (zk , Î¾k ), s.t.
(9)
(10)

If Ïƒ = 0, the stochastic gradient F 0 (zk , Î¾k ) is the exact
gradient at point zk , i.e., F 0 (zk , Î¾k ) = f 0 (zk ).
Our algorithmic framework is inspired by the SCGS method
by (Lan and Zhou, 2014). However, instead of applying
the classic CG method to solve the projection subproblem

(12)

where F 0 (zk , Î¾k,j ), j = 1, . . . , Bk , are stochastic gradients computed by the SFO at zk .
end for
Output: yN .

We hasten to make some observations about the CALSGD
method. Firstly, we apply mini-batches to estimate the
gradient at point zk , where the parameter {Bk } denotes the
batch sizes used to compute gk . It can be easily seen from
(9), (10), and (12) that
E[gk âˆ’ f 0 (zk )] = 0 and E[kgk âˆ’ f 0 (zk )k2âˆ— ] â‰¤

2.1. The Algorithm

E [F 0 (zk , Î¾k )] = f 0 (zk ),
 0

E kF (zk , Î¾k ) âˆ’ f 0 (zk )k2âˆ— â‰¤ Ïƒ 2 .

appearing in the accelerated gradient (AG) method, the
CALSGD method utilizes a modified parameter-free LCG
algorithm (see Section 2.2) to approximately solve the subproblem Ïˆ(x) defined in (16) and skips the computations
of the stochastic gradient F 0 (z, Î¾) from time to time when
performing weak separation over the feasible region X. The
main advantages of our method are that it does not solve
a traditional projection problem and achieves the optimal
bounds on the number of calls to the SFO and LOsepX
oracles (see Oracle 1 in Subsection 2.2) for solving problem
(1)-(8). To the authorsâ€™ best knowledge, no such algorithms
have been developed before in the literature; we present the
algorithm below in Algorithm 1.

Ïƒ2
Bk ,

(15)

and hence gk is an unbiased estimator of f 0 (zk ). In fact,
PBk
letting SBk = j=1
(F 0 (zk , Î¾k,j ) âˆ’ f 0 (zk )), from (9) and
(10), by induction, we have




E kSBk k2âˆ— = E kSBk âˆ’1 + F 0 (zk , Î¾k,Bk ) âˆ’ f 0 (zk )k2âˆ—

= E kSBk âˆ’1 k2âˆ— + kF 0 (zk , Î¾k,Bk ) âˆ’ f 0 (zk )k2âˆ—

+2hSBk âˆ’1 , F 0 (zk , Î¾k,Bk ) âˆ’ f 0 (zk )i]


= E kSBk âˆ’1 k2âˆ—


+ E kF 0 (zk , Î¾k,Bk ) âˆ’ f 0 (zk )k2âˆ—

PBk  0
= j=1
E kF (zk , Î¾k,j ) âˆ’ f 0 (zk )k2âˆ— â‰¤ Bk Ïƒ 2 ,

Conditional Accelerated Lazy Stochastic Gradient Descent

which together with the fact that gk âˆ’ f 0 (zk ) =
PBk
1
1
0
0
j=1 [F (zk , Î¾k,j ) âˆ’ f (zk )] = Bk SBk , implies the
Bk
second relationship in (15).
Secondly, in view of the SCGS method in (Lan and Zhou,
2014), xk obtained in (13) should be an approximate solution to the gradient sliding subproblem
n
o
min Ïˆk (x) := hgk , xi + Î²2k kx âˆ’ xkâˆ’1 k2 ,
(16)
xâˆˆX

such that for some Î·k â‰¥ 0 we have
hÏˆk0 (xk ), xk âˆ’ xi = hgk + Î²k (xk âˆ’ xkâˆ’1 ), xk âˆ’ xi â‰¤ Î·k ,
(17)
for all x âˆˆ X. If we solve the subproblem (16) exactly
(i.e., Î·k = 0), then CALSGD will reduce to the accelerated stochastic approximation method by (Lan, 2009; 2012).
However, by employing the LCG procedure (see Procedure 1 in Subsection 2.2), we only need to use a weak
separation oracle, but still maintaining the optimal bounds
on stochastic first-order oracle as in (Lan, 2009; 2012; Lan
and Zhou, 2014).
Thirdly, observe that the CALSGD method so far is conceptual only as we have not yet specified the LCG procedure
and the parameters {Bk }, {Î²k }, {Î³k }, and {Î·k }. We will
come back to this issue after introducing the LCG procedure
and establishing its main convergence properties.

Observe that the oracle has two output modes. In particular,
Oracle 1 first verifies whether there exists an improving
point y âˆˆ P with the required guarantee and if so it outputs this point, which we refer it as a positive call. If no
such point exists the oracle certifies this by providing the
maximizer y, which then also provides a new duality gap.
We refer to this case as a negative call. The computational
advantages of this oracle are that it can reuse previously
seen solutions y if they satisfy the improvement condition
and even if LO oracle has to be called, the optimization can
be terminated early once the improvement condition is satisfied. Finally, the parameter Î± allows to only approximately
satisfy the improvement condition making separation even
easier; in our applications we set the parameter Î± slightly
larger than 1.
We present the LCG procedure based on (Braun et al., 2016)
below. We adapted the parameter-free version to remove
any dependence on hard to estimate parameters. For any
smooth convex function Ï†, we define its duality gap as
gapÏ†,X (x) â‰¡ gapÏ† (x) := max âˆ‡Ï†(x)T (x âˆ’ y).
yâˆˆX

(18)

Clearly, by convexity the duality gap is an upper bound on
f (xâˆ— ) âˆ’ f (x). Given any accuracy parameter Î· â‰¥ 0, the
LCG procedure solves minxâˆˆX Ï†(x) approximately with
accuracy Î·, i.e., it outputs a point uÌ„ âˆˆ X, s.t. gapÏ† (uÌ„) â‰¤ Î·.

We present the LOsep oracle in Oracle 1 below.

Procedure 1 Parameter-free Lazy Conditional Gradients
(LCG) procedure
Input: access to gradients of smooth convex function Ï†,
u1 âˆˆ X vertex, LOsepX weak linear separation oracle,
accuracy Î± â‰¥ 1, duality gap bound Î·
Output: uÌ„ âˆˆ X with bounded duality gap, i.e., gapÏ† (uÌ„) â‰¤
Î·
1: Î¦0 â† maxuâˆˆX âˆ‡Ï†(u1 )T (u1 âˆ’ u)
2: for t = 1 to T âˆ’ 1 do
3:
vt â† LOsepX (âˆ‡Ï†(ut ), xt , Î¦tâˆ’1 , Î±)
4:
if not âˆ‡Ï†(ut )T (ut âˆ’ vt ) > Î¦tâˆ’1 /Î± then
5:
if Î¦tâˆ’1 = Î· then
6:
return uÌ„ = ut
7:
end if
8:
else
n
o
9:
Î¦t â† max Î¦tâˆ’1
,
Î·
{Update Î¦t }
2
10:
end if
11:
Î»t â† argmin Ï†((1 âˆ’ Î»t )ut + Î»t vt )
12:
ut+1 â† (1 âˆ’ Î»t )ut + Î»t vt
13: end for

Oracle 1 Weak Separation Oracle LOsepP (c, x, Î¦, Î±)
Input: c âˆˆ Rn linear objective, x âˆˆ P point, Î± â‰¥ 1 accuracy, Î¦ > 0 objective value;
Output: y âˆˆ P vertex with either (1) cT (x âˆ’ y) > Î¦/Î±,
or (2) y = argmaxyâˆˆP cT (x âˆ’ z) â‰¤ Î¦.

The LCG procedure is a parameter-free algorithm. Note
that while line search can be expensive in general, for our
subproblems, function evaluation is very cheap. The algorithm needs only one LO oracle call to estimate the
initial functional value gap at Line 1. Alternatively, this

2.2. The Parameter-free Lazy Conditional Gradient
Procedure
The classical CG method is a well-known projection-free
algorithm, which requires only the solution of a linear optimization subproblem (3) rather than the projection over
X per iteration. Therefore, it has computational advantages
over many other first-order methods when projection over
X being costly. The LCG procedure presented in this subsection, a modification of the vanilla LCG method in (Braun
et al., 2016), goes several steps further than CG and even
vanilla LCG method. Firstly, it replaces LO oracle by a
weaker separation oracle LOsep, which is no harder than
linear optimization and often much simpler. Secondly, it
uses a stronger termination criterion, the Frank-Wolfe gap
(cf. (18)), than vanilla LCG method. Finally, it maintains
the same order of convergence rate as the CG and the vanilla
LCG method.

Conditional Accelerated Lazy Stochastic Gradient Descent

can be also done approximately via binary search with
LOsep. The algorithm maintains a sequence, {Î¦t }, that
provides valid upper bounds for the functional value gap
at the current iterate, i.e., Ï†(ut ) âˆ’ Ï†âˆ— â‰¤ 2Î¦tâˆ’1 (see Theorem 5.1 of (Braun et al., 2016)), and it halves the value
of Î¦t only when the current oracle call is negative. Finally,
our LCG procedure exits at Line 5 whenever LOsepX returns a negative call and Î¦tâˆ’1 = Î·, which ensures that
gapÏ† (uÌ„) = maxyâˆˆX hâˆ‡Ï†(uÌ„), uÌ„ âˆ’ yi â‰¤ Î·.
Theorem 2.1 below provides a bound for the total number of iterations (or calls to the LOsepX oracle) that the
LCG procedure requires to generate a point uÌ„ âˆˆ X with
gapÏ† (uÌ„) â‰¤ Î·.

Theorem 2.1. Procedure 1 returns a point uÌ„ âˆˆ X such that
the duality gap at point uÌ„ is bounded by Î·, i.e., gapÏ† (uÌ„) â‰¤ Î·.
Furthermore, the total number of iterations T (and hence
LOsepX calls) performed by Procedure 1 is at most
T â‰¤

(
Îº+

8Î±2 CÏ†
Î·

Îº + 4Î± +

l
with Îº := 4Î± log

Î¦0
Î±CÏ†

m

+ 2,
4Î±2 CÏ†
Î·

+ log

Î· < Î±CÏ† ;
+ 2,

Î· â‰¥ Î±CÏ† ,

(19)

Î¦0
Î· .

Proof. From the observations above, it is clear that the duality gap at the output point uÌ„ is bounded by Î·.
Also observe that the procedure calls LOsepX once per
iteration. In order to demonstrate the bound in (19), we split
the LCG procedure into two phases, and bound the number
of iterations separately for each phase. Let CÏ† denote the
curvature of the smooth convex function Ï†.
We say Procedure 1 is in the first phase whenever Î¦tâˆ’1 > Î·.
In view of Theorem 5.1 in (Braun et al., 2016), it is clear that
the number of iterations in the first phase can be bounded as
l
T1 â‰¤ 4Î± log

Î¦0
Î±CÏ†

m

+

4Î±2 CÏ†
Î·

+ log

Î¦0
Î· .

Procedure 1 enters the second phase when Î¦tâˆ’1 â‰¤ Î·. Again
with the argumentation in Theorem 5.1 in (Braun et al.,
2016), we obtain that the total number of positive calls in
4Î±2 C
this phase can be bounded by Î· Ï† , if Î· < Î±CÏ† , or by 4Î±
if Î· â‰¥ Î±CÏ† . Moreover, the procedure exits whenever the
current LOsepX oracle call is a negative call. Hence, the
number of iterations in the second phase can be bounded by
(
T2 â‰¤

4Î±2 CÏ†
Î·

+ 1,
4Î± + 1,

Î· < Î±CÏ† ;
Î· â‰¥ Î±CÏ† .

Thus, our bound in (19) can be obtained from the above two
bounds plus one more LO oracle call at Line 1.

2.3. The Convergence Properties of CALSGD
This subsection is devoted to establishing the main convergence properties of the CALSGD method. Since the
algorithm is stochastic, we will establish the convergence
results for finding a stochastic -solution, i.e., a point xÌ„ âˆˆ X
s.t. E[f (xÌ„) âˆ’ f (xâˆ— )] â‰¤ . We first state a simple technical
result from (Lan and Zhou, 2014, Lemma 2.1) that we will
use.
Lemma 2.2. Let wt âˆˆ (0, 1], t = 1, 2, . . ., be given. Also
let us denote
(
1
t=1
Wt :=
(1 âˆ’ wt )Wtâˆ’1 t â‰¥ 2.
Suppose that Wt > 0 for all t â‰¥ 2 and that the sequence
{Î´t }tâ‰¥0 satisfies
Î´t â‰¤ (1 âˆ’ wt )Î´tâˆ’1 + Bt , t = 1, 2, . . . .
Then for any 1 â‰¤ l â‰¤ k, we have

Pk Bi 
l
Î´k â‰¤ Wk 1âˆ’w
Î´
+
lâˆ’1
i=l Wi .
Wl
Theorem 2.3 describes the main convergence properties of
the CALSGD method (cf. Algorithm 1). The proof of this
theorem can be found in the Supplementary material A.
Theorem 2.3. Let Î“k be defined as follows,
(
1
k=1
Î“k :=
Î“kâˆ’1 (1 âˆ’ Î³k ) k â‰¥ 2.

(20)

Suppose that {Î²k } and {Î³k } in the CALSGD algorithm
satisfy
Î³1 = 1 and LÎ³k â‰¤ Î²k , k â‰¥ 1.
(21)
a) If
Î² k Î³k
Î“k

â‰¥

Î²kâˆ’1 Î³kâˆ’1
Î“kâˆ’1 ,

k â‰¥ 2,

(22)

then under assumptions (9) and (10), we have
E [f (yk ) âˆ’ f (xâˆ— )] â‰¤

Î²k Î³k 2
2 DX
k h
X

+ Î“k

Î·i Î³i
Î“i

+

Î³i Ïƒ 2
2Î“i Bi (Î²i âˆ’LÎ³i )

i

,

i=1

(23)
where xâˆ— is an arbitrary optimal solution of (8) and
DX is defined in (4).
b) If
Î² k Î³k
Î“k

â‰¤

Î²kâˆ’1 Î³kâˆ’1
Î“kâˆ’1 ,

k â‰¥ 2,

(24)

(rather than (36)) is satisfied, then the result in part a)
2
holds by replacing Î²k Î³k DX
with Î²1 Î“k kx0 âˆ’ xâˆ— k2 in
the first term of the RHS of (37).

Conditional Accelerated Lazy Stochastic Gradient Descent

c) Under the assumptions in part a) or b), the number of
inner iterations performed at the k-th outer iterations
is bounded by
(
Tk =

Îº+
Îº+

2
8Î±2 Î²k DX
+ 2,
Î·k
2
4Î±2 Î²k DX
4Î± +
Î·k

Î¦k
0

l
with Îº := 4Î± log

2
Î±Î²k DX

2
Î·k < Î±Î²k DX
;

2
Î·k â‰¥ Î±Î²k DX
,
(25)
m
Î¦k
+ log Î·k0 .

+ 2,

Now we provide two different sets of parameters
{Î²k }, {Î³k }, {Î·k }, and {Bk }, which lead to optimal complexity bounds on the number of calls to the SFO and
LOsepX oracles.
Corollary 2.4. Suppose that {Î²k }, {Î³k }, {Î·k }, and {Bk }
in the CALSGD method are set to
2
LDX

3
Î³k = k+2
, Î·k = k(k+1) ,
m
l 2
3
and Bk = Ïƒ L(k+2)
, k â‰¥ 1,
2 D2

Î²k =

4L
k+2 ,

(26)

X

and we assume kf 0 (xâˆ— )k is bounded for any optimal solution xâˆ— of (8). Under assumptions (9) and (10), we have
E [f (yk ) âˆ’ f (xâˆ— )] â‰¤

2
6LDX
(k+2)2

2
9LDX
2(k+1)(k+2) ,

âˆ€k â‰¥ 1.
(27)
As a consequence, the total number of calls to the SFO and
LOsepX oracles performed by the CALSGD method for
finding a stochastic -solution of (1), respectively, can be
bounded by

q
2
LDX

O



+

+

Ïƒ

2

2
DX
2

,

(28)

and
O

q

2
LDX


log

2
LDX
Î›

+

2
LDX



with probability 1 âˆ’ Î›.
(29)

Proof. It can be easily seen from (26) that (35) holds. Also
note that by (26), we have
Î“k =

6
k(k+1)(k+2) ,

(30)

Î²k Î³k
Î“k

=

2Lk(k+1)
,
k+2

which implies that (36) holds. It can also be easily checked
from (30) and (26) that
Î·i Î³i
i=1 Î“i

PN

k=1 Bk

â‰¤

PN

k=1

Ïƒ 2 (k+2)3
2
L2 DX

+N â‰¤

Ïƒ 2 (N +3)4
2
4L2 DX

+ N.

We now provide a good estimation for Î¦k0 (cf. Line 1 in
LCG procedure) at the k-th outer iteration. In view of the
definition of Î¦k0 and Ïˆ(Â·) (cf. (16)), we have,
Î¦k0 = hÏˆk0 (xkâˆ’1 ), xkâˆ’1 âˆ’ xi = hgk , xkâˆ’1 âˆ’ xi.
q 2
NÏƒ
Moreover, let Ak := kgk âˆ’ f 0 (zk )kâˆ— â‰¥ Î›B
, by Chebyk
shevâ€™s inequality and (15), we obtain,
Prob{Ak } â‰¤

E[kgk âˆ’f 0 (zk )|2âˆ— ]Î›Bk
N Ïƒ2

â‰¤

Î›
N,

âˆ€Î› < 1, k â‰¥ 1,

TN
which implies that Prob{ k=1 AÌ„k } â‰¤ 1 âˆ’ Î›. Hence, by
Cauchy-Schwarz and triangle inequalities, we have with
probability 1 âˆ’ Î›,
Î¦k0 = hgk âˆ’ f 0 (zk ), xkâˆ’1 âˆ’ xi + hf 0 (zk ), xkâˆ’1 âˆ’ xi}
q

0
0 âˆ—
0 âˆ—
N Ïƒ2
â‰¤
Î›Bk + kf (zk ) âˆ’ f (x )kâˆ— + kf (x )kâˆ— DX

q
2
0 âˆ—
N
(31)
â‰¤
Î›k3 + 1 LDX + kf (x )kâˆ— DX ,
where the last inequality follows from (6) and (26).
2
Note that we always have Î·k < Î±Î²k DX
. Therefore, it
follows from the bound in (39), (26), and (31) that the total
number of inner iterations can be bounded by

PN
PN h 
Î¦k
Î¦k
0
+ log Î·k0
2 + 1
k=1 Tk â‰¤
k=1 4Î± log Î±Î²k DX
i
8Î±2 Î² D 2
+ Î·kk X + 2

q

N 
X
kf 0 (xâˆ— )kâˆ—
N
5Î± log 2k 2
â‰¤
+
1
+
3
Î›k
LDX
k=1


+32Î±2 k + (4Î± + 2)N
= O(N log

N2
Î›

+ N 2 + N ),

which implies that our bound in (29).

and hence

Pk

bound in (28) then immediately follows from this observation and the fact that the number of calls to the SFO oracle
is bounded by

â‰¤

2
kLDX
,
2

Pk

Î³i
i=1 Î“i Bi (Î²i âˆ’LÎ³i )

â‰¤

2
kLDX
2Ïƒ 2 .

Using the bound in (37), we obtain (27), which implies that
thetotal number
 of outer iterations N can be bounded by
p
2 / under the assumptions (9) and (10). The
O
LDX

We now provide a slightly improved complexity bound on
the number of calls to the SFO oracle which depends on
the distance from the initial point to the set of optimal solutions, rather than the diameter DX . In order to obtain
this improvement, we need to estimate D0 â‰¥ kx0 âˆ’ xâˆ— k
and to fix the number of iterations N in advance. This
result will play an important role for the analysis of the
CALSGD method to solve strongly convex problems (see
Supplementary Material C.1).

Conditional Accelerated Lazy Stochastic Gradient Descent

(32)

100
10âˆ’1
10âˆ’2
10âˆ’3

0

Under assumptions (9) and (10),
E [f (yN ) âˆ’ f (x )] â‰¤

âˆ€N â‰¥ 1.

As a consequence, the total number of calls to the SFO and
LOsepX oracles performed by the CALSGD method for
finding a stochastic -solution of (1), respectively, can be
bounded by

q
O

LD02


+

Ïƒ 2 D02
2

150 300 450
Iterations

,

(33)

and (29).
Proof. The proof is similar to Corollary 2.4, and hence
details are skipped.
It should be pointed out that the complexity bound for the
number of calls to the LOsep oracle in (29) is established
with probability 1 âˆ’ Î›. However, the probability parameter
Î› only appears in the non-dominant term.

3. Experimental Results
We present preliminary experimental results showing the
performance of CALSGD compared to OFW for stochastic
optimization. As examples we use the video co-localization
problem, which can be solved by quadratic programming
over a path polytope, different structured regression problems, and quadratic programming over the standard spectrahedron. In all cases we use objective functions of the
2
form kAx âˆ’ bk , with A âˆˆ RmÃ—n , i.e., m examples over a
feasible region of dimension n. For comparability we use a
batch size of 128 for all algorithms to compute each gradient and the full matrix A for the actual objective function
values. All graphs show the function value using a logscale
on the vertical axis.
In Figure 1 we compare the performance of three algorithms:
CALSGD, SCGS and OFW. As described above SCGS is
the non-lazy counterpart of CALSGD. In the four graphs
of Figure 1 we report the objective function value over the
number of iterations, the wall clock time in seconds, the
number of calls to the linear oracle, and the number of
gradient evaluations in that order. In all these measures, our
proposed algorithms outperform OFW by multiple orders
of magnitude. As expected in number of iterations and
number of gradient evaluations both versions CALSGD and
SCGS perform equally well, however in wall clock time and

101
100
10

100
10âˆ’1
10âˆ’2
0

150
300
450
Wall clock time

102
CALSGD
SCGS
OFW

âˆ’1

10âˆ’2
10âˆ’3

CALSGD
SCGS
OFW

101

10âˆ’3

600

102

8LD02
N (N +1) ,

Function value

âˆ—

0

0 100 200 300 400 500 600
LP calls

Function value

3L
k ,

10

102
CALSGD
SCGS
OFW

1

Function value

2LD 2

2
Î³k = k+1
, Î·k = N k 0 ,
m
l 2
2
and Bk = Ïƒ NL2(k+1)
, k â‰¥ 1.
2
D

Î²k =

102
Function value

Corollary 2.5. Suppose that there exists an estimate D0
s.t. kx0 âˆ’ xâˆ— k â‰¤ D0 â‰¤ DX . Also assume that the outer
iteration limit N â‰¥ 1 is given. If

101
100

CALSGD
SCGS
OFW

10âˆ’1
10âˆ’2
10âˆ’3

0 100 200 300 400 500 600
Gradient evaluations

Figure 1. Performance of CALSGD and its non-lazy variant SCGS
on a structured regression problem compared to OFW. The feasible region is the flow-based formulation of the convex hull of
Hamiltonian cycles on 9 nodes and has dimension n = 162.

in the number of calls to the linear oracle we observe the
advantage of the weaker LOsep oracle over LO.
In Figure 5 and 4 we show the performance of CALSGD
on one video co-localization instance and one semi-definite
convex programming instance. Due to space limitations
we only report the function value over the number of iterations and wall clock time in seconds; see Supplementary
Material D for a detailed analysis as well as more examples.
Implementation details. Finally, we provide details of
the implementation of LOsep. In the case of the structured
regression problems and the quadratic optimizations over
the path polytope instances, we used Gurobi as a solver
and included callbacks to terminate whenever the required
improvement (given by Î¦tâˆ’1 ) is reached; our approach is
one out of many and other approaches could have been used
equally well. If the solver does not find a good enough
solution, it returns with a lower bound on the Wolfe gap,
which we use to update Î¦t . In the case of convex programming over the feasible region Sn := {X âˆˆ RnÃ—n | X <
0 and tr(X) = 1}, we compute a maximal eigenvector of
the gradient (which is a matrix in this case) and use the rank1 factor of the maximal eigenvector, which is an optimal
point. In this case, there is no early termination.
However, in all cases, we use caching, i.e., we store all
previously seen points and check if any of them satisfies
the improvement guarantee. If that is the case we do not
call Gurobi or the maximal eigenvector routine. The size of
the cache is very small in all experiments; alternatively one
could use cache strategies such as e.g., k-paging.

Conditional Accelerated Lazy Stochastic Gradient Descent

104
103
10

2

0

10
20
30
Iterations

10

6

105
10

4

10

3

102

104

0

15
30
45
Wall clock time

10

âˆ’1

10âˆ’2
10âˆ’3
10

âˆ’4

103
0

8
16
24
Iterations
CALSGD
OFW

107
10

0

101
100
10âˆ’1
10âˆ’2
10âˆ’3
10âˆ’4

500 1000 1500
Iterations

0

25
50
75 100
Wall clock time

2

108
CALSGD
OFW

Function value

Function value

10

105

10

40

108
7

106

100

CALSGD
OFW

102

6

Figure 4. Performance of CALSGD and OFW on a medium sized
convex programming instance with feasible region Sn := {X âˆˆ
RnÃ—n | X < 0, tr(X) = 1} with n = 100 and m = 10000.
Similar to the results before in both iterations and wall clock time
our method performs better.

105
104
103

108

102

7

0

15
30
45
Wall clock time

Figure 2. Two small video co-localization instances. On the
left: road_paths_01_DC_a instance (n = 29682 and m =
10000). On the right: road_paths_01_DC_b instance (n =
29682 and m = 10000). Observe a significant difference in function value of multiple orders of magnitude after a few seconds.

10

108
CALSGD
OFW

Function value

105

CALSGD
OFW

107

101

Function value

106

8

103
CALSGD
OFW

102

Function value

10
CALSGD
OFW

107

Function value

Function value

10

8

Function value

103

106
10

5

10

4

10

3

10

2

0

10
20
30
Iterations

106
105
104
103
102

40

CALSGD
OFW

107

0

15
30
45
Wall clock time

Figure 5. Performance of CALSGD compared to OFW on a small
video co-localization instance. The dimension of the underlying
path polytope is n = 29682, the time limit is 50 seconds. Our
algorithm performs significantly better both in number of iterations
as well as in wall clock time.
109

106
105
104
103

0

107

107
CALSGD
OFW

105
104
0

8
16
Iterations

24

106

0

109

107
106
105
104
3

0

50 100 150 200
Wall clock time

CALSGD
OFW

108
107
106
105
104
103

0

50 100 150 200
Wall clock time

Figure 3. Two medium sized video co-localization instances. On
the left: road_paths_02_DE_a instance (n = 119520 and
m = 10000). On the right: road_paths_02_DE_b instance
(n = 119520 and m = 10000). Similar results as in Figure 2.

25
50
75
Iterations

0

20
40
60
Iterations

107
CALSGD
OFW

106

CALSGD
OFW

106

100

107
Function value

CALSGD
OFW

108

Function value

Function value

106

103

10
20
30
Iterations

109

10

107

Function value

107

CALSGD
OFW

108

0

1000 2000 3000 4000
Wall clock time

CALSGD
OFW

Function value

108

Function value

CALSGD
OFW

Function value

Function value

109

106

0

1000 2000 3000 4000
Wall clock time

Figure 6. Structured regression problem over the convex hull of
all Hamiltonian cycles of a graph on 11 nodes (n = 242) on the
left and 12 nodes (n = 288) on the right. We used a density of
d = 0.6 for A and m = 10000. On both instances CALSGD
achieves lower values much faster, both in number of iterations as
well as in wall clock time.

Conditional Accelerated Lazy Stochastic Gradient Descent

Acknowledgements
We would to thank Elad Hazan for providing references.
Research reported in this paper was partially supported by
NSF CAREER award CMMI-1452463.

References
S. Ahipasaoglu and M. Todd. A Modified Frank-Wolfe Algorithm for Computing Minimum-Area Enclosing Ellipsoidal Cylinders: Theory and Algorithms. Computational
Geometry, 46:494â€“519, 2013.
F. Bach, S. Lacoste-Julien, and G. Obozinski. On the equivalence between herding and conditional gradient algorithms. In the 29th International Conference on Machine
Learning, 2012.
A. Beck and M. Teboulle. A conditional gradient method
with linear rate of convergence for solving convex linear
systems. Math. Methods Oper. Res., 59:235â€“247, 2004.
G. Braun, S. Pokutta, and D. Zink. Lazifying conditional
gradient algorithms. arXiv preprint arXiv:1610.05120,
2016.
Y. Chen, G. Lan, and Y. Ouyang. Optimal primal-dual
methods for a class of saddle point problems. SIAM
Journal on Optimization, 24(4):1779â€“1814, 2014.
K. L. Clarkson. Coresets, sparse greedy approximation, and
the frank-wolfe algorithm. ACM Trans. Algorithms, 6(4):
63:1â€“63:30, Sept. 2010.
B. Cox, A. Juditsky, and A. S. Nemirovski. Dual subgradient
algorithms for large-scale nonsmooth learning problems.
Manuscript, School of ISyE, Georgia Tech, Atlanta, GA,
30332, USA, 2013. submitted to Mathematical Programming, Series B.
M. Frank and P. Wolfe. An algorithm for quadratic programming. Naval Research Logistics Quarterly, 3:95â€“110,
1956.
R. M. Freund and P. Grigas. New Analysis and Results for
the Frank-Wolfe Method. ArXiv e-prints, July 2013.
D. Garber and E. Hazan. A Linearly Convergent Conditional Gradient Algorithm with Applications to Online
and Stochastic Optimization. ArXiv e-prints, Jan 2013.
S. Ghadimi and G. Lan. Optimal stochastic approximation
algorithms for strongly convex stochastic composite optimization, I: a generic algorithmic framework. SIAM
Journal on Optimization, 22:1469â€“1492, 2012.
S. Ghadimi and G. Lan. Optimal stochastic approximation
algorithms for strongly convex stochastic composite optimization, II: shrinking procedures and optimal algorithms.
SIAM Journal on Optimization, 23:2061â€“2089, 2013.

Gurobi Optimization. Gurobi optimizer reference manual version 6.5, 2016. URL https://www.gurobi.
com/documentation/6.5/refman/.
Z. Harchaoui, A. Juditsky, and A. S. Nemirovski. Conditional gradient algorithms for machine learning. NIPS
OPT workshop, 2012.
E. Hazan. Sparse approximate solutions to semidefinite
programs. In E. Laber, C. Bornstein, L. Nogueira, and
L. Faria, editors, LATIN 2008: Theoretical Informatics, volume 4957 of Lecture Notes in Computer Science,
pages 306â€“316. Springer Berlin Heidelberg, 2008. ISBN
978-3-540-78772-3.
E. Hazan and S. Kale. Projection-free online learning. arXiv
preprint arXiv:1206.4657, 2012.
E. Hazan and H. Luo. Variance-reduced and projectionfree stochastic optimization. In Proceedings of The 33rd
International Conference on Machine Learning, pages
1263â€“1271, 2016.
M. Jaggi. Sparse Convex Optimization Methods for
Machine Learning. PhD thesis, ETH ZÃ¼rich, 2011.
http://dx.doi.org/10.3929/ethz-a-007050453.
M. Jaggi. Revisiting frank-wolfe: Projection-free sparse
convex optimization. In the 30th International Conference on Machine Learning, 2013.
M. Jaggi and M. SulovskÃ½. A simple algorithm for nuclear
norm regularized problems. In the 27th International
Conference on Machine Learning, 2010.
R. Johnson and T. Zhang. Accelerating stochastic gradient
descent using predictive variance reduction. In Advances
in Neural Information Processing Systems, pages 315â€“
323, 2013.
A. Joulin, K. Tang, and L. Fei-Fei. Efficient image and
video co-localization with frank-wolfe algorithm. In European Conference on Computer Vision, pages 253â€“268.
Springer, 2014.
G. Lan. Convex optimization under inexact first-order information. Ph.D. dissertation, School of Industrial and
Systems Engineering, Georgia Institute of Technology,
Atlanta, GA 30332, USA, 2009.
G. Lan. An optimal method for stochastic composite optimization. Mathematical Programming, 133(1):365â€“397,
2012.
G. Lan. The complexity of large-scale convex programming
under a linear optimization oracle. Technical Report,
2013. Available on http://www.optimization-online.org/.

Conditional Accelerated Lazy Stochastic Gradient Descent

G. Lan and Y. Zhou. Conditional gradient sliding for convex
optimization. Optimization-Online preprint (4605), 2014.
R. Luss and M. Teboulle. Conditional gradient algorithms
for rank one matrix approximations with a sparsity constraint. SIAM Review, 55:65â€“98, 2013.
M. Mahdavi, L. Zhang, and R. Jin. Mixed optimization for
smooth functions. In Advances in Neural Information
Processing Systems, pages 674â€“682, 2013.
Y. E. Nesterov. A method for unconstrained convex minimization problem with the rate of convergence O(1/k 2 ).
Doklady AN SSSR, 269:543â€“547, 1983.
Y. E. Nesterov. Introductory Lectures on Convex Optimization: a basic course. Kluwer Academic Publishers, Massachusetts, 2004.
Y. E. Nesterov. Smooth minimization of nonsmooth functions. Mathematical Programming, 103:127â€“152, 2005.
C. Shen, J. Kim, L. Wang, and A. van den Hengel. Positive semidefinite metric learning using boosting-like algorithms. Journal of Machine Learning Research, 13:
1007â€“1036, 2012.

Conditional Accelerated Lazy Stochastic Gradient Descent

A. Omitted proofs

which implies that

Theorem A.1. Let Î“k be defined as follows,
(
1
k=1
Î“k :=
Î“kâˆ’1 (1 âˆ’ Î³k ) k â‰¥ 2.

1
2 kxk

a) If
â‰¥

Î²kâˆ’1 Î³kâˆ’1
Î“kâˆ’1 ,

k â‰¥ 2,

(36)

â‰¤ 12 kxkâˆ’1 âˆ’ xk2 âˆ’ 12 kxk âˆ’ xk2

E [f (yk ) âˆ’ f (x )] â‰¤

Î²k Î³k 2
2 DX
k h
X

+ Î“k

Î·i Î³i
Î“i

+

1
Î²k hgk , x

+

âˆ’ xk i +

Î·k
Î²k .

Combing the above two relations, we have
f (yk ) â‰¤ (1 âˆ’ Î³k )f (ykâˆ’1 ) + Î³k lf (zk , xk ) + Î³k hgk , x âˆ’ xk i


+ Î²k2Î³k kxkâˆ’1 âˆ’ xk2 âˆ’ kxk âˆ’ xk2

then under assumptions (9) and (10), we have
âˆ—

âˆ’ hxkâˆ’1 âˆ’ xk , xk âˆ’ xi

(34)

Suppose that {Î²k } and {Î³k } in the CALSGD algorithm
satisfy
Î³1 = 1 and LÎ³k â‰¤ Î²k , k â‰¥ 1.
(35)
Î² k Î³k
Î“k

âˆ’ xkâˆ’1 k2 = 12 kxkâˆ’1 âˆ’ xk2 âˆ’ 12 kxk âˆ’ xk2

+ Î·k Î³k âˆ’

Î³k (Î²k âˆ’LÎ³k )
kxk
2

âˆ’ xkâˆ’1 k2

+ Î·k Î³k âˆ’

Î³k (Î²k âˆ’LÎ³k )
kxk
2

âˆ’ xkâˆ’1 k2 .

= (1 âˆ’ Î³k )f (ykâˆ’1 ) + Î³k lf (zk , x) + Î³k hÎ´k , x âˆ’ xk i


+ Î²k2Î³k kxkâˆ’1 âˆ’ xk2 âˆ’ kxk âˆ’ xk2

Î³i Ïƒ 2
2Î“i Bi (Î²i âˆ’LÎ³i )

i

,

Using the above inequality and the fact that

i=1

(37)
where xâˆ— is an arbitrary optimal solution of (8) and
DX is defined in (4).

hÎ´k ,x âˆ’ xk i âˆ’

= hÎ´k , x âˆ’ xkâˆ’1 i

â‰¤

Î²kâˆ’1 Î³kâˆ’1
Î“kâˆ’1 ,

k â‰¥ 2,

â‰¤ hÎ´k , x âˆ’ xkâˆ’1 i +

(38)

(rather than (36)) is satisfied, then the result in part a)
2
holds by replacing Î²k Î³k DX
with Î²1 Î“k kx0 âˆ’ xâˆ— k2 in
the first term of the RHS of (37).
c) Under the assumptions in part a) or b), the number of
inner iterations performed at the k-th outer iterations
is bounded by
(
2
8Î±2 Î²k DX
2
;
Îº+
+ 2,
Î·k < Î±Î²k DX
Î·k
Tk =
2
4Î±2 Î²k DX
2
Îº + 4Î± +
,
+ 2,
Î·k â‰¥ Î±Î²k DX
Î·k
(39)
l
m
Î¦k
Î¦k
0
with Îº := 4Î± log Î±Î²k D
+ log Î·k0 .
2
X

L
2 kyk

(Î²k âˆ’LÎ³k )
kxk
2
kÎ´k k2âˆ—
2(Î²k âˆ’LÎ³k ) ,

âˆ’ xkâˆ’1 k2

we obtain for all x âˆˆ X,
f (yk ) â‰¤ (1 âˆ’ Î³k )f (ykâˆ’1 ) + Î³k f (x) + Î·k Î³k


+ Î²k2Î³k kxkâˆ’1 âˆ’ xk2 âˆ’ kxk âˆ’ xk2
+ Î³k hÎ´k , x âˆ’ xkâˆ’1 i +

Î³k kÎ´k k2âˆ—
2(Î²k âˆ’LÎ³k ) .

f (yk ) âˆ’ f (x) â‰¤ Î“k (1 âˆ’ Î³1 ) [f (y0 ) âˆ’ f (x)] + Î“k
+ Î“k

k
X

Î²i Î³i
2Î“i

i=1

+ Î“k

âˆ’ zk k2

k
X
i=1

Î³i
Î“i

+

2

+

Î²k Î³k
2 kxk

âˆ’ xkâˆ’1 k2 âˆ’

Î³k (Î²k âˆ’LÎ³k )
kxk
2

Î·i Î³i
Î“i

i=1

h
hÎ´i , x âˆ’ xiâˆ’1 i +

kÎ´i k2âˆ—
2(Î²i âˆ’LÎ³i )

i

.

(41)

kxk âˆ’ xkâˆ’1 k2

= (1 âˆ’ Î³k )f (ykâˆ’1 ) + Î³k lf (zk ; xk )

k
X



kxkâˆ’1 âˆ’ xk2 âˆ’ kxk âˆ’ xk2

= (1 âˆ’ Î³k )lf (zk ; ykâˆ’1 ) + Î³k lf (zk ; xk )
LÎ³k2

(40)

Subtracting f (x) from both sides of (40) and applying
Lemma 2.2, we have

Proof. Let us denote Î´k,j = F 0 (zk , Î¾k,j )âˆ’f 0 (zk ) and Î´k â‰¡
PBk
gk âˆ’ f 0 (zk ) = j=1
Î´k,j /Bk . We first show part a). In
view of (6), (11) and (14), we have
f (yk ) â‰¤ lf (zk ; yk ) +

âˆ’ xkâˆ’1 k2

+ hÎ´k , xkâˆ’1 âˆ’ xk i âˆ’

b) If
Î² k Î³k
Î“k

(Î²k âˆ’LÎ³k )
kxk
2

âˆ’ xkâˆ’1 k2 ,

where the last inequality follows from the convexity of f (Â·).
Also observe that by (17), we have
hgk + Î²k (xk âˆ’ xkâˆ’1 ), xk âˆ’ xi â‰¤ Î·k , âˆ€x âˆˆ X,

Also observe that
Pk Î²i Î³i
2
2
i=1 Î“i (kxiâˆ’1 âˆ’ xk âˆ’ kxi âˆ’ xk )

âˆ’ xk2 âˆ’ Î²Î“k Î³kk kxk âˆ’ xk2


Pk
Î³iâˆ’1
+ i=2 Î²Î“i Î³i i âˆ’ Î²iâˆ’1
kxiâˆ’1 âˆ’ xk2
Î“iâˆ’1


Pk
Î³iâˆ’1
2
2
+ i=2 Î²Î“i Î³i i âˆ’ Î²iâˆ’1
DX
=
â‰¤ Î²Î“1 Î³1 1 DX
Î“iâˆ’1
=

Î²1 Î³1
Î“1 kx0

Î²k Î³k 2
Î“k DX ,

Conditional Accelerated Lazy Stochastic Gradient Descent

where the inequality follows from the third assumption in
(36) and the definition of DX in (4).
Therefore, from the above two relations and the fact that
Î³1 = 1, we can conclude that
h
Pk
kÎ´i k2âˆ—
2
f (yk ) âˆ’ f (x) â‰¤ Î²k2Î³k DX
+ Î“k i=1 Î“Î³ii Î·i + 2(Î²i âˆ’LÎ³
i)
i
PBi âˆ’1
(42)
+ j=1 Bi hÎ´i,j , x âˆ’ xiâˆ’1 i .
Note that by our assumptions on SFO, the random variables
Î´i,j are independent of the search point xiâˆ’1 and hence
E[hÎ´i,j , xâˆ— âˆ’ xiâˆ’1 i] = 0. In addition, relation (15) implies
that E[kÎ´i k2âˆ— ] â‰¤ Ïƒ 2 /Bi . Using the previous two observations and taking expectation on both sides of (42) (with
x = xâˆ— ) we obtain (37).
Similarly, Part b) follows from (41), the assumption that
Î³1 = 1, and the fact that
Pk Î²i Î³i
2
2
i=1 Î“i (kxiâˆ’1 âˆ’ xk âˆ’ kxi âˆ’ xk )
â‰¤

Î² 1 Î³1
Î“1 kx0

âˆ’ xk2 âˆ’

Î² k Î³k
Î“k kxk

âˆ’ xk2 â‰¤ Î²1 kx0 âˆ’ xk2 ,
(43)

due to the assumptions in (35) and (38).
Let Î¦k0 denote the initial bound obtained in Line 1 of the
LCG procedure at the k-th outer iteration. The result in
Part c) follows immediately from (19) and the fact that
2
CÏˆk = Î²k DX
.

B. Deterministic CALSGD
Our goal in this section is to present a deterministic version
of CALSGD, which we refer to as CALGD. Instead of
calling the SFO oracle to compute the stochastic gradients,
we assume that we have access to the exact gradients of
f . Therefore, the CALGD method calls the FO oracle to
obtain the exact gradients f 0 (zk ) at the k-th outer iteration.
The CALGD method is formally described as follows.
Algorithm 2 The conditional accelerated lazy gradient descent (CALGD) method
This algorithm is the same as Algorithm 1 except that
steps (12) and (13) are replaced by
xk = LCG(f 0 (zk ), Î²k , xkâˆ’1 , Î±, Î·k ).

(44)

Similarly to the stochastic case, we can easily see that xk
obtained in (44) is an approximate solution for the gradient
sliding subproblem


Î²k
0
2
min Ïˆk (x) := hf (zk ), xi +
kx âˆ’ xkâˆ’1 k
(45)
xâˆˆX
2

such that for all x âˆˆ X
hÏˆk0 (xk ), xk âˆ’xi = hf 0 (zk )+Î²k (xk âˆ’xkâˆ’1 ), xk âˆ’xi â‰¤ Î·k ,
(46)
for some Î·k â‰¥ 0.
Theorem B.1 describes the main convergence properties of
the above CALGD method.
Theorem B.1. Let Î“k be defined as in (34). Suppose that
{Î²k } and {Î³k } in the CALGD algorithm satisfy (35).
a) If (36) is satisfied, then for any x âˆˆ X and k â‰¥ 1,
Pk
2
f (yk ) âˆ’ f (xâˆ— ) â‰¤ Î²k2Î³k DX
+ Î“k i=1 Î·Î“i Î³i i . (47)
where xâˆ— is an arbitrary optimal solution of (1) and
DX is defined in (4).
b) If (38) (rather than (36)) is satisfied, then for any x âˆˆ
X and k â‰¥ 1,
Pk
f (yk ) âˆ’ f (xâˆ— ) â‰¤ Î²12Î“k kx0 âˆ’ xâˆ— k2 + Î“k i=1 Î·Î“i Î³i i .
(48)
c) Under the assumptions in either part a) or b), the
number of inner iterations performed at the k-th outer
iteration can be bounded by (39).
Proof. Since the convergence results stated in Theorem 2.3 cover the deterministic case when we set Î´k,j =
F 0 (zk , Î¾k,j )âˆ’f 0 (zk ) â‰¡ 0, Part a) immediately follows from
(37) with P
Ïƒ = 0. Similarly, Part b) follows from (41), (43)
Bi
and Î´i = j=1
Î´i,j = 0. The proof of Part c) is exactly the
same as that of Theorem 2.3.c).
Clearly, there exist various options to specify the parameters
{Î²k }, {Î³k }, and {Î·k } so as to guarantee the convergence
of the CALGD method. In the following corollaries, we
provide two different parameter settings for {Î²k }, {Î³k }, and
{Î·k }, which lead to optimal complexity bounds on the total
number of calls to the FO and LOsep oracles for smooth
convex optimization.
Corollary B.2. If {Î²k }, {Î³k }, and {Î·k } in the CALGD
method are set to
3L
k+1 ,

3
k+2 ,

2
LDX
k(k+1) ,

âˆ€k â‰¥ 1,
(49)
and we assume that kf 0 (xâˆ— )k is bounded for any optimal
solution xâˆ— of (1), then for any k â‰¥ 1,
Î²k =

Î³k =

and Î·k =

f (yk ) âˆ’ f (xâˆ— ) â‰¤

2
15LDX
2(k+1)(k+2) .

(50)

As a consequence, the total number of calls to the FO and
LOsep oracles performed by the CALGD method
p for finding

2 / and
an -solution of (1) can be bounded by O
LDX

2
O LDX
/ respectively.

Conditional Accelerated Lazy Stochastic Gradient Descent

Proof. It can be easily seen from (49) that (35) holds, Î“k is
given by (30), and
Î² k Î³k
Î“k

=

k(k+1)(k+2)
9L
(k+1)(k+2)
6

=

3Lk
2 ,

which implies that (36) is satisfied. It then follows from
Theorem B.1.a), (49), and (30) that
f (yk ) âˆ’ f (xâˆ— ) â‰¤
=

2
9LDX
2(k+1)(k+2)

+

6
k(k+1)(k+2)

Pk

Î· i Î³i
i=1 Î“i

2
15LDX
2(k+1)(k+2) ,

which implies that the total number of outer iterations performed by the CALGD
pmethod for finding an -solution can
2 /(2).
be bounded by N = 15LDX
We first provide a valid upper bound for Î¦k0

defined in Line 1
when the CALGD method enters the LCG procedure at the
k-th outer iteration. In view of the definitions of Î¦k0 and Ïˆ(Â·)
at Line 1 and (45), respectively, we have, for any k â‰¥ 1,

C. Generalizations to other optimization
problems
We generalize the CALGD and CALSGD methods to solve
two other classes of problems frequently seen in machine
learning. In particular, we discuss the CALGD method with
a restarting technique for solving smooth and strongly convex problems in Subsection C.1, and in Subsection C.3 we
extend the CALGD method to solve a special class of nonsmooth problems. Discussions for the similar extensions for
CALSGD method can be found in Subsection C.2 and C.4.
C.1. Strongly convex optimization
In this subsection, we assume that the objective function f
is not only smooth (i.e., (6) holds), but also strongly convex,
that is, âˆƒ Âµ > 0 s.t.

Î¦k0 = hÏˆk0 (xkâˆ’1 ), xkâˆ’1 âˆ’ xi = hf 0 (zk ), xkâˆ’1 âˆ’ xi
â‰¤ (kf 0 (zk ) âˆ’ f 0 (xâˆ— )k + kf 0 (xâˆ— )k)kxkâˆ’1 âˆ’ xk

2
â‰¤ LDX
+ kf 0 (xâˆ— )kDX ,

(51)

where the first inequality follows from Cauchy-Schwarz and
the triangle inequality, and the second inequality follows
2
from (2) and (4). Note that we always have Î·k < Î±Î²k DX
.
2
Therefore, similar to the stochastic case, our O(LDX /)
bound immediately follows from the above relation, (39),
and (49).
As before in the stochastic case, we can slightly improve
the complexity bound on the calls to the FO oracle in terms
of the dependence on DX .
Corollary B.3. Suppose that there exists an estimate D0 â‰¥
kx0 âˆ’ xâˆ— k and that the outer iteration limit N â‰¥ 1 is given.
If
2LD02
2
(52)
Î²k = 2L
k , Î³k = k+1 , Î·k = N k ,
for k â‰¥ 1, then

f (y) âˆ’ f (x) âˆ’ hf 0 (x), y âˆ’ xi â‰¥

Âµ
2 ky

âˆ’ xk2 , âˆ€x, y âˆˆ X.
(55)

For simplicity, we first establish the convergence results
for the deterministic case, i.e., we have access to the exact
gradients of the objective function f .

respectively.

The shrinking conditional gradient method in (Lan, 2013)
needs to make additional assumptions on the LO oracle to
obtain a linear rate of convergence. However, we will show
now that CALGD (relying on the vanilla weak separation
oracle) can obtain a linear rate of convergence in terms of
2
the number of calls to the FO oracle and O(LDX
/) rate
of convergence in the total number of calls to the LOsep
oracle. In view of the lower complexity bound established
for the LO oracle to solve strongly convex problems in
(Jaggi, 2013; Lan, 2013), our bound for the LOsep oracle
is not improvable.

Proof. The proof is similar to Corollary B.2, and hence
omitted.

We are now ready to formally describe the CALGD method
for solving strongly convex problems, which is obtained by
properly restarting the CALGD method (Algorithm 2).

f (yN ) âˆ’ f (xâˆ— ) â‰¤

6LD02
N (N +1) .

(53)

As a consequence, the total number of calls to the FO and
LOsep oracles performed by the CALGD method for finding
an -solution of (1) can be bound by
 q 
 2 
LDX
O D0 L
and O
(54)


Conditional Accelerated Lazy Stochastic Gradient Descent

Algorithm 3 The CALGD method for strongly convex problems
Input: Initial point p0 âˆˆ X and an estimate Î´0 > 0
satisfying f (p0 ) âˆ’ f (xâˆ— ) â‰¤ Î´0 .
for s = 1, 2, . . . do
Call the CALGD method in Algorithm 2 with input
l q m
x0 = psâˆ’1 and N = 2 6L
,
(56)
Âµ

2L
k ,

Î³k =

 2 s 
ÂµDX 2 N
O
s=1
k=1
Î´0
 2 2P

ÂµDX N
S
s
=O
s=1 2
Î´0

 2 2
 2 2
ÂµDX N
ÂµDX N
S+1
=
O
=O
2
,
Î´0


PS PN
s=1

k=1 Ts,k â‰¤

PS PN

which implies our second bound in (58) due to the definitions of N and S in (56) and (59), respectively.

and parameters
Î²k =

Therefore, the total number of calls to the LOsep oracle can
be bounded by

2
k+1 ,

and Î·k = Î·s,k :=

8LÎ´0 2âˆ’s
ÂµN k ,

(57)
and let ps be its output solution.
end for

In Algorithm 3, we restart the CALGD p
method for smooth
optimization (i.e., Algorithm 2) every d2 6L/Âµe iterations.
We call each loop iteration a phase of the above CALGD
algorithm. Observe that {Î·k } decrease by a factor of 2 as
s increments by 1, while {Î²k } and {Î³k } remain the same.
The following theorem shows the convergence of the above
variant of the CALGD method.
Theorem C.1. Assume (55) holds and let {ps } be generated
by Algorithm 3. Then,
f (ps ) âˆ’ f (xâˆ— ) â‰¤ Î´0 2âˆ’s ,

s â‰¥ 0.

As a consequence, the total number of calls to the FO and
LOsep oracles performed by this algorithm for finding an
-solution of problem (1) can be bounded by
nq 
n 2 o
o
LDX
Î´0
L
, (58)
O
and O
Âµ log2 max 1, 

respectively.
Proof. Denote the total number of phases performed by
CALGD method to obtain an -solution of (1) by S. In view
of the complexity results obtained in Theorem 2.5 in (Lan
and Zhou, 2014), we conclude that


S = log2 max 1, Î´0 .
(59)
The total number of calls to the FO oracle performed by
Algorithm 3 is clearly bounded by N S, which immediately
implies our first result in (58).
Now, let Ts,k denote the number of calls to the LOsep
oracle required at the k-th outer iteration in the s-th phase.
It follows from Theorem B.1.c), (51), and (57) that


 2 s 
Î² D2
ÂµDX 2 N
Ts,k â‰¤ O Î·ks,kX = O
.
Î´0

In view of classic complexity theory for convex optimization, the bound on the total number of calls to the FO oracle
(cf. first bound in (58)) is optimal for strongly convex optimization. Moreover, in view of the complexity results
established in (Lan, 2013) and the fact that the LOsep oracle is weaker than the LO oracle, the bound on the total
number of calls to the LOsep oracle (cf. second bound in
(58)) is not improvable either.
C.2. Strongly convex stochastic optimization
Similarly to the deterministic case we present an optimal
algorithm for solving stochastic smooth and strongly convex
problems.
Algorithm 4 The CALSGD method for solving strongly
convex problems
Input: Initial point p0 âˆˆ X and an estimate Î´0 > 0
satisfying f (p0 ) âˆ’ f (xâˆ— ) â‰¤ Î´0 .
for s = 1, 2, . . . do
Call the CALSGD method in Algorithm 1 with input
l q m
x0 = psâˆ’1 and N = 4 2L
,
(60)
Âµ
and parameters
Î²k =

3L
k ,

Î³k =

âˆ’s

02
Î·k = Î·s,k := 8LÎ´
ÂµN k ,
l 2
m
2
:= ÂµÏƒ4LN2 Î´(k+1)
,
(61)
âˆ’s
02

2
k+1 ,

and Bk = Bs,k

and let ps be its output solution.
end for

The main convergence properties of Algorithm 4 are as
follows.
Theorem C.2. Assume that (55) holds and let {ps } be generated by Algorithm 4. Then,
E[f (ps ) âˆ’ f (xâˆ— )] â‰¤ Î´0 2âˆ’s ,

s â‰¥ 0.

Conditional Accelerated Lazy Stochastic Gradient Descent

As a consequence, the total number of calls to the SFO and
LOsep oracles performed by this algorithm for finding a
stochastic -solution of problem (1)-(8) can be bounded by
n 2 q 
o
Î´0
log
max
1,
,
(62)
O ÏƒÂµ + L
2
Âµ

and
O

n

2
LDX


o

, with probability 1 âˆ’ Î›,

Proof. In view of Corollary 2.5, and Theorem 3.4 in (Lan
and Zhou, 2014), the total number of phases, S, performed
by CALSGD method to find a stochastic -solution of problem (1)-(8) is bounded by (59). Since the number of outer
iterations in each phase is at most N , the total number of
calls to the SFO oracle is bounded by

PS PN
PS PN  ÂµÏƒ2 N (k+1)2
s=1
k=1 Bk â‰¤
s=1
k=1
4L2 Î´0 2âˆ’s + 1
2
N (N +1)3 PS
s
â‰¤ ÂµÏƒ 12L
2Î´
s=1 2 + SN
0
â‰¤

For the sake of simplicity, we consider the deterministic
case, i.e., the problem of interest is an important class of
saddle point problems with f given in the form of
n
o
f (x) = max hAx, yi âˆ’ fË†(y) ,
(64)
yâˆˆY

(63)

respectively.

ÂµÏƒ 2 N (N +1)3
3L2 

C.3. Non-smooth optimization: Saddle point problems

+ SN.

Moreover, similar to (31), we obtain a good estimator for
Î¦s,k
0 , for any 0 < Î› â‰¤ 1
q

s,k
2
0 âˆ—
4SL2 Î´0
Î¦0 â‰¤
Î›Âµk2 2s + 1 LDX + kf (x )kâˆ— DX ,
with probability 1 âˆ’ Î›. Let Ts,k denote the number of calls
to the LOsep oracle required at the k-th outer iteration in the
s-th phase of the CALSGD method. It follows from Theorem 2.3.c), the above relation, and (61) that with probability
1 âˆ’ Î›,


 2 s 
Î¦s,k
Î² D2
ÂµDX 2 N
0
Ts,k â‰¤ O log Î·s,k
+ Î·ks,kX = O
Î´0
holds. Therefore, the total number of calls to the LOsep
oracle is bounded by
 2 s 
PS PN
PS PN
ÂµDX 2 N
T
â‰¤
O
s,k
s=1
k=1
s=1
k=1
Î´0


P
S
âˆ’1
2
s
= O ÂµDX
N 2 Î´0
s=1 2
 2 2
ÂµDX N
,
=O

which implies the bound in (63), due to the definitions of N
and S in (60) and (59), respectively.
According to Theorem C.2, the total number of calls to the
SFO oracle is bounded by O(1/), which is optimal in view
of the classic complexity theory for strongly convex optimization (see (Ghadimi and Lan, 2012; 2013)). Moreover,
the total number of calls to the LOsep oracle is bounded by
O(1/), which is the same bound as for the CALGD method
for strongly convex optimization and hence not improvable.

where A : Rn â†’ Rm denotes a linear operator, Y âˆˆ Rm is
a convex compact set, and fË† : Y â†’ R is a simple convex
function. Since the objective function f is non-smooth, we
cannot directly apply the CALGD method presented in the
previous section. However, as shown by Nesterov (Nesterov,
2005), the function f (Â·) in (64) can be closely approximated
by a class of smooth convex functions. More specifically,
let Ï‰ : Y â†’ R be a given strongly convex function with
strongly convex modulus ÏƒÏ‰ > 0, i.e.,
Ï‰(y) â‰¥ Ï‰(x) + hÏ‰ 0 (x), y âˆ’ xi +

ÏƒÏ‰
2 ky

âˆ’ xk2 , âˆ€x, y âˆˆ Y,

and let us denote cÏ‰ := argminyâˆˆY Ï‰(y), W (y) := Ï‰(y) âˆ’
Ï‰(cÏ‰ ) âˆ’ hâˆ‡Ï‰(cÏ‰ ), y âˆ’ cÏ‰ i and
2
DY,W
:= max W (y).
yâˆˆY

It can be easily seen that
ky âˆ’ cÏ‰ k2 â‰¤

2
ÏƒÏ‰ W (y)

â‰¤

2
2
ÏƒÏ‰ DY,W ,

âˆ€y âˆˆ Y,

and hence that
ky1 âˆ’ y2 k2 â‰¤

2
4
ÏƒÏ‰ DY,W ,

âˆ€y1 , y2 âˆˆ Y.

In view of these relations, the function f (Â·) in (64) can be
closely approximated by
n
o
2
fÏ„ (x) := max hAx, yi âˆ’ fË†(y) âˆ’ Ï„ [W (y) âˆ’ DY,W
] .
yâˆˆY

(65)
In particular, for any Ï„ â‰¥ 0,
2
f (x) â‰¤ fÏ„ (x) â‰¤ f (x) + Ï„ DY,W
, âˆ€x âˆˆ X.

Moreover, Nesterov (Nesterov, 2005) shows that fÏ„ (Â·) is
differentiable and its gradients are Lipschitz continuous with
the Lipschitz constant given by
LÏ„ :=

kAk2
Ï„ ÏƒÏ‰ .

(66)

Throughout this subsection, we assume that the feasible
region Y and the function fË† are simple enough, so that the
subproblem in (65) is easy to solve. Therefore, the major
computational cost for gradient calculations of fÏ„ lie in the
evaluations of the linear operator A and its adjoint operator
AT . We are now ready to present a variant of the CALGD
method, which can achieve optimal bounds on the number

Conditional Accelerated Lazy Stochastic Gradient Descent

of calls to the LOsep oracle and the number of evaluations
of the linear operators A and AT .
Algorithm 5 The CALGD method for solving saddle point
problems
This algorithm is the same as Algorithm 2 except that
(44) is replaced by
xk = LCG(fÏ„0 k (zk ), Î²k , xkâˆ’1 , Î±, Î·k ),

(67)

for some Ï„k â‰¥ 0.

Theorem C.3. Suppose that Ï„1 â‰¥ Ï„2 â‰¥ . . . â‰¥ 0. Also
assume that {Î²k } and {Î³k } satisfy (35) (with L replaced by
LÏ„k defined in (66)) and (36). Then, for all k â‰¥ 1,
Î²k Î³k 2
2 DX

Pk

Î³i
i=1 Î“i


2
Î·i + Ï„i DY,W
,
(68)
where xâˆ— is an arbitrary optimal solution of (1)-(64). Moreover, the number of inner iterations performed at the k-th
outer iteration is bounded by (39).
+ Î“k

Proof. The proof is similar to Theorem 4.1 in (Lan and
Zhou, 2014), and hence omitted.
We now provide two different sets of parameter settings
for {Î²k }, {Î³k }, {Î·k }, and {Ï„k } which can guarantee the
optimal convergence of the above variant of the CALGD
method for saddle point optimization. Specifically, Corollary C.4 gives a static setting for parameter {Ï„k } under the
assumption that the outer iteration limit N â‰¥ 1 is given,
while a dynamic setting is provided in Corollary C.5.
Corollary C.4. Assume the outer iteration limit N â‰¥ 1 is
given. If
2kAkDX
âˆš
Ï„k â‰¡ Ï„ = DY,W
(69)
ÏƒÏ‰ N , k â‰¥ 1,
and {Î²k }, {Î³k }, and {Î·k } used in Algorithm 5 are set to
Î²k =

3LÏ„k
k+1

, Î³k =

k

3
k+2 , and

Î·k =

2
LÏ„k DX
,
k2

k â‰¥ 1, (70)

then the number of linear operator evaluations (for A and
AT ) and the number of calls to the LOsep oracle performed
by Algorithm 5 for finding an -solution of problem (1)-(64),
respectively, is bounded by
n
o
n
o
2
2
kAk2 DX
DY,W
kAkDX DY,W
âˆš
O
and
O
.
(71)
2
ÏƒÏ‰ 
ÏƒÏ‰ 
Proof. In view of the result in Corollary 4.2 of (Lan and
Zhou, 2014), our first bound in (71) immediately follows.

X

which implies our second bound in (71).
Corollary C.5. Suppose that parameter {Ï„k } is now set to
Ï„k =

In Theorem C.3 we state the main convergence properties
of this modified CALGD method to solve the saddle point
problem in (1)-(64).

f (yk ) âˆ’ f (xâˆ— ) â‰¤

Moreover, it follows from (51), (39), (69), (70) and (66) that
the total number of calls to the LOsep oracle is bounded by


2
PN
PN
Î²k DX
k=1 Tk â‰¤
k=1 O
Î·k


2
PN
L k DX
k2
= O(N 2 ),
= k=1 O Ï„k+1
2
LÏ„ D

2kAkDX
âˆš
DY,W ÏƒÏ‰ k ,

k â‰¥ 1,

(72)

and the parameters {Î²k }, {Î³k }, and {Î·k } used in Algorithm 5 are set as in (70). Then, the number of linear operator evaluations (for A and AT ) and the number of calls to
the LOsep oracle performed by Algorithm 5 for finding an
-solution of problem (1)-(64) is bounded by the two bounds
as given in (71) respectively.
Proof. The proof is similar to the Corollary C.4, and hence
omitted.
In view of the discussions in (Chen et al., 2014), the obtained
bound on the total number of operator evaluations (cf. first
bound in (71)) is not improvable for solving the saddle
point problems in (1)-(64). Moreover, according to (Lan,
2013) and the fact that the LOsep oracle is weaker than LO
oracle, the O(1/2 ) bound on the total number of calls to
the LOsep is not improvable.
C.4. Non-smooth stochastic optimization: stochastic
saddle point problems
In this subsection, we briefly discuss stochastic saddle point
problems, i.e., only stochastic gradients of fÏ„ (cf. (65)) are
available. In particular, we consider the situation when the
original objective function f in (1) is given by


f (x) = E maxhAÎ¾ x, yi âˆ’ fË†(y, Î¾) ,
(73)
yâˆˆY

where fË†(Â·, Î¾) is simple concave function for all Î¾ âˆˆ Îž and
AÎ¾ is a random linear operator such that


E kAÎ¾ k2 â‰¤ L2A
(74)
We can solve this stochastic saddle point problem by replacing (67) with
xk = LCG(gk , xkâˆ’1 , Î²k , Î·k ),
PBk 0
where gk = B1k j=1
FÏ„k (zk , Î¾k,j ) for some Ï„k â‰¥ 0 and
Bk â‰¥ 1. By properly specifying {Î²k }, {Î·k }, {Ï„k }, and
{Bk }, we can show that the number of linear operator
evaluations (for AÎ¾ and ATÎ¾ ) and the number of calls to

Conditional Accelerated Lazy Stochastic Gradient Descent

the LOsep oracle performed by this variant of CALSGD
method for finding a stochastic -solution of problem (1)(73) is bounded by
n 2 2 2 o
LA DX DY,W
,
O
ÏƒÏ‰ 2

of all Hamiltonian cycles of graphs of different size. In
Figure 8 the polytopes are the standard formulation of the
cut problem and the Birkhoff polytope.

and

In this section we consider instances of the problem of
finding the minimum of a convex function over the standard
spectrahedron, which is defined as

O

n

2
2
L2A DX
DY,W
ÏƒÏ‰ 2

o

with probability 1 âˆ’ Î› respectively. This result can be
proved by combining the techniques in Section 2 and those
in Theorem C.3. However, we skip the details of these
developments for the sake of simplicity.

D. Experimental results
We now provide additional experimental results in this section. The setup of the problems is as described in Section 3,
2
i.e., we use kAxâˆ’bk as the objective function where A is a
m Ã— n matrix with n being the dimension of the underlying
feasible region and m being the number of examples. In
each example we use a density parameter d specifying the
fraction of non-zero entries in A. We compute b = Axâˆ—
with some feasible point xâˆ— so that in all examples the optimal value is 0. Albeit the theoretical number of samples
Bk (see Equation (26)) needed for CALSGD we use a batch
size of 128 for each gradient computation in all algorithms
for comparability. The function values that we report are
calculated using the full matrix A, however since they are
not used by either algorithm, each algorithm has only the
information provided by the 128 examples sampled in that
specific round.
We implemented all algorithms using Python 2.7 using
Gurobi 7.0 (Gurobi Optimization, 2016) as the solver
for our linear models.
D.1. Video co-localization
Video co-localization is the problem of identifying and object over multiple frames of a video. As shown by (Joulin
et al., 2014) this problem can be solved by quadratic programming over a path/flow polytope. In Figures 2, 3 and
7 we show that our algorithm CALSGD performs significantly better than OFW on this type of instances. We use
path polytopes available at http://lime.cs.elte.
hu/~kpeter/data/mcf/road/. The non-zero entries of A in this section are chosen uniformly from [0, 1]
and the density parameter we used is d = 0.8.
D.2. Structured regression
For our structured regression instances we solve the objec2
tive function kAx âˆ’ bk as described before over different
polytopes. In Figure 6 the feasible region is the convex hull

D.3. Convex optimization over spectrahedra

Sn := {X âˆˆ RnÃ—n | X < 0, tr(X) = 1}.
In this case the linear minimization problem for an objective
function C is solved by computing an eigenvector for the
largest eigenvalue of âˆ’C. We use the same method to
implement LOsepSn .
We show results on three different sized instances, in Figure 9 for n = 50, Figure 10 for n = 100 and in Figure 11
for n = 150.

Conditional Accelerated Lazy Stochastic Gradient Descent

1010
CALSGD
OFW

109
108
107
106
105
104
103

0

8
16
Iterations

Function value

Function value

1010

107
106
105
104
0

8
16
Iterations

24

1010
CALSGD
OFW

109
108
107
106
105
104
0

150
300
450
Wall clock time

Function value

Function value

1010

103

108

103

24

CALSGD
OFW

109

CALSGD
OFW

109
108
107
106
105
104
103

0

150
300
450
Wall clock time

Figure 7. Two large video co-localization instances. On the left: road_paths_03_NH_a instance (n = 262958 and m = 10000).
On the right: road_paths_03_NH_b instance (n = 262958 and m = 10000). CALSGD has a better performance in both, iterations
and wall clock time.

Conditional Accelerated Lazy Stochastic Gradient Descent

102
CALSGD
OFW

104
103
102
101
100
10âˆ’1

0

800 1600 2400
Iterations

CALSGD
OFW

Function value

Function value

105

101
100
10âˆ’1

CALSGD
OFW

104
103
102
101
100
10âˆ’1

1500 3000
Iterations

4500

102

0

2000 4000 6000 8000
Wall clock time

Function value

Function value

105

0

CALSGD
OFW

101
100
10âˆ’1

0

150
300
450
Wall clock time

Figure 8. Structured regression problem over the cut polytope for a graph on 23 vertices on the left and the Birkboff polytope containing
all doubly stochastic matrices of size 100 Ã— 100 on the right. In both cases we used m = 10000 rows for the matrix A, on the left a
density of d = 0.6 and on the right d = 0.8. In both cases the number of iterations computed in the given time between CALSGD and
OFW is quite significant, however in both cases CALSGD achieves better function values in the smaller number of iterations. In the
example of the Birkhoff polytope it almost looks like as if OFW converges suboptimally, however this is due to the large number of
iterations required: the convergence rate of OFW as shown by (Hazan and Kale, 2012) is O(T âˆ’1/4 ), so if we compute the improvement
with logarithmic scale, from, e.g., iteration 1500 to iteration 4500, we get âˆ’1/4(log(1500) âˆ’ log(4500)) â‰ˆ 0.12 (the constants hidden
in the O-notation get canceled due to the logarithm and the difference) and therefore indeed fits to the observation on the graph.

Conditional Accelerated Lazy Stochastic Gradient Descent

103
CALSGD
OFW

102
101
10
10

0

âˆ’1

10âˆ’2
10âˆ’3
10âˆ’4

0

Function value

Function value

103

CALSGD
OFW

102
101
100
âˆ’1

10âˆ’2
10âˆ’3
10âˆ’4

100
10âˆ’1
10âˆ’2
0

1000 2000 3000 4000
Iterations

103

0

25
50
75 100
Wall clock time

Function value

Function value

103

10

101

10âˆ’3

2000 4000 6000 8000
Iterations

CALSGD
OFW

102

CALSGD
OFW

102
101
100
10âˆ’1
10âˆ’2
10âˆ’3

0

25
50
75 100
Wall clock time

Figure 9. Quadratic optimization over the standard spectrahedron of size n = 50. On the left we use m = 10000 on the right m = 20000.
In both cases CALSGD performs better than OFW both in iterations as well as in wall clock time. As described in Figure 8 the impression
of suboptimal convergence of OFW can be explained by the very high number of iterations required.

Conditional Accelerated Lazy Stochastic Gradient Descent

103
CALSGD
OFW

102
101
100
10âˆ’1
10âˆ’2
10âˆ’3
10âˆ’4

0

Function value

Function value

103

100
10âˆ’1
10âˆ’2
10âˆ’3
0

250 500 750 1000
Iterations

103
CALSGD
OFW

102
101
100
10âˆ’1
10âˆ’2
10âˆ’3
0

25
50
75 100
Wall clock time

Function value

Function value

103

10âˆ’4

101

10âˆ’4

500 1000 1500
Iterations

CALSGD
OFW

102

CALSGD
OFW

102
101
100
10âˆ’1
10âˆ’2
10âˆ’3
10âˆ’4

0

25
50
75 100
Wall clock time

Figure 10. Medium sized quadratic optimization over the standard spectrahedron (n = 100). Again we chose m = 10000 on the left and
m = 20000 on the right. The CALSGD method achieves values multiple orders of magnitude better within the given time window.

Conditional Accelerated Lazy Stochastic Gradient Descent

103
CALSGD
OFW

102
101
100
10âˆ’1
10âˆ’2
10âˆ’3
10âˆ’4

0

200 400 600
Iterations

Function value

Function value

103

100
10âˆ’1
10âˆ’2
10âˆ’3
0

100 200 300
Iterations

400

103
CALSGD
OFW

102
101
100
10âˆ’1
10âˆ’2
10âˆ’3
0

25
50
75 100
Wall clock time

Function value

Function value

103

10âˆ’4

101

10âˆ’4

800

CALSGD
OFW

102

CALSGD
OFW

102
101
100
10âˆ’1
10âˆ’2
10âˆ’3
10âˆ’4

0

25
50
75 100
Wall clock time

Figure 11. Large quadratic optimization over the standard spectrahedron (n = 150), with m = 10000 on the left and m = 20000 on the
right. The behaviour and the achieved objective function values are very similar to the medium size instances in Figure 10.

