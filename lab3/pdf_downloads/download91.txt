Robust Submodular Maximization: A Non-Uniform Partitioning Approach

Supplementary Material
“Robust Submodular Maximization: A Non-Uniform Partitioning Approach” (ICML 2017)
Ilija Bogunovic, Slobodan Mitrović, Jonathan Scarlett, and Volkan Cevher
A. Proof of Proposition 4.1
We have
|S0 | =


dlog ⌧ e

X
i=0

d⌧ /2i e2i ⌘

dlog ⌧ e ⇣

X
i=0

⌘
⌧
+
1
2i ⌘
2i

 ⌘(dlog ⌧ e + 1)(⌧ + 2dlog ⌧ e )
 3⌘⌧ (dlog ⌧ e + 1)
 3⌘⌧ (log k + 2).

B. Proof of Proposition 4.4
Recalling that Aj (T ) denotes a set constructed by the algorithm after j iterations, we have
f (Aj (T ))

f (Aj

1

1 (T ))

max f (e|Aj
e2T

1

1 (T ))

max f (e|Ak (T ))
e2T

1

max

e2T \Ak (T )

f (e|Ak (T )),

where the first inequality follows from the -iterative property (6), and the second inequality follows from Aj
Ak (S) and the submodularity of f .

(13)
1 (S)

✓

Continuing, we have

f (Ak (T )) =

k
X

f (Aj (T ))

f (Aj

1 (T ))

j=1

k

max

e2T \Ak (T )

f (e|Ak (T )),

where the last inequality follows from (13).
By rearranging, we have for any e 2 T \ Ak (T ) that
f (e|Ak (T )) 

f (Ak (T ))
.
k

C. Proof of Lemma 4.3
Recalling that Aj (T ) denotes the set constructed after j iterations when applied to T , we have
X
1
max
f (e|Aj 1 (T ))
f (e|Aj 1 (T ))
k
e2T \Aj 1 (T )
e2OPT(k,T )\Aj

1 (T )

1
f (OPT(k, T )|Aj 1 (T ))
k
1
f (OPT(k, T )) f (Aj 1 (T )) ,
k

(14)

Robust Submodular Maximization: A Non-Uniform Partitioning Approach

where the first line holds since the maximum is lower bounded by the average, the line uses submodularity, and the last
line uses monotonicity.
By combining the -iterative property with (14), we obtain
f (Aj (T ))

f (Aj

1 (T ))

1

max

e2T \Aj

1 (T )

f (e|Aj

1 (T ))

1
f (OPT(k, T ))
k

f (Aj

1 (T ))

.

 k f (Aj (T ))

f (Aj

1 (T ))

.

By rearranging, we obtain
f (OPT(k, T ))

f (Aj

1 (T ))

We proceed by following the steps from the proof of Theorem 1.5 in (Krause & Golovin, 2012). Defining
f (OPT(k, T )) f (Aj (T )), we can rewrite (15) as j 1  k( j 1
j ). By rearranging, we obtain
✓
◆
1
j  1
j 1.
k

(15)
j

:=

l

1
Applying this recursively, we obtain l  1
0 , where 0 = f (OPT(k, T )) since f is normalized (i.e., f (;) = 0).
k
x
Finally, applying 1 x  e and rearranging, we obtain
⇣
⌘
l
f (Al (T ))
1 e k f (OPT(k, T )).

D. Proof of Theorem 4.5
D.1. Technical Lemmas

We first provide several technical lemmas that will be used throughout the proof. We begin with a simple property of
submodular functions.
Lemma D.1 For any submodular function f on a ground set V , and any sets A, B, R ✓ V , we have
f (A [ B)

f (A [ (B \ R))  f (R | A).

Proof. Define R2 := A \ R, and R1 := R \ A = R \ R2 . We have
f (A [ B)

f (A [ (B \ R)) = f (A [ B)

f ((A [ B) \ R1 )

= f (R1 | (A [ B) \ R1 )
 f (R1 | (A \ R1 ))

(16)

= f (R1 [ R2 | A)

(18)

= f (R1 | A)

(17)

= f (R | A),

where (16) follows from the submodularity of f , (17) follows since A and R1 are disjoint, and (18) follows since R2 ✓ A.
2
The next lemma provides a simple lower bound on the maximum of two quantities; it is stated formally since it will be
used on multiple occasions.
Lemma D.2 For any set function f , sets A, B, and constant ↵ > 0, we have
✓
◆
1
max{f (A), f (B) ↵f (A)}
f (B),
1+↵
and

max{↵f (A), f (B)

f (A)}

✓

↵
1+↵

◆

f (B).

(19)

(20)

Robust Submodular Maximization: A Non-Uniform Partitioning Approach

Proof. Starting with (19), we observe that one term is increasing in f (A) and the other is decreasing in f (A). Hence, the
1
maximum over all possible f (A) is achieved when the two terms are equal, i.e., f (A) = 1+↵
f (B). We obtain (20) via the
same argument. 2
The following lemma relates the function values associated with two buckets formed by PRO, denoted by X and Y . It is
stated with respect to an arbitrary set EY , but when we apply the lemma, this will correspond to the elements of Y that are
removed by the adversary.
Lemma D.3 Under the setup of Theorem 4.5, let X and Y be buckets of PRO such that Y is constructed at a later time
than X. For any set EY ✓ Y , we have
1
f (X [ (Y \ EY ))
f (Y ),
1+↵
and
f (EY | X)  ↵f (X),
(21)
where ↵ =

|EY |
|X| .

Proof. Inequality (21) follows from the -iterative property of A; specifically, we have from (8) that
f (e|X) 

f (X)
,
|X|

where e is any element of the ground set that is neither in X nor any bucket constructed before X. Hence, we can write
f (EY | X) 

X

e2EY

f (e|X) 

|EY |
f (X) = ↵f (X),
|X|

where the first inequality is by submodularity. This proves (21).
Next, we write
f (Y )

f (X [ (Y \ EY ))  f (X [ Y )

 f (EY | X),

f (X [ (Y \ EY ))

(22)
(23)

where (22) is by monotonicity, and (23) is by Lemma D.1 with A = X, B = Y , and R = EY .
Combining (21) and (23), together with the fact that f (X [ (Y \ EY ))
f (X [ (Y \ EY ))

f (X) (by monotonicity), we have

max {f (X), f (Y )
1
f (Y ),
1+↵

↵f (X)}
(24)

where (24) follows from (19). 2
Finally, we provide a lemma that will later be used to take two bounds that are known regarding the previously-constructed
buckets, and use them to infer bounds regarding the next bucket.
Lemma D.4 Under the setup of Theorem 4.5, let Y and Z be buckets of PRO such that Z is constructed at a later time
than Y , and let EY ✓ Y and EZ ✓ Z be arbitrary sets. Moreover, let X be a set (not necessarily a bucket) such that
f ((Y \ EY ) [ X)

1
f (Y ),
1+↵

(25)

and
Then, we have

f (EY | X)  ↵f (X).

(26)

f (EZ | (Y \ EY ) [ X)  ↵next f ((Y \ EY ) [ X),

(27)

Robust Submodular Maximization: A Non-Uniform Partitioning Approach

and

1
f (Z),
1 + ↵next

f ((Z \ EZ ) [ (Y \ EY ) [ X)
where
↵next =

|EZ |
(1 + ↵) + ↵.
|Y |

(28)
(29)

Proof. We first prove (27):
f (EZ | (Y \ EY ) [ X) = f ((Y \ EY ) [ X [ EZ )
 f (X [ Y [ EZ )

f ((Y \ EY ) [ X)

f ((Y \ EY ) [ X)

= f (EZ | X [ Y ) + f (X [ Y )
 f (EZ | Y ) + f (X [ Y )

f ((Y \ EY ) [ X)

f ((Y \ EY ) [ X)

|EZ |

f (Y ) + f (X [ Y ) f ((Y \ EY ) [ X)
|Y |
|EZ |

(1 + ↵)f ((Y \ EY ) [ X) + f (X [ Y ) f ((Y \ EY ) [ X)
|Y |
|EZ |

(1 + ↵)f ((Y \ EY ) [ X) + f (EY | (Y \ EY ) [ X)
|Y |
|EZ |

(1 + ↵)f ((Y \ EY ) [ X) + f (EY | X)
|Y |
|EZ |

(1 + ↵)f ((Y \ EY ) [ X) + ↵f (X)
|Y |
|EZ |

(1 + ↵)f ((Y \ EY ) [ X) + ↵f ((Y \ EY ) [ X)
|Y |
✓
◆
|EZ |
=
(1 + ↵) + ↵ f ((Y \ EY ) [ X).,
|Y |

(30)
(31)
(32)
(33)
(34)
(35)
(36)
(37)
(38)

where: (30) and (31) follow by monotonicity and submodularity, respectively; (32) follows from the second part of
Lemma D.3; (33) follows from (25); (34) is obtained by applying Lemma D.1 for A = X, B = Y , and R = EY ;
(35) follows by submodularity; (36) follows from (26); (37) follows by monotonicity. Finally, by defining ↵next :=
|EZ |
|Y | (1 + ↵) + ↵ in (38) we establish the bound in (27).
In the rest of the proof, we show that (28) holds as well. First, we have
f ((Z \ EZ ) [ (Y \ EY ) [ X)

f (Z)

f (EZ | (Y \ EY ) [ X)

(39)

by Lemma D.1 with B = Z, R = EZ and A = (Y \ EY ) [ X. Now we can use the derived bounds (38) and (39) to obtain
f ((Z \ EZ ) [ (Y \ EY ) [ X)

f (Z)
f (Z)

Finally, we have
f ((Z \ EZ ) [ (Y \ EY ) [ X)

f (EZ | (Y \ EY ) [ X)
✓
◆
|EZ |
(1 + ↵) + ↵ f ((Y \ EY ) [ X).
|Y |

⇢
max f ((Y \ EY ) [ X), f (Z)
1
f (Z),
1 + ↵next

✓

◆
|EZ |
(1 + ↵) + ↵ f ((Y \ EY ) [ X)
|Y |

where the last inequality follows from Lemma D.1. 2
Observe that the results we obtain on f (EZ | (Y \ EY ) [ X) and on f ((Z \ EZ ) [ (Y \ EY ) [ X) in Lemma D.4 are of
the same form as the pre-conditions of the lemma. This will allow us to apply the lemma recursively.

Robust Submodular Maximization: A Non-Uniform Partitioning Approach

D.2. Characterizing the Adversary
Let E denote a set of elements removed by an adversary, where |E|  ⌧ . Within S0 , PRO constructs dlog ⌧ e + 1 partitions.
Each partition i 2 {0, . . . , dlog ⌧ e} consists of d⌧ /2i e buckets, each of size 2i ⌘, where ⌘ 2 N will be specified later. We
let B denote a generic bucket, and define EB to be all the elements removed from this bucket, i.e. EB = B \ E.
The following lemma identifies a bucket in each partition for which not too many elements are removed.

Lemma D.5 Under the setup of Theorem 4.5, suppose that an adversary removes a set E of size at most ⌧ from the set S
constructed by PRO. Then for each partition i, there exists a bucket Bi such that |EBi |  2i , i.e., at most 2i elements are
removed from this bucket.
Proof. Towards contradiction, assume that this is not the case, i.e., assume |EBi | > 2i for every bucket of the i-th partition.
As the number of buckets in partition i is d⌧ /2i e, this implies that the adversary has to spend a budget of
|E|

2i |EBi | > 2i d⌧ /2i e = ⌧,

which is in contradiction with |E|  ⌧ . 2
We consider B0 , . . . , Bdlog ⌧ e as above, and show that even in the worst case, f

⇣S

dlog ⌧ e
i=0

⌘
(Bi \ EBi ) is almost as large

as f Bdlog ⌧ e for appropriately set ⌘. To achieve this, we apply Lemma D.4 multiple times, as illustrated in the following
lemma. We henceforth write ⌘h := ⌘/2 for brevity.

Lemma D.6 Under the setup of Theorem 4.5, suppose that an adversary removes a set E of size at most ⌧ from the set S
constructed by PRO, and let B0 , · · · , Bdlog ⌧ e be buckets such that |EBi |  2i for each i 2 {1, · · · dlog ⌧ e} (cf., Lemma
D.5). Then,
0
1
✓
◆
dlog ⌧ e
[
1
1
@
A
f
(Bi \ EBi )
1
f Bdlog ⌧ e =
f Bdlog ⌧ e ,
(40)
1
1
+
↵
1
+
↵
i=0
and

0

f @EBdlog ⌧ e

for some

dlog ⌧ e 1

[

i=0

1

dlog ⌧ e 1

(Bi \ EBi )A  ↵f @
2 (1

↵

0

[

i=0

dlog ⌧ e

+ ⌘h )dlog ⌧ e

⌘h

dlog ⌧ e

⌘h

1

(Bi \ EBi )A ,

(41)

(42)

.

Proof. In what follows, we focus on the case where there exists some bucket B0 in partition i = 0 such that B0 \EB0 = B0 .
If this is not true, then E must be contained entirely within this partition, since it contains ⌧ buckets. As a result, (i) we
trivially obtain (40) even when ↵ is replaced by zero, since the union on the left-hand side contains Bdlog ⌧ e ; (ii) (41)
becomes trivial since the left-hand side is zero is a result of EBdlog ⌧ e = ;.
We proceed by induction. Namely, we show that
!
j
[
f
(Bi \ EBi )
i=0

and

f

E Bj

j[1
i=0

for every j

1, where

1

1
1 + ↵1j

(Bi \ EBi )

↵j 

!

2 (1

!

 ↵j f

+ ⌘h ) j
⌘hj

Upon showing this, the lemma is concluded by setting j = dlog ⌧ e.

f (Bj ) =

j[1
i=0

⌘hj

.

1
f (Bj ),
1 + ↵j
!

(Bi \ EBi ) ,

(43)

(44)

(45)

Robust Submodular Maximization: A Non-Uniform Partitioning Approach

Base case j = 1. In the case that j = 1, taking into account that EB0 = ;, we observe from (43) that our goal is to bound
f (B0 [ (B1 \ EB1 )). Applying Lemma D.3 with X = B0 , Y = B1 , and EY = EB1 , we obtain
1
f (B1 ),
1 + ↵1

f (B0 [ (B1 \ EB1 ))
and
where ↵1 =

|EB1 |
|B0 | .

f (EB1 | B0 )  ↵1 f (B0 ),
We have |B0 | = ⌘, while |EB1 |  2 by assumption. Hence, we can upper bound ↵1 and rewrite as
2
=
⌘

↵1 
where the last inequality follows since
Inductive step.
well.

Fix j

1
=
⌘h

(1 + ⌘h )
⌘h

⌘h

2 (1



+ ⌘h )
⌘h

f

j
[

i=0

,

1 by definition.

2. Assuming that the inductive hypothesis holds for j

We write

⌘h

(Bi \ EBi )

!

j[1

=f

i=0

(Bi \ EBi )

!

1, we want to show that it holds for j as
!

[ (Bj \ EBj ) ,

Sj 2
and apply Lemma D.4 with X = i=0 (Bi \ EBi ), Y = Bj 1 , EY = EBj 1 , Z = Bj , and EZ = EBj . Note that the
conditions (25) and (26) of Lemma D.4 are satisfied by the inductive hypothesis. Hence, we conclude that (43) and (44)
hold with
|EBj |
↵j =
(1 + ↵j 1 ) + ↵j 1 .
|Bj 1 |
It remains to show that (45) holds for ↵j , assuming it holds for ↵j
↵j =


|EBj |
(1 + ↵j
|Bj 1 |
1
⌘h



2

=

2

=
=

2

1+
1
⌘h

+ ↵j

(1 + ⌘h )j

1

⌘hj

1

1+

(1 + ⌘h )j

⌘hj

1

⌘hj

1

+

1

+
⌘hj

+ ⌘h ) j

⌘hj
1

1 (1 + ⌘h )j
⌘h
⌘hj 1

We have

1

(1 + ⌘h )j

⌘hj
2 (1

1)

1.

1

!

⌘hj

1

+

!

(1 + ⌘h )j

1

⌘hj

1

⌘h (1 + ⌘h )j

(1 + ⌘h )j

1

⌘hj

1

(1 + ⌘h )j

1

⌘hj

1

+

⌘hj
⌘hj

1

⌘hj

1

!

!

⌘hj

1

⌘hj

1

(46)
!

(47)

,

where (46) follows from (45) and the fact that
|EBj |

|Bj 1 |
by |EBj |  2j and |Bj

1|

= 2j

1

2j
2j

⌘; and (47) follows since

1⌘

=

2
=
⌘

1
,
⌘h

1. 2

Inequality (45) provides an upper bound on ↵j , but it is not immediately clear how the bound varies with j. The following
lemma provides a more compact form.

Robust Submodular Maximization: A Non-Uniform Partitioning Approach

Lemma D.7 Under the setup of Lemma D.6, we have for 2dlog ⌧ e  ⌘h that
↵j  3

2j

(48)

⌘

Proof. We unfold the right-hand side of (45) in order to express it in a simpler way. First, consider j = 1. From (45) we
obtain ↵1  2 2 ⌘1 , as required. For j 2, we obtain the following:
2

↵j 

⌘hj

(1 + ⌘h )j

⌘hj
j 1✓ ◆ i
X
j ⌘h
=
i ⌘hj
i=0
j 2✓ ◆ i
X
j
j ⌘h
=
+
⌘h i=0 i ⌘hj
!
Qj i
j 2
X
t + 1) ⌘hi
j
t=1 (j
=
+
Qj i
⌘h i=0
⌘hj
t=1 t

(49)
(50)

j 2

j
1 X j i ⌘hi
+
j
⌘h
2 i=0
⌘hj
◆j
j 2✓
j
1X j
=
+
⌘h
2 i=0 ⌘h

(51)



j
1
=
+
⌘h
2

i

j

X
j
+
⌘h i=0

1

✓

j
⌘h

◆j i !

,

Qj i
where (49) is a standard summation identity, and (51) follows from t=1 (j t + 1)  j j
Next, explicitly evaluating the summation of the last equality, we obtain
0
⇣ ⌘j+1 1
j
1
⌘h
j
1B
j
C
2
↵j 
+ @ 1
+
A
j
⌘h
2
⌘h
1 ⌘h
!
j
1
j
1

+
1
+
⌘h
2
⌘h
1 ⌘jh
0 ⇣ ⌘2 1

i

and

Qj

i
t=1

t

2 for j

i

2.

j

j
1 B ⌘h C
=
+ @
A
⌘h
2 1 ⌘j

(52)

h

j
j
=
+
⌘h
2⌘h
where (52) follows from ( a

1)( a + 1) = a2

Next, observe that if j/⌘h  1/2, or equivalently
then we can weaken (53) to
2

which yields (48).
2

↵j 

j
⌘h

1

j
⌘h

!

,

(53)

1 with a = j/⌘h .
2j  ⌘h ,
j
j
3 j
j
+
=
=3 ,
⌘h
2⌘h
2 ⌘h
⌘

(54)
(55)

Robust Submodular Maximization: A Non-Uniform Partitioning Approach

D.3. Completing the Proof of Theorem 4.5
We now prove Theorem 4.5 in several steps. Throughout, we define µ to be a constant such that f (E1 | (S \ E)) = µf (S1 )
holds, and we write E0 := ES⇤ \ S0 , E1 := ES⇤ \ S1 , and EBi := ES⇤ \ Bi , where ES⇤ is defined in (9). We also make use
of the following lemma characterizing the optimal adversary. The proof is straightforward, and can be found in Lemma 2
of (Orlin et al., 2016)
Lemma D.8 (Orlin et al., 2016) Under the setup of Theorem 4.5, we have for all X ⇢ V with |X|  ⌧ that
⇤
f (OPT(k, V, ⌧ ) \ EOPT(k,V,⌧
) )  f (OPT(k

⌧, V \ X)).

Initial lower bounds: We start⇣by providing three lower
bounds on f (S \ ES⇤ ). First, we observe that f (S \ ES⇤ )
⌘
S
dlog ⌧ e
f (S0 \ E0 ) and f (S \ ES⇤ ) f
(Bi \ EBi ) . We also have
i=0
f (S \ E) = f (S)

f (S) + f (S \ E)

= f (S0 [ S1 ) + f (S \ E0 )

f (S \ E0 )

= f (S1 ) + f (S0 | S1 ) + f (S \ E0 )

f (S)

= f (S1 ) + f (S0 | (S \ S0 )) + f (S \ E0 )

(56)

f (S) + f (S \ E)

f (S \ E0 ) + f (S \ E)

f (E0 [ (S \ E0 ))

f (S \ E0 ) + f (S \ E)

= f (S1 ) + f (S0 | (S \ S0 ))

f (E0 | (S \ E0 ))

f (S \ E0 ) + f (S \ E)

= f (S1 ) + f (S0 | (S \ S0 ))

f (E0 | (S \ E0 ))

f (E1 | S \ E)

= f (S1 ) + f (S0 | (S \ S0 ))
= f (S1 )
(1

f (E0 | (S \ E0 ))

f (E1 | S \ E) + f (S0 | (S \ S0 ))

µ)f (S1 ),

f (E1 [ (S \ E)) + f (S \ E)
f (E0 | (S \ E0 ))

(57)
(58)

(59)

where (56) and (57) follow from S = S0 [ S1 , (58) follows from ES⇤ = E0 [ E1 , and (59) follows from f (S0 | (S \ S0 ))
f (E0 | (S \ E0 )) 0 (due to E0 ✓ S0 and S \ S0 ✓ S \ E0 ), along with the definition of µ.
By combining the above three bounds on f (S \ ES⇤ ), we obtain
8
0
19
dlog ⌧ e
<
=
[
f (S \ ES⇤ ) max f (S0 \ E0 ), (1 µ)f (S1 ), f @
(Bi \ EBi )A .
:
;

(60)

i=0

We proceed by further bounding these terms.

Bounding the first term in (60): Defining S00 := OPT(k
we have
f (S0 \ E0 ) + f (OPT(k

⌧, V \ E0 ) \ (S0 \ E0 ) and X := OPT(k

⌧, V \ S0 ))

f (S00 ) + f (X)
f (OPT(k

(61)

⌧, V \ E0 ))

f (OPT(k, V, ⌧ ) \

⌧, V \ E0 ) \ S00 ,

⇤
EOPT(k,V,⌧
) ),

(62)
(63)

where (61) follows from monotonicity, i.e. (S0 \ E0 ) ✓ S00 and (V \ S0 ) ✓ (V \ E0 ), (62) follows from the fact that
OPT(k ⌧, V \ E0 ) = S00 [ X and submodularity,2 and (63) follows from Lemma D.8 and |E0 |  ⌧ . We rewrite (63) as
f (S0 \ E0 )

⇤
f (OPT(k, V, ⌧ ) \ EOPT(k,V,⌧
))

f (OPT(k

⌧, V \ S0 )).

(64)

Bounding the second term in (60): Note that S1 is obtained by using A that satisfies the -iterative property on the set
V \ S0 , and its size is |S1 | = k |S0 |. Hence, from Lemma 4.3 with k ⌧ in place of k, we have
⇣
⌘
k |S0 |
f (S1 )
1 e (k ⌧ ) f (OPT(k ⌧, V \ S0 )).
(65)
2

The submodularity property can equivalently be written as f (A) + f (B)

f (A [ B) + f (A \ B).

Robust Submodular Maximization: A Non-Uniform Partitioning Approach

Bounding the third term in (60): We can view S1 as a large bucket created by our algorithm after creating the buckets
Sdlog ⌧ e 1
in S0 . Therefore, we can apply Lemma D.4 with X = i=0
(Bi \ EBi ), Y = Bdlog ⌧ e , Z = S1 , EY = ES⇤ \ Y ,
and EZ = E1 . Conditions (25) and (26) needed to apply Lemma D.4 are provided by Lemma D.6. From Lemma D.4, we
obtain the following with ↵ as in (42):
0
0
1
1
0
1
✓
◆
dlog ⌧ e
dlog ⌧ e
[
[
|E
|
1
f @E1 @
(Bi \ EBi )A [ (S1 \ E1 )A 
(1 + ↵) + ↵ f @
(Bi \ EBi )A .
(66)
|B
dlog
⌧ e|
i=0
i=0
Furthermore, noting that the assumption ⌘ 4(log k + 1) implies 2dlog ⌧ e  ⌘h , we can upper-bound ↵ as in Lemma D.7
|E1 |
by (48) for j = dlog ⌧ e. Also, we have |Bdlog
 2dlog⌧ ⌧ e ⌘  ⌘ . Putting these together, we upper bound (66) as
⌧e|
follows:
0
0
1
1
0
1
✓ ✓
◆
◆
dlog ⌧ e
dlog ⌧ e
2
2
[
[
3 dlog ⌧ e
3 dlog ⌧ e
f @E 1 @
(Bi \ EBi )A [ (S1 \ E1 )A 
1+
+
f@
(Bi \ EBi )A
⌘
⌘
⌘
i=0
i=0
0
1
dlog ⌧ e
3
[
5 dlog ⌧ e @
(Bi \ EBi )A ,

f
⌘
i=0
where we have used ⌘
0

1 and dlog ⌧ e

dlog ⌧ e

f@

[

i=0

1 (since ⌧

2 by assumption). We rewrite the previous equation as
0
0
1
1
dlog ⌧ e
[
⌘
f @E 1 @
(Bi \ EBi )A [ (S1 \ E1 )A
5 3 dlog ⌧ e
i=0

1

(Bi \ EBi )A

⌘

=

5

3 dlog ⌧ e

5

3 dlog ⌧ e

⌘

f (E1 | (S \ E))

(67)

µf (S1 ),

(68)

where (67) follows from submodularity, and (68) follows from the definition of µ.
Combining the bounds: Returning to (60), we have
8
<
f (S \ ES⇤ ) max f (S0 \ E0 ), (1
:
⇢
max f (S0 \ E0 ), (1

0

µ)f (S1 ), f @

µ)f (S1 ),

5

dlog ⌧ e

[

i=0

⌘

19
=
(Bi \ EBi )A
;

3 dlog ⌧ e

µf (S1 )

⇤
max{f (OPT(k, V, ⌧ ) \ EOPT(k,V,⌧
f (OPT(k ⌧, V \ S0 )),
))
⇣
⌘
k |S0 |
(1 µ) 1 e (k ⌧ ) f (OPT(k ⌧, V \ S0 )),
⇣
⌘
k |S0 |
⌘
(k ⌧ )
µ
1
e
f (OPT(k ⌧, V \ S0 ))}
5 3 dlog ⌧ e
⇤
max{f (OPT(k, V, ⌧ ) \ EOPT(k,V,⌧
f (OPT(k ⌧, V \ S0 )),
))
⌘
⇣
⌘
k |S0 |
5 3 dlog ⌧ e
1 e (k ⌧ ) f (OPT(k ⌧, V \ S0 ))}
⌘
1 + 5 3 dlog ⌧ e

⇤
= max{f (OPT(k, V, ⌧ ) \ EOPT(k,V,⌧
f (OPT(k ⌧, V \ S0 )),
))
⇣
⌘
k |S0 |
⌘
1 e (k ⌧ ) f (OPT(k ⌧, V \ S0 ))}
5 3 dlog ⌧ e + ⌘
⇣
⌘
k |S0 |
⌘
(k ⌧ )
1
e
5 3 dlog ⌧ e+⌘
⇤
⇣
⌘ f (OPT(k, V, ⌧ ) \ EOPT(k,V,⌧
k |S0 |
) ),
⌘
(k
⌧
)
1 + 5 3 dlog ⌧ e+⌘ 1 e

(69)

(70)

(71)

(72)

Robust Submodular Maximization: A Non-Uniform Partitioning Approach

where (69) follows from (68), (70) follows from (64) and (65), (71) follows since max{1
(19), and (72) follows from (20). Hence, we have established (72).

µ, cµ}

c
1+c

analogously to

Turning to the permitted values of ⌧ , we have from Proposition 4.1 that
|S0 |  3⌘⌧ (log k + 2).
For the choice of ⌧ to yield valid set sizes, we only require |S0 |  k; hence, it suffices that
⌧

k
.
3⌘(log k + 2)

Finally, we consider the second claim of the lemma. For ⌧ 2 o
2

log k (which satisfies the assumption ⌘

⌘

k ! 1. Hence, the constant factor converges to
we have
=

1 ✏,
1

(73)
we have |S0 | 2 o(k). Furthermore, by setting

k
⌘(log k)

4(log k + 1) for large k), we get
1 e
2 e

1/
1/

!

1

and

⌘

5

3 dlog ⌧ e+⌘

! 1 as

, yielding (11). In the case that G REEDY is used as the subroutine,

= 1, and hence the constant factor converges t

and hence the constant factor converges to

k |S0 |
(k ⌧ )

1 e✏
2 e✏

1 e
2 e
1
1

1
1

(1

0.387. If T HRESHOLDING -G REEDY is used, we have
✏) 12

e
e

1
1

(1

✏)0.387.

