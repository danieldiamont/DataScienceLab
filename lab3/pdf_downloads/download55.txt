Improving Viterbi is Hard: Better Runtimes Imply Faster Clique Algorithms

A. Hardness of V ITERBI PATH with small alphabet: Proof
Throughout the proof, we set p = d Cε e and α =

C
p

≤ ε.

We will perform a reduction from the M IN -W EIGHT k-C LIQUE problem for k = p + 2 to the V ITERBI PATH problem. In
the instance of the M IN -W EIGHT k-C LIQUE problem, we are given a k-partite graph G = (V1 ∪ V2 ∪ U1 . . . ∪ Up , E) such
that |V1 | = |V2 | = n and |U1 | = . . . = |Up | = m = Θ(nα ). We want to find a clique of minimum weight in the graph G.
Before describing our final V ITERBI PATH instance, we first define a weighted directed graph G0 = ({1, 2, 3}∪V1 ∪V2 , E 0 )
similar to the graph in the proof of Theorem 1. E 0 contains all the edges of G between V1 and V2 , directed from V1 towards
V2 , edges from node 1 towards all nodes in V1 of weight 0 and edges from all nodes in V2 towards node 2 of weight 0. We
also add a self-loop at nodes 1 and 3 of weight 0 as well as an edge of weight 0 from node 2 towards node 3. We obtain the
final graph G00 as follows:
• For every node v ∈ V1 , we replace the directed edge (1, v) with a path 1 → av,1 → ... → av,p → v by adding p
intermediate nodes. All edges on the path have weight 0.
• For every node v ∈ V2 , we replace the directed edge (v, 2) with a path v → bv,1 → ... → bv,p → 2 by adding p
intermediate nodes. All edges on the path have weight 0.
• Finally, we replace the directed edge (2, 3) with a path 2 → c1 → ... → cZ → 3 by adding Z intermediate nodes,
where 2Z is a strict upper bound on the weight of any k-clique6 . All edges on the path have weight 0.
We create an instance of the V ITERBI PATH problem (A, B, S) as described below. Figure 2 illustrates the construction of
the instance.
• Matrix A is the weighted adjacency matrix of G00 that takes value +∞ (or a sufficiently large integer) for non-existent
edges and non-existent self-loops.
• The alphabet of the HMM is U1 ∪ ... ∪ Up ∪ {⊥, ⊥0 , ⊥1 , ⊥F } and thus matrix B has O(n) rows and σ = p · m + 4 =
O(nα ) columns.
For all v ∈ V1 , every i ∈ [p] and every u ∈ Ui , B(av,i , u) is equal to the weight of the edge (v, u) in graph G.
Similarly, for all v ∈ V2 , every j ∈ [p] and every u ∈ Uj , B(bv,j , u) is equal to the weight of the edge (v, u) in graph
G.
Moreover, for all i ∈ {1, ..., Z}, B(ci , ⊥1 ) = 2i−1 and B(ci , ⊥0 ) = 0. Finally, B(v, ⊥) = +∞ for all nodes
v 6∈ {1, 3} while B(v, ⊥F ) = +∞ for all nodes v 6= 3. All remaining entries of matrix B are 0.
• Sequence S is generated by appending for every tuple (u1 , ..., up ) ∈ U1 × ... × Up the following observations in this
order: Initially we add the observations (u1 , ..., up , ⊥0 , ⊥0 , u1 , ..., up , ⊥0 ). Moreover, let W be the total weight of
the clique (u1 , ..., up ) in the graph G. We add Z observations encoding W in binary7 starting with the least significant
bit. For example, if W = 11 and Z = 5, the binary representation is 010112 and the observations we add are
⊥1 , ⊥1 , ⊥0 , ⊥1 , ⊥0 in that order. Finally, we append a ⊥ observation at the end.
Notice, that for each tuple, we append exactly Z + 2p + 4 = Z + 2k observations. Thus, the total number of
observations is mp (Z + 2k). We add a final ⊥F observation at the end and set T = mp (Z + 2k) + 1.
Size of graph G00 Since the edge-weights in the k-Clique conjecture are upper bounded by nO(k) , the length of the path
2 → c1 → ... → cZ → 3 can be upper bounded by Z + 2 ≤ O(k log n). The length of every path 1 → av,1 → ... →
av,p → v or v → bv,1 → ... → bv,p → 2 is p + 2 = k. The number of vertices of G00 can now be upper bounded by
O(k log n + kn) ≤ O(n) since k = O(1).
Correctness of the reduction Since the M IN -W EIGHT k-C LIQUE instance requires
Qp
1−o(1)
Ω (|V1 | · |V2 | · i=1 |Ui |)
= Ω(T n2 )1−o(1) time, the following claim implies that the above V ITERBI PATH in2 1−o(1)
stances require Ω(T n )
time. The alphabet size used is at most O(nα ) and α ≤ ε and the theorem follows.
6
7

A trivial such upper bound is k2 times the weight of the maximum edge.
Since 2Z is a strict upper-bound on the clique size at most Z digits are required.

Improving Viterbi is Hard: Better Runtimes Imply Faster Clique Algorithms

V1

V2
wv1 ,v2

nodes av,i

0
1

0
0

0

0

0

0

nodes bv,i

0

0

0

0

0

0
2

0

0

0

0

0

0

Node
1
av,i for v ∈ V1
v ∈ V1 ∪ V2
bv,i for v ∈ V2
2
ci
3

0

c1

c2

cZ

3

0

0

u ∈ Uj
0
wu,v 1i=j
0
wu,v 1i=j
0
0
0

⊥0
0
0
0
0
0
0
0

⊥1
0
0
0
0
0
2i−1
0

⊥
0
∞
∞
∞
∞
∞
0

⊥F
∞
∞
∞
∞
∞
∞
0

Figure 2: The construction of matrices A and B for the reduction in the proof of Theorem 2.
Claim 2. The weight of the solution to the V ITERBI PATH instance is equal to the minimum weight of a k-clique in the
graph G.
Proof. The optimal path for the V ITERBI PATH instance begins at node 1. It must end in node 3 since otherwise when
observation ⊥F arrives we collect cost +∞. Similarly, whenever an observation ⊥ arrives the path must be either on node
1 or 3. Thus, the path first loops in node 1 and then goes from node 1 to node 3 during the sequence of Z + 2k consecutive
observations corresponding to some tuple (u1 , ..., up ) ∈ U1 × ... × Up and stays in node 3 until the end. Let v1 and v2 be
the nodes in V1 and V2 , respectively, that are visited when moving from node 1 to node 3. The only steps of non-zero cost
happen during the subsequence of observations corresponding to the tuple (u1 , ..., up ):
1. When the subsequence begins with u1 , the path jumps to node av1 ,1 which has a cost B(av1 ,1 , u1 ) equal to the edgeweight (v1 , u1 ) in graph G.
PpIt then continues on to nodes av1 ,2 , ..., av1 ,p when seeing observations u2 , ..., up . The
total cost of these steps is i=1 B(av1 ,i , ui ) which is the total weight of edges (v1 , u1 ), ..., (v1 , up ) in graph G.
2. For the next two observations ⊥0 , ⊥0 , the path jumps to nodes v1 and v2 . The first jump has no cost while the latter
has cost A(v1 , v2 ) equal to the weight of the edge (v1 , v2 ) in G.
3. The subsequence
continues with observations u1 , ..., up and the path jumps to nodes bv2 ,1 , ..., bv2 ,p which has a total
Pp
cost i=1 B(bv2 ,i , ui ) which is equal to the total weight of edges (v2 , u1 ), ..., (v2 , up ) in graph G.
4. The path then jumps to node 2 at no cost at observation ⊥0 .
5. The path then moves on to the nodes c1 , ..., cZ . The total cost of those moves is equal to the total weight of the clique
(u1 , ..., up ) since the observations ⊥0 and ⊥1 that follow encode that weight in binary.
The overall cost of the path is exactly equal to the weight of the k-clique (v1 , v2 , u1 , ..., up ) in G. Minimizing the cost of
the path in this instance is therefore the same as finding the minimum weight k-clique in G.

B. Reduction from M IN -W EIGHT k-C LIQUE to M IN -W EIGHT k-C LIQUE in k-partite graphs
In this section, we show the following lemma using standard techniques.

Improving Viterbi is Hard: Better Runtimes Imply Faster Clique Algorithms

Lemma 1. Consider the M IN -W EIGHT k-C LIQUE problem in k-partite graphs G = (V1 ∪ . . . ∪ Vk , E) with |Vi | = ni .
Θ(1)
If for all i, j we have that ni = nj , then the M IN -W EIGHT k-C LIQUE problem for this class of instances requires
Q
1−o(1)
k
Ω
time assuming the k-Clique conjecture.
i=1 ni
Q
1−ε
Proof. Without loss of generality assume that n1 ≥ ni for all i and let n = n1 . Assume, that there is an O ( i ni )
algorithm that finds a minimum weight k-clique in k-partite graphs with |Vi | = ni for all i. We can use this faster algorithm
to find a k-clique in a graph G = (V, E) where |V | = n, as follows: Let V i be a partition of V into nni sets of size ni . For
all (V1 , . . . , Vk ) ∈ V 1 × · · · × V k , we create a k-partite graph G0 = (V1 ∪ . . . ∪ Vk , E 0 ) by adding edges corresponding
to the edges of graph G between nodes across partitions and find the minimum weight k-clique in the graph G0 using
the faster algorithm. Computing the minimum weight k-clique out of all the graphs we consider gives the solution to the
Q
1−ε
Qk
k
n
M IN -W EIGHT k-C LIQUE instance on G. The total runtime is i=1 nni · O
= nk−Ω(ε) which would violate
i=1 i
Θ(1)

the k-Clique conjecture. The previous equality holds because of the assumption that ni = nj

.

C. Sum of Probabilities
In the definition of the additive version of V ITERBI PATH, we didn’t impose any constraint on the weights. In the multiplicative version where weights correspond to probabilities, we have the restriction that probabilities of transition from
each vertex sum to 1.
To convert an instance IAdd of the additive V ITERBI PATH formulation to an equivalent instance IM ul in the multiplicative
setting, we add a shift of log n to all entries of A and a shift of log T to entries of matrix B. This doesn’t change the optimal
solution but only changes its value by an additive shift of T log n + T log T . This transformation makes all probabilities
in the IM ul instance small enough such that transition probabilities sum to less than 1 and similarly probabilities of
outputting observations sum to less than 1. To handle the remaining probability, we introduce an additional node α and
an additional symbol γ in the alphabet of observations. Every original transitions to node α with its remaining transition
probability and outputs observation γ with its remaining transition probability. We require that node α outputs observation
γ with 100% probability. As we never observe γ in the sequence of observations, the optimal solution must never go
through node α and thus the optimal solution remains the same.
The transformation above requires introducing an additional symbol in the alphabet.
For our reduction of
A LL -PAIRS S HORTEST PATHS to V ITERBI PATH when σ = 1, we don’t want the alphabet to increase. We describe
an alternative transformation for σ = 1 that doesn’t introduce additional symbols. This case corresponds to the
S HORTEST WALK instance and matrix B is irrelevant.
We first scale all weights in matrices A, by dividing by some large weight W , so that all values are between 0 and 1 and then
add a shift of log n to all of them. This doesn’t change the optimal solution but only changes its value by a multiplicative
factor W and an additive shift of T log n. After this transformation all values are between log n and 1 + log n and thus the
corresponding probabilities in the IM ul instance are at most 1/n. This causes transition probabilities to sum to less than 1.
To assign the remaining probability, we introduce a clique of 4n additional nodes. All nodes in the clique have probability
1
4n of transition to any other node in the clique and 0 probability of transition to any of the original node. For every original
node, we spread its remaining transition probability evenly to the 4n nodes of the clique. It is easy to see that the optimal
solution to the V ITERBI PATH problem will not change, as it is never optimal to visit any of the nodes in the clique. This is
because all edges in the original graph have weight at most 1 + log n while if a node in the clique is visited the path must
stay in the clique at a cost of 2 + log n per edge.

