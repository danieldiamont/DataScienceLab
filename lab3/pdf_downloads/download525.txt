Adapting Kernel Representations Online Using Submodular Maximization

Matthew Schlegel 1 Yangchen Pan 1 Jiecao Chen 1 Martha White 1

Abstract
Kernel representations provide a nonlinear representation, through similarities to prototypes, but
require only simple linear learning algorithms
given those prototypes. In a continual learning
setting, with a constant stream of observations,
it is critical to have an efficient mechanism for
sub-selecting prototypes amongst observations.
In this work, we develop an approximately submodular criterion for this setting, and an efficient online greedy submodular maximization algorithm for optimizing the criterion. We extend
streaming submodular maximization algorithms
to continual learning, by removing the need for
multiple passes—which is infeasible—and instead introducing the idea of coverage time. We
propose a general block-diagonal approximation
for the greedy update with our criterion, that enables updates linear in the number of prototypes.
We empirically demonstrate the effectiveness of
this approximation, in terms of approximation
quality, significant runtime improvements, and
effective prediction performance.

1. Introduction
Kernel representations provide an attractive approach to
representation learning, by facilitating simple linear prediction algorithms and providing an interpretable representation. A kernel representation consists of mapping an input observation into similarity features, with similarities to
a set of prototypes. Consequently, for an input observation, a prediction can be attributed to those prototypes that
are most similar to the observation. Further, the transformation to similarity features is non-linear, enabling nonlinear function approximation while using linear learning
algorithms that simply optimize for weights on these transformed features. Kernel representations are universal func1

Department of Computer Science, Indiana University, Bloomington. Correspondence to: Martha White
<martha@indiana.edu>.
Proceedings of the 34 th International Conference on Machine
Learning, Sydney, Australia, PMLR 70, 2017. Copyright 2017 by
the author(s).

tion approximators1 and the flexibility in choosing the kernel (similarity function) has enabled impressive prediction performance for a range of settings, including speech
(Huang et al., 2014), computer vision (Mairal et al., 2014),
and object recognition (Lu et al., 2014).
In a continual learning setting, such as in online learning or
reinforcement learning, there is a constant, effectively unending stream of data, necessitating some care when using
kernel representations. The issue arises from the choice of
prototypes. Before the advent of huge increases in dataset
sizes, a common choice was to use all of the training data
as prototypes. This choice comes from the representer theorem, which states that for a broad class of functions, the
empirical risk minimizer is a linear weighting of similarity
features, to a set of prototypes that consists of the training
data. For continual learning, however, the update should be
independent of the the total number of samples— which is
not clearly defined for continual learning. Conversely, we
want to permit selection of a sufficiently large number of
prototypes, to maintain sufficient modeling power. For efficient, continual updating, therefore, we require per-step
prototype selection strategies that are approximately linear
in the number of prototypes.
Currently, most algorithms do not satisfy the criteria for a
continual learning setting. Incremental selection of prototypes has been tackled in a wide range of areas, due to the
fundamental nature of this problem. Within the streaming
community, approaches typically assume that the batch of
data, though large, is accessible and fixed. The most related of these areas2 include active set selection for Gaussian process regression (Seeger et al., 2003), with streaming submodular maximization approaches (Krause et al.,
2008b;a; Badanidiyuru et al., 2014); incremental Nystrom methods within kernel recursive least-squares (KRLS)
1

Radial basis function networks are an example of a kernel
representation, that have been shown to be universal function approximators (Park & Sandberg, 1991). Further, the representer
theorem further characterizes the approximation capabilities under empirical risk minimization for a broad class of functions.
2
Facility location, k-medians and k-centers are three problems
that focus on selecting representative instances from a set (c.f.
(Guha et al., 2003)). The criteria and algorithms are not designed
with the intention to use the instances for prediction and so we do
not consider them further here.

Adapting Kernel Representations Online Using Submodular Maximization

(Rudi et al., 2015)3 ; and functional gradients that sample
random bases which avoid storing prototypes but require
storing n scalars, for n training samples (Dai et al., 2014).
Kernel representation algorithms designed specifically for
the online setting, on the other hand, are typically too
computationally expensive in terms of the number of prototypes. Kernel least-mean squares (KLMS) algorithms
use stochastic updates, maintaining the most recent prototypes and truncating coefficients on the oldest (Kivinen
et al., 2010; Schraudolph et al., 2006; Cheng et al., 2007);
though efficient given sufficient truncation, this truncation
can introduce significant errors (Van Vaerenbergh & Santamaria, 2013). Random feature approximations (Rahimi &
Recht, 2007) can be used online, but require a significant
number of random features. Gaussian process regression
approaches have online variants (Csató & Opper, 2006;
Cheng & Boots, 2016), however, they inherently require
at least quadratic computation to update the variance parameters. KRLS can be applied online, but has a threshold parameter that makes it difficult to control the number of prototypes and requires quadratic computation and
space (Engel et al., 2004). More efficient coherence heuristic have been proposed (Richard et al., 2009; Van Vaerenbergh et al., 2010; Chen et al., 2013; Van Vaerenbergh &
Santamaria, 2013), but provide no approximation quality
guarantees.
In this work, we provide a simple and efficient greedy algorithm for selecting prototypes for continual learning, by
extending recent work in prototype selection with submodular maximization. We introduce a generalized coherence
criterion for selecting prototypes, which unifies two previously proposed criteria: the coherence criterion and the log
determinant. Because this criterion is (approximately) submodular, we pursue a generalization to streaming submodular maximization algorithms. We avoid the need for multiple passes over the data—which is not possible in continual
learning— by introducing the idea of coverage time, which
reflects that areas of the observation space are repeatedly
visited under sufficient mixing. We prove that our online
submodular maximization achieves an approximation-ratio
of 1/2, with a small additional approximation introduced
due to coverage time and from using an estimate of the submodular function. We then provide a linear-time algorithm
for approximating one instance of our submodular criterion, by exploiting the block-diagonal form of the kernel
matrix. We empirically demonstrate that this approximation closely matches the true value, despite using significantly less computation, and show effective prediction performance using the corresponding kernel representation.
3
There is a large literature on fast Nystrom methods using related approaches, such as determinant point processes for sampling landmark points (Li et al., 2016). The primary goal for these
methods, however, is to approximate the full kernel matrix.

2. Using kernel representations
A kernel representation is a transformation of observations
into similarity features, consisting of similarities to prototypes. A canonical example of such a representation is a radial basis function network, with radial basis kernels such
as the Gaussian kernel; however, more generally any kernel
similarity can be chosen. More formally, for observations
x ∈ X , the kernel representation consists of similarities to
a set of prototypes S = {z1 , . . . , zb } ⊂ X
x → [k(x, z1 ), . . . , k(x, zb )] ∈ Rb .
for kernel k : X × X → R. The observations need not be
numerical; as long as a similarity k can be defined between
two observations, kernel representations can be used and
conveniently provide a numeric feature vector in Rb . We
use the term prototype, instead of center, to emphasize that
the chosen observations are representative instances, that
are sub-selected from observed data.
A fundamental result for kernel representations is the representer theorem, with significant recent generalizations (Argyriou & Dinuzzo, 2014), which states that for a broad
class of function spaces H, the empirical risk minimizer
f ∈ H on a training set {(xi , yi }ni=1 has the simple form
f (·) =

n
X

αi k(·, xi ).

i=1

This result makes use of a key property: the kernel function can be expressed as an inner product, k(xi , xj ) =
hφ(xi ), φ(xj )i for some implicit
expansion φ. The funcPn
tion f can be written f = i=1 αi φ(xj ), with
f (x) = hφ(x),

n
X
i=1

αi φ(xj )i =

n
X

αi hφ(x), φ(xj )i.

i=1

It is typically impractical to use all xi as prototypes, and
a subset needs to be chosen. Recently, there has been several papers (Krause et al., 2008b;a; Krause & Gomes, 2010;
Badanidiyuru et al., 2014) showing that prototypes can be
effectively selected in the streaming setting using greedy
submodular maximization on the log-determinant of the
kernel matrix, KS ∈ Rb×b where (KS )ij = k(zi , zj ).
Given some ground set Ω and its powerset P(Ω), submodular functions g : P(Ω) → R are set functions, with a
diminishing returns property: the addition of a point to a
given set increases the value less or equal than adding a
point to a subset of that set. For prototype selection, the
ground set considered are sets of all observations X , so
S ⊂ Ω = X . The log-determinant of the resulting kernel
matrix, log det KS , is a submodular function of S. Though
maximizing submodular functions is NP-hard, greedy approximation algorithms have been shown to obtain reasonable approximation ratios, even for the streaming setting

Adapting Kernel Representations Online Using Submodular Maximization

(Krause & Gomes, 2010; Badanidiyuru et al., 2014), and
the resulting algorithms are elegantly simple and theoretically sound.
In the following sections, we derive a novel criterion for
prototype selection, that includes the log-determinant as a
special case. Then, we provide an efficient prototype selection algorithm for the continual learning setting, using
submodular maximization.

3. Selecting kernel prototypes
Many prototype selection strategies are derived based on
diversity measures. The coherence criterion (Engel et al.,
2004) approximates how effectively the set of prototypes
spans the set of given observations. The log-determinant
measures the spread of eigenvalues for the kernel matrix,
and is related to information gain (Seeger, 2004). These
selection criteria are designed for a finite set of observed
points; here, we step back and reconsider a suitable objective for prototype selection for continual learning.
Our goal is to select prototypes that minimize distance to
the optimal function. In this section, we begin from this
objective and demonstrate that the coherence criterion and
log-determinant are actually upper bounds on this objective, and special cases of a more general such upper bound.
The analysis justifies that the log-determinant is a more
suitable criteria for continual learning, which we then pursue in the remainder of this work.

.
For ki = [k(xi , z1 ), . . . , k(xi , zb )], the interior minimization can be re-written as
2



b
X


(i)

βj φ(zj )
min αi φ(xi ) −

β (i) 

j=1
>

>

= min β (i) KS β − 2αi β (i) ki + αi2 k(xi , xi )
β

To provide more stable approximations, we regularize
2



b
n
X
X


(i)
(i) 2

(2) ≤ min
βj φ(zj )
min αi φ(xi )−
 +λkβ k2
(i)
S⊂X
β


j=1
i=1
= min
S⊂X

n
X
i=1

>

>

min β (i) (KS + λI)β − 2αi β (i) ki
β (i)

+ αi2 k(xi , xi ).
For λ = 0, the inequality is equality. Otherwise adding regularization theoretically increases the upper bound, though
in practice will be key for stability.
Solving gives β (i) = αi (KS + λI)−1 ki , and so
>

>

β (i) (KS + λI)β − 2αi β (i) ki + αi2 k(xi , xi )
= αi2 ki (KS + λI) ki − 2αi2 ki (KS + λI) ki
>

−1

>

−1

+ αi2 k(xi , xi )
= αi2 k(xi , xi ) − αi2 ki (KS + λI) ki
>

−1

We can now simplify the above upper bound
3.1. Criteria to select prototypes from a finite set
Let X = {x1 , . . . , xn } be a set of points, with corresponding labels y1 , . . . , yn . We will not assume that this
is a batch of data, but could rather consist of all possible observations for a finite observation space. Ideally, we
would learn S = {z1 , . . . , zb } ⊂ X and corresponding
Pb
fS,β (·) = i=1 βj k(·, xi ) according to the loss
2

min min kf − fS,β k
(1)



X
b
X
 n


wherekf − fS,β k = 
αi φ(xi ) −
βj φ(zj )

 i=1

j=1
S⊂X β∈Rb

for the optimal f for the set of points X . Because we do not
have f , we derive an upper bound on this value. Introducing
Pn
(i)
(i)
dummy variables βj ∈ R such that βj = i=1 βj ,

2

n 
b
X
X


(i)

(1) ≤ min
αi φ(xi ) −
βj φ(zj )


b
S⊂X ,β∈R

i=1 
j=1

2


n
b
X
X


(i)
 (2)
= min
min 
α
φ(x
)
−
β
φ(z
)
i
i
j 
j

(i)
(i)
S⊂X

i=1 β1 ,...,βb 
j=1

(2) ≤ min
S⊂X

n
X

αi2 k(xi , xi ) − αi2 ki (KS + λI) ki
>

−1



i=1

and obtain equivalent optimization
argmax
S⊂X

n
X

αi2 ki (KS + λI) ki .
>

−1

i=1

This criteria closely resembles the coherence criterion (Engel et al., 2004). The key idea for the coherence criterion is to add a prototype xi , to kernel matrix KS if
1 − ki K−1
S ki ≤ ν for some threshold parameter ν. The
coherence criterion,
argmax
S⊂X

n
X

>

−1

ki (KS + λI) ki

i=1

therefore, can be seen as an upper bound on the
distance the optimal
rePn function, with further
−1
laxation because P i=1 αi2 k>
≤
i (KS + λI) ki
n
−1
max{α12 , . . . , αn2 } i=1 k>
i (KS + λI) ki .
The relationship to another popular criterion—the log
determinant— arises when we consider the extension to an
infinite state space.

Adapting Kernel Representations Online Using Submodular Maximization

3.2. Criteria to select prototypes from an infinite set
The criterion above can be extended to an uncountably infinite Robservation space X . For this setting, the optimal
f = X ω(x)φ(x)dx, for a function ω : Rd → R. Let
k(x, S) = [k(x, z1 ), . . . , k(x, zb )] Then, using a similar
analysis to above,
Z
min min kf − fS,β k2 ≤ min
ω(x)2 k(x, x)dx
S⊂X β∈Rb
S⊂X X
Z
>
−1
−
ω(x)2 k(x, S) (KS + λI) k(x, S)dx.
X

and so the resulting goal is to optimize
Z
>
−1
argmax
ω(x)2 k(x, S) (KS + λI) k(x, S)dx. (3)
S⊂X

X

This provides a nice relation to the log determinant criterion, with normalized kernels4 : k(z, z) = 1. If k(x, S)
maps to a unique kernel vector k ∈ [0, 1]b , and the function
k(·, S) also maps onto [0, 1]b , then for ω(x) = 1,
Z
>
−1
ω(x)2 k(x, S) (KS + λI) k(x, S)dx
X
Z
>
−1
= k (KS + λI) k dk
= det(KS + λI).
In general, it is unlikely to have a bijection k(·, S). More
generally, we can obtain the above criterion by setting the
coefficient function ω so that each possible kernel vector
k ∈ Rb has uniform weighting, or implicitly so the integration is uniformly over k ∈ [0, 1]b . Because log is monotonically increasing, maximizing det(KS + λI) with a fixed b
is equivalent to maximizing log det(KS + λI).
This derivation of an upper bound on the distance to the optimal function provides new insights into the properties of
the log-determinant, clarifies the connection between the
coherence criterion and the log-determinant, and suggesting potential routes for providing criteria based on the prediction utility of a prototype. The choice of weighting ω to
obtain the log-determinant removes all information about
the utility of a prototype and essentially assumes a uniform distribution over the kernel vectors k. For more general coefficient functions ω, let µ(S) = E[k(X, S)] and
Σ(S) = Cov(k(X, S)), where the expectations
R are according to density ω 2 /c for normalizer c = X ω(x)dx.
By the quadratic expectations properties (Brookes, 2004)
−1

(3) = argmax tr((KS + λI) Σ(S))
S⊂X
>

−1

+ µ(S) (KS + λI) µ(S).

(4)

p
4
A kernel can be normalized by k(x, z)/ k(z, z)k(x, x).

This more general form in (4) enables prototypes to be
more highly weighted based on the magnitude of values
in ω. We focus in this work first on online prototype selection for the popular log-determinant, and leave further
investigation into this more general criteria to future work.
We nonetheless introduce the form here to better motivate
the log-determinant, as well as demonstrate that the above
analysis is amenable to a host of potential directions for
more directed prototype selection.

4. Online submodular maximization
In this section, we introduce an OnlineGreedy algorithm
for submodular maximization, to enable optimization of the
prototype selection objective from an online stream of data.
Current submodular maximization algorithms are designed
for the streaming setting, which deals with incrementally
processing large but fixed datasets. Consequently, the objectives are specified for a finite batch of observations and
the algorithms can do multiple passes over the dataset. For
the online setting, both of these conditions are restrictive.
We show that, with a minor modification to StreamGreedy
(Krause & Gomes, 2010), we can obtain a comparable approximation guarantee that applies to the online setting.
We would like to note that there is one streaming algorithm,
called Sieve Streaming, designed to only do one pass of the
data and avoid too many calls to the submodular function
(Badanidiyuru et al., 2014); however, it requires keeping
parallel solutions, which introduces significant complexity
and which we found prohibitively expensive. In our experiments, we show it is significantly slower than our approach
and found it typically maintained at least 500 parallel solutions. For this reason, we opt to extend the simpler StreamGreedy algorithm, and focus on efficient estimates of the
submodular function, since we will require more calls to
this function than Sieve Streaming.
Our goal is to solve the submodular maximization problem
max
S⊂X :|S|≤b

g(S)

(5)

where X is a general space of observations and g is a submodular function. The key modification is to enable X to be
a large, infinite or even uncountable space. For such X , we
will be unable to see all observations, let alone make multiple passes. Instead, we will use a related notion to mixing
time, where we see a cover of the space.
The greedy algorithm consists of greedily adding in a new
prototype if it is an improvement on a previous prototype.
The resulting greedy algorithm—given in Algorithm 1— is
similar to StreamGreedy, and so we term it OnlineGreedy.
The algorithm queries the submodular function on each
set, with a previous prototype removed and the new observation added. To make this efficient, we will rely on us-

Adapting Kernel Representations Online Using Submodular Maximization

Algorithm 1 OnlineGreedy
Input: threshold parameter t , where a prototype is only
added if there is sufficient improvement
S0 ← ∅
for t = 1 : b do St ← St−1 ∪ {xt }
while interacting, t = b + 1, . . . do
z0 = argmax ĝ(St−1 \{z} ∪ {xt })
z∈St−1

St ← St−1 \{z0 } ∪ {xt }
if ĝ(St ) − ĝ(St−1 ) < t then
St ← St−1
ing only an approximation to the submodular function g.
We will provide a linear-time algorithm—in the number of
prototypes— for querying replacement to all prototypes, as
opposed to a naive solution which would be cubic in the
number of prototypes. This will enable us to use this simple
greedy approach, rather than more complex streaming submodular maximization approaches that attempt to reduce
the number of calls to the submodular function.
We bound approximation error, relative to the optimal solution. We extend an algorithm that uses multiple passes;
our approach suggests more generally how algorithms from
the streaming setting can be extended to an online setting.
To focus the on this extension, we only consider submodular functions here; in Appendix B, we generalize the result
to approximately submodular functions. Many set functions are approximately submodular, rather than submodular, but still enjoy similar approximation properties. The
log-determinant is submodular, however, it is more likely
that, for the variety of choices for ω, the generalized coherence criterion is only approximately submodular. For
this reason, we provide this generalization to approximate
submodularity, as it further justifies the design of (approximately) submodular criteria for prototype selection.
We compare our solution to the optimal solution
S ∗ = argmax g(S) = {z∗1 , . . . , z∗b }.

This final assumption characterizes that the environment is
sufficiently mixing, to see a cover of the space. We introduce the term coverage, instead of cover time for finitestate, to indicate a relaxed notion of observing a covering
of the space rather than observing all states.
For simplicity of the proof, we characterize the coverage
time in terms of the submodular function. We show that the
submodular function we consider—the log-determinant—
satisfies this assumption, given a more intuitive assumption
that instead requires that observations be similar according
to the kernel. The statement and proof are in Appendix A.
Now we prove our main result.
Theorem 1. Assume Assumptions 1-3 and that g(S ∗ ) is
finite and g(∅) ≥ 0. Then, for t > ρg(S ∗ )/t , all sets St
chosen by OnlineGreedy using ĝ satisfy, with probability
1 − δ,
g(St ) ≥

b
1
g(S ∗ ) − (r + 2f + t )
2
2

Proof: The proof follows closely to the proof of Krause
& Gomes (2010, Theorem 4). The key difference is that
we cannot do multiple passes through a fixed dataset, and
instead use submodular coverage time.
Case 1: There have been t ≥ ρg(S ∗ )/t iterations, and St
has always changed within ρ iterations (i.e., there has never
been ρ consecutive iterations where St remained the same).
This mean that for each ρ iterations, ĝ(St ) must have been
improved by at least t , which is the minimum threshold for
improvement. This means that over the t iterations, ĝ(S0 )
has improved by at least t each ρ,
ĝ(S0 ) + t t/ρ ≥ t t/ρ = ĝ(S ∗ ) ≥ g(S ∗ ) − f
The solution is within f of g(S ∗ ), and we are done.
Case 2: At some time t, St was not changed for ρ iterations,
i.e., St−ρ = St−ρ−1 = . . . St . Order the prototypes in the
set as zi = argmaxz∈St g({z1 , . . . , zi−1 } ∪ {z}), with

S⊂X :|S|≤b

Assumption 1 (Submodularity). g is monotone increasing
and submodular.
Assumption 2 (Approximation error). We have access to
a set function ĝ that approximates g: for some f ≥ 0 for
all S ⊂ X , with |S| ≤ b,
|ĝ(S) − g(S)| ≤ f

δi = g({z1 , . . . , zi }) − g({z1 , . . . , zi−1 }).
By Lemma 3, δi−1 ≥ δi .
Because the point that was observed ri that was closest to
z∗i was not added to S, we have the following inequalities
|ĝ(S ∪ {ri }) − g(S ∪ {ri })| ≤ f
ĝ(S ∪ {ri }) − ĝ(S ∪ {zb }) ≤ t
|g(S ∪ {ri }) − g(S ∪ {z∗i })| ≤ r

Assumption 3 (Submodular coverage time). For a fixed
r > 0 and δ > 0 there exists a ρ ∈ N such that for all S ⊂
X where |S| ≤ b, with probability 1 − δ, for any z∗ ∈ S ∗
an observation x is observed within ρ steps (starting from
any point in X ) that is similar to z∗ in that

where the last inequality is true for all z∗i with probability
1 − δ. Using these inequalities, as shown more explicitly in
the proof in the appendix, we get

|g(S ∪ {x}) − g(S ∪ {z∗ })| ≤ r .

g(S ∪ {z∗i }) − g(S) ≤ δb + r + 2f + t

Adapting Kernel Representations Online Using Submodular Maximization

Algorithm 2 BlockGreedy: OnlineGreedy for Prototype
Selection using a Block-Diagonal Approximation
r = block-size, with set of blocks B, S0 ← ∅
c, l book-keeping maps, with (c(B), l(B)) = (z, l) for z
leading to smallest utility loss l if removed from block B.
ge ← 0 is the incremental estimate of log-determinant
for t = 1 : b do, St ← St−1 ∪ {xt }
while interacting, t = b + 1, . . . do
if added b new prototypes since last clustering then
cluster St into bb/rc blocks with k-means,
initialize with previous clustering; update c, l, ge
BlockGreedy-Swap(xt )

By the definition of submodularity, g(S ∪ S ∗ ) − g(S) ≤
Pb
∗
i=1 g(S ∪ {zi }) − g(S)).
Putting this all together, with probability 1 − δ,
∗

∗

g(S ) ≤ g(S ∪ S )
≤ g(S) +

b
X

g(S ∪ {z∗i }) − g(S))

i=1
b
X
(δb + r + 2f + t )
≤ g(S) +
i=1

≤ g(S) +

b
X

!
δi

+ b(r + 2f + t )

i=1

= g(S) +

b
X

g({s1 , . . . , zi }) − g({z1 , . . . , zi−1 })

i=1

+ b(r + 2f + t )
≤ g(S) + g({z1 , . . . , zb }) + b(r + 2f + t )
≤ 2g(St ) + b(r + 2f + t )
where the last inequality uses g(S) ≤ g(St ) which follows
from monotonicity.


5. Block-diagonal approximation for efficient
computation of the submodular function
The computation of the submodular function g is the critical bottleneck in OnlineGreedy and other incremental submodular maximization techniques. In this section, we propose a time and memory efficient greedy approach to computing a submodular function on KS , enabling each step
of OnlineGreedy to cost O(db), where d is the feature dimension and b is the budget size. The key insight is to take
advantage of the block-diagonal structure of the kernel matrix, particularly due to the fact that the greedy algorithm
intentionally selects diverse prototypes. Consequently, we
can approximately cluster prototypes into small groups of

Algorithm 3 BlockGreedy-Swap(x)
B1 ← get-block(x)
. returns the nearest block to x
(z1 , g1 ) ← argmax g(B1 \{z} ∪ {x}) − g(B1 )
z∈B1
e
if ge 6= 0 and g1g−g
< t then
e
return with no update if low percentage improvement
(B2 , g2 ) ← argmax g(B1 ∪ {x}) − l(B)

B∈B\B1

if g1 < g2 then
. remove point from same block
B1 ← B1 \{z1 } ∪ {x}
update c(B1 )
. using Appendix E.3
ge ← ge + g1
else
. remove point from a different block
B1 ← B1 ∪ {x}
B2 ← B2 \ {c(B2 )}
update c(B1 ), c(B2 )
. using Appendix E.3
ge ← ge + g2
size r, and perform updates on only these blocks.
Approximations to the kernel matrix have been extensively
explored, but towards the aim of highly accurate approximations for use within prediction. These methods include
low-rank approximations (Bach & Jordan, 2005), Nystrom
methods (Drineas & Mahoney, 2005; Gittens & Mahoney,
2013) and a block-diagonal method for dense kernel matrices, focused on storage efficiency (Si et al., 2014). Because
these approximations are used for prediction and because
they are designed for a fixed batch of data and so do not
take advantage of incrementally updating values, they are
not sufficiently efficient for use on each step, and require at
least O(b2 ) computation. For OnlineGreedy, however, we
only need a more coarse approximation to KS to enable
effective prototype selection. By taking advantage of this
fact, saving computation with incremental updating and using the fact that our kernel matrix is not dense—making it
likely that many off-diagonal elements are near zero— we
can reduce storage and computation to linear in b.
The key steps in the algorithm are to maintain a clustering
of prototypes, compute all pairwise swaps between prototypes within a block—which is much more efficient than
pairwise swaps between all prototypes— and finally perform a single swap between two blocks. The computational
complexity of Algorithm 2 on each step is O(bd + r3 )
for block size r (see Appendix F for an in-depth explanation). We assume that, with a block-diagonal KS with
blocks
B, the submodular function separates into g(S) =
P
B∈B g(B). For both the log-determinant and the trace
of the inverse of KS , this is the case because the inverse of a block-diagonal matrix corresponds to a blockdiagonal matrix P
of the inverses of these blocks. Therefore,
log det(KS ) = B∈B log det(KB ).
We use this property to avoid all pairwise comparisons. If x
is added to S, it gets clustered into its nearest block, based

Adapting Kernel Representations Online Using Submodular Maximization

120

BlockGreedy Estimation
FullGreedy

100

1

SieveStreaming

Block Greedy with
only local replacement

1200

0.8

1000

BlockGreedy

80

Log
Determinant
60

1400

Block Greedy

Block Greedy without clustering

Percentage
0.6
Accuracy

BlockGreedy without clustering

Random

400
0.2

20
0
500

1000

1500

2000

2500

Samples Processed

(a) log det of K

3000

3500

FullGreedy

600

0.4
40

800
Time
(seconds)

SieveStreaming
BlockGreedy

200
0

0
0

20

40

60

Block Size

80

100

(b) Estimate Accuracy, with b = 200

100

200

300

400

500

600

Budget Size

(c) Runtime with increasing b

Figure 1. Performance of BlockGreedy in Telemonitoring. Figure (a) shows the true log determinant of K for the prototypes selected
by each algorithm. Our algorithm, BlockGreedy, achieves almost the same performance as FullGreedy, which uses no approximation to
K to compute the log-determinant. Figure (b) shows the accuracy of the log determinant estimate as the block size increases. We can
see that clustering is key, and that for smaller block sizes, comparing between blocks is key. Figure (c) shows the runtime of the main
prototype selection competitors, FullGreedy and SieveStreaming, versus BlockGreedy with block size r = 10.

on distance to the mean of that cluster. To compute the
log-determinant for the new S, we simply need to recompute the log-determinant for the modified block, as the logdeterminant for the remaining blocks is unchanged. Therefore, if KS really is block-diagonal, computing all pairwise
swaps with x is equivalent to first computing the least useful point z in the closest cluster to x, and then determining
if g(S ∪ {x}) would be least reduced by removing z or
removing the least useful prototype from another cluster.
With some book-keeping, we maintain the least-useful prototype for each cluster, to avoid recomputing it each step.

6. Experiments
We empirically illustrate the accuracy and efficiency of our
proposed method as compared to OnlineGreedy with no
approximation to the submodular function (which we call
Full Greedy), Sieve Streaming, and various naive versions
of our algorithm. We also show this method can achieve
reasonable regression accuracy as compared with KRLS
(Engel et al., 2004). For these experiments we use four
well known datasets: Boston Housing (Lichman, 2015),
Parkinson’s Telemonitoring (Tsanas et al., 2010), Sante Fe
A (Weigend, 1994) and Census 1990 (Lichman, 2015). Further details about each dataset are in Appendix C. We use a
Gaussian kernel for the first three datasets, and a Hamming
distance kernel for Census, which has categorical features.
To investigate the effect of the block-diagonal approximation, we select the log-determinant as the criterion, which
is an instance of our criterion, and set λ = 1.
Quality of the log-determinant approximation.
We first investigate the quality of prototypes selection and
their runtimes, depicted in Figure 1. We compare our al-

gorithm with the FullGreedy, SieveStreaming and a random prototype selection baseline. We also use variants of
our algorithm including without clustering—naively dividing prototypes into equal-sized blocks—and one where we
only consider replacement in the closest block. We include these variants to indicate the importance of clustering
and of searching between blocks as well within blocks, in
BlockGreedy. For all experiments on maximization quality,
we use percentage gain with a threshold of t = 0.001.
We plot the log determinant with increasing samples, in
Figure 1(a). Experiments on the other datasets are included
in Appendix C. BlockGreedy maximizes the submodular
function within 1% of the FullGreedy method. Though
BlockGreedy achieves nearly as high a log determinant
value, we can see that its approximation of the log determinant is an overestimate for this small block size, r = 5.
Our next experiment, therefore, focuses on the estimate accuracy of BlockGreedy with increasing block
size, in Figure 1(b). The accuracy is computed by 1 −
−gestimate
| gactualgactual
|. We can see our algorithm, BlockGreedy
performs much better as compared to the other variants,
ranging in accuracy from 0.82 to 0.99. This suggests that
one can choose reasonably small block sizes, without incurring a significant penalty in maximizing the log determinant. In Figure 1(a), the estimate is inaccurate by about
20%, but follows the same trend of the full log determinant
and picks similar prototypes to those chosen by FullGreedy.
The runtime of our algorithm should be much less than
that of FullGreedy, and memory overhead much less than
SieveStreaming. In Figure 1(c), we can see our method
scales much better than FullGreedy and even has gains in
speed over SieveStreaming. Though not shown, the number
of sieves generated by SieveStreaming is large, in many instances well over 600, introducing a significant amount of

Adapting Kernel Representations Online Using Submodular Maximization
6
5.5

8

1

7.5

0.9

KRLS

7

5

Random

Random

0.6

Mean
Square6
Error

BlockGreedy without Clustering
BlockGreedy

5.5

3.5

5

Sieve Streaming
3
2.5

0.7

6.5
Root

Root
Mean
Square
Error

Full Greedy

KRLS

SieveStreaming

100

0.2
0.1

Block Greedy

150

200

250

300

Samples Processed

350

400

BlockGreedy
prediction

0.3

FullGreedy

4.5

0.5
0.4

4
50

True continuation

0.8

500

(a) Boston housing

1000

1500

2000

2500

3000

3500

Samples Processed

(b) Telemonitoring

0
1000

1020

1040

1060

1080

1100

Time Steps 1001-1100

(c) Santa Fe Data Set A

Figure 2. Figure (a) is the learning curve on Bostondata, averaged over 50 runs, with η = 0.01. On average, KRLS uses 116.46
prototypes. Figure (b) is the learning curve on the Telemonitoring data set, over 50 runs, with b = 500 and η = 0.001. Figure (c) plots
the predicted values of our algorithm and true values. The regularizer η = 0.001, and the utility threshold is t = 0.0001.

overhead. Overall, by taking advantage of the block structure of the kernel matrix, our algorithm obtains significant
runtime and memory improvements, while also producing
a highly accurate estimate of the log determinant.
Learning performance for regression problems.
While the maximization of the submodular function is
useful in creating a diverse collection of prototypes, ultimately we would like to use these representations for prediction. In Figure 2, we show the effectiveness of solving
(KS +ηI)w = y for the three regression datasets, by using
our algorithm to select prototypes for KS . For all regression experiments, we use a threshold of t = 0.01 unless
otherwise specified.
For Boston housing data, in figure 2(a), we see that BlockGreedy can perform almost as well as FullGreedy and
SieveStreaming, and outperforms KRLS at early learning
and finally converges to almost same performance. We set
the parameters for KRLS using the same parameter settings
for this dataset as in their paper (Engel et al., 2004). For
our algorithms we set the budget size to b = 80, which is
smaller than what KRLS used, and chose a block size of
4. We also have lower learning variance than KRLS, likely
because we use explicit regularization, whereas KRLS uses
its prototype selection mechanism for regularization.
On the Telemonitoring dataset, the competitive algorithms
all perform equally well, reaching a RMSE of approximately 4.797. BlockGreedy, however, uses significantly
less computation for selecting prototypes. We used a budget of b = 500, and a block size of r = 25; a block size
of r = 5 for this many prototypes impacted the log determinant estimation enough that it was only able to reach
a RMSE of about 5.2. With the larger block size, BlockGreedy obtained a log determinant value within 0.5% of
FullGreedy.

On the benchmark time series data set Santa Fe Data Set
A, we train on the first 1000 time steps in the series and
predict the next 100 steps, calculating the normalized MSE
(NMSE), as stated in the original competition. We set the
width parameter and budget size to that used with KRLS
after one iteration on the training set. The NMSE of our
algorithm and KRLS were 0.0434 and 0.026 respectively.
While our method performs worse, note that KRLS actually
runs on 6 × 1000 samples according to its description (Engel et al., 2004), but with 1000 samples it performs worse
with a NMSE of 0.0661. We demonstrate the 100-step forecast with BlockGreedy, in Figure 2(c); we include forecast
plots for the other algorithms in Figure 4, Appendix C.4.

7. Conclusion
We developed a memory and computation efficient incremental algorithm, called BlockGreedy, to select centers for
kernel representations in a continual learning setting. We
derived a criterion for prototype selection, and showed that
the log-determinant is an instance of this criterion. We extended results from streaming submodular maximization,
to obtain an approximation ratio for OnlineGreedy. We
then derived the efficient variant, BlockGreedy, to take advantage of the block-diagonal structure of the kernel matrix, which enables separability of the criteria and faster
local computations. We demonstrated that, by taking advantage of this structure, BlockGreedy can significantly reduce computation without incurring much penalty in maximizing the log-determinant and maintaining competitive
prediction performance. Our goal within continual learning
was to provide a principled, near-linear time algorithm for
prototype selection, in terms of the number of prototypes.
We believe that BlockGreedy provides one of the first such
algorithms, and is an important step towards effective kernel representations for continual learning settings, like online learning and reinforcement learning.

Adapting Kernel Representations Online Using Submodular Maximization

Acknowledgements
This research was supported in part by NSF CCF-1525024,
IIS-1633215 and the Precision Health Initiative at Indiana
University. We would also like to thank Inhak Hwang for
helpful discussions.

References
Argyriou, A. and Dinuzzo, F. A Unifying View of Representer Theorems. In International Conference on Machine Learning, 2014.
Bach, F. R. and Jordan, M. I. Predictive low-rank decomposition for kernel methods. In International Conference
on Machine Learning, 2005.

Gittens, A. and Mahoney, M. W. Revisiting the Nystrom
method for improved large-scale machine learning. In
International Conference on Machine Learning, 2013.
Guha, S., Meyerson, A., Mishra, N., Motwani, R., and
O’Callaghan, L. Clustering Data Streams: Theory and
Practice. IEEE Transaction on Knowledge and Data Engineering, 2003.
Huang, P. S., Avron, H., and Sainath, T. N. Kernel methods
match deep neural networks on timit. IEEE International
Conference on Acoustics, Speech and Signal Processing,
2014.
Kivinen, J., Smola, A., and Williamson, R. C. Online learning with kernels. IEEE Transactions on Signal Processing, 2010.

Badanidiyuru, A., Mirzasoleiman, B., Karbasi, A., and
Krause, A. Streaming submodular maximization: massive data summarization on the fly. Conference on
Knowledge Discovery and Data Mining, 2014.

Krause, A. and Gomes, R. G. Budgeted nonparametric
learning from data streams. In International Conference
on Machine Learning, 2010.

Brookes, M. Matrix reference manual. Imperial College
London, 2004.

Krause, A., McMahon, H. B., Guestrin, C., and Gupta, A.
Robust Submodular Observation Selection. Journal of
Machine Learning Research, 2008a.

Chen, B., Zhao, S., Zhu, P., and Principe, J. C. Quantized Kernel Recursive Least Squares Algorithm. IEEE
Transactions on Neural Networks and Learning Systems,
2013.
Cheng, C.-A. and Boots, B. Incremental Variational Sparse
Gaussian Process Regression. Advances in Neural Information Processing Systems, 2016.
Cheng, L., Vishwanathan, S. V. N., Schuurmans, D., Wang,
S., and Caelli, S. W. Implicit Online Learning with Kernels. In Advances in Neural Information Processing Systems, 2007.
Csató, L. and Opper, M. Sparse On-Line Gaussian Processes. dx.doi.org, 2006.
Dai, B., Xie, B., He, N., Liang, Y., Raj, A., Balcan, M.F. F., and Song, L. Scalable Kernel Methods via Doubly
Stochastic Gradients. Advances in Neural Information
Processing Systems, 2014.
Das, A. and Kempe, D. Submodular meets Spectral:
Greedy Algorithms for Subset Selection, Sparse Approximation and Dictionary Selection. arXiv.org, 2011.
Drineas, P. and Mahoney, M. W. On the Nyström Method
for Approximating a Gram Matrix for Improved KernelBased Learning. Journal of Machine Learning Research,
2005.
Engel, Y., Mannor, S., and Meir, R. The kernel recursive
least-squares algorithm. IEEE Transactions on Signal
Processing, 2004.

Krause, A., Singh, A. P., and Guestrin, C. Near-Optimal
Sensor Placements in Gaussian Processes: Theory, Efficient Algorithms and Empirical Studies. Journal of Machine Learning Research, 2008b.
Li, C., Jegelka, S., and Sra, S. Fast DPP Sampling for Nystrom with Application to Kernel Methods. In International Conference on Machine Learning, 2016.
Lichman, M. UCI machine learning repository. URL
http://archive. ics. uci. edu/ml, 2015.
Lu, Z., May, A., Liu, K., Garakani, A. B., Guo, D., Bellet,
A., Fan, L., Collins, M., Kingsbury, B., Picheny, M., and
Sha, F. How to Scale Up Kernel Methods to Be As Good
As Deep Neural Nets. CoRR abs/1202.6504, 2014.
Mairal, J., Koniusz, P., Harchaoui, Z., and Schmid, C. Convolutional Kernel Networks. NIPS, 2014.
Matic, I. Inequalities with determinants of perturbed positive matrices. Linear Algebra and its Applications, 2014.
Park, J. and Sandberg, I. Universal Approximation Using
Radial-Basis-Function Networks. Neural Computation,
1991.
Rahimi, A. and Recht, B. Random features for large-scale
kernel machines. In Advances in Neural Information
Processing Systems, 2007.
Richard, C., Bermudez, J. C. M., and Honeine, P. Online Prediction of Time Series Data With Kernels. IEEE
Transactions on Signal Processing, 2009.

Adapting Kernel Representations Online Using Submodular Maximization

Rudi, A., Camoriano, R., and Rosasco, L. Less is More:
Nyström Computational Regularization. Advances in
Neural Information Processing Systems, 2015.
Schraudolph, N. N., Smola, A. J., and Joachims, T. Step
size adaptation in reproducing kernel Hilbert space.
Journal of Machine Learning Research, 2006.
Seeger, M. Greedy Forward Selection in the Informative
Vector Machine. 2004.
Seeger, M., Williams, C., and Lawrence, N. Fast Forward
Selection to Speed Up Sparse Gaussian Process Regression. Artificial Intelligence and Statistics, 2003.
Si, S., Hsieh, C.-J., and Dhillon, I. Memory efficient kernel
approximation. In International Conference on Machine
Learning, 2014.
Tsanas, A., Little, M. A., and McSharry, P. E. Accurate Telemonitoring of Parkinson’s Disease Progression
by Noninvasive Speech Tests. IEEE transactions on
Biomedical Engineering, 2010.
Van Vaerenbergh, S. and Santamaria, I. A comparative
study of kernel adaptive filtering algorithms. In Digital Signal Processing and Signal Processing Education
Meeting, 2013.
Van Vaerenbergh, S., Santamarı́a, I., Liu, W., and Principe,
J. C. Fixed-budget kernel recursive least-squares. In
IEEE International Conference on Acoustics, Speech
and Signal Processing, 2010.
Weigend, A. S. Time Series Prediction: Forecasting the
Future and Understanding the Past. Santa Fe Institute
Studies in the Sciences of Complexity, 1994.

Adapting Kernel Representations Online Using Submodular Maximization

A. Coverage time for the log-determinant
The more general coverage time condition assumes similarity between points, based on the submodular function
itself. However, more intuitively, we would like the condition to be related to the similarity measure. In this section, we show how we can obtain Assumption 3 for the
log-determinant, but using instead coverage in terms of
the kernel rather than the submodular function itself. In
the below, we show √
that, for an  related to r , when
||φ(x1 ) − φ(x2 )|| ≤ 2,  ≥ 0 for two points x1 , x2 —
which for a normalized kernel means k(x1 , x2 ) ≥ 1 − —
then we get that |g(S ∪ {x1 }) − g(S ∪ {x2 })| ≤ r .
Lemma 2. Assume k is a continuous Mercer√kernel. For
, we
g(S) = log det(λI + KS ) and r = log λ+ 8λ+2
λ
√
have that if ||φ(x1 ) − φ(x2 )|| ≤ 2 then
|g(S ∪ {x1 }) − g(S ∪ {x2 })| ≤ r .

Proof: Let K be the kernel matrix without x1 and without x2 , let kii denote k(xi , xi ) for short. Then Kj =
[K k>
j ; kj kjj ] for kj = [k(z1 , xj ), . . . , k(zb−1 , xj )]. The
determinant of λI + Kj , by (Matic, 2014, Theorem 2.4), is
det(λI + Kj )
>

−1

= det(λI + K) det(kjj + λ − kj (λI + K) kj )
−1

>

= det(λI + K)(kjj + λ − kj (λI + K) kj )

ing φ(x2 ) in above minimization problem, then:



X


ai φ(zi ) − φ(x1 )



zi ∈S



X


ai φ(zi ) − φ(x1 ) + φ(x2 ) − φ(x2 )
=


z ∈S

 i

X


ai φ(zi ) − φ(x2 ) + kφ(x1 ) − φ(x2 )k
≤


z ∈S

 i
 √
X


ai φ(zi ) − φ(x2 ) + 2.
≤


zi ∈S

.
Let b = λ + k22 − k>
+ K)−1 k2 , which means b =
2 (λI
2
P
 + λkak22 + λ. Then

zi ∈S ai φ(zi ) − φ(x2 )

2
X



ai φ(zi ) − φ(x1 ) + λkak22 + λ
(6)



zi ∈S


!2
X
 √


≤ 
ai φ(zi ) − φ(x2 ) + 2 + λkak22 + λ


zi ∈S


√
X


ai φ(zi ) − φ(x2 ) 2 + 2
≤ b + 2


zi ∈S
√
≤ b + 8b + 2
P
where the last step follows because k zi ∈S ai φ(zi ) −
φ(x2 )k2 ≤ b. Because a is not optimal for x1 ,
>

−1

λ + k11 − k1 (λI + K) k1 ≤ (6)
≤b+

The ratio between the two determinants then reduces to

√
8b + 2

Because b ≥ λ
log det(λI + K1 ) − log det(λI + K2 )

>

−1

det(λI + K1 )
λ + k11 − k1 (λI + K) k1
λ + k11
=
≤
−1
det(λI + K2 )
λ + k22 − k>
λ
(λI
+
K)
k
2
2
with the lower bound on the denominator resulting from
−1
k22 − k>
2 (λI + K) k2 ≥ 0 because:
>

−1

kjj − kj (λI + K) kj

2
X



= min 
ai φ(zi ) − φ(xj ) + λkak22
a 

zi ∈S

One should note that this is a loose upper bound without
restriction on . To get a tighter bound, we start
√ from considering distance bound kφ(x1 ) − φ(x2 )k ≤ 2. We will
see that they have a similar error in being spanned by the
kernels in K. Let a be the optimal solution for approximat-

det(λI + K1 )
det(λI + K2 )
√
b + 8b + 2
≤ log
√b
λ + 8λ + 2
≤ log
λ
= log

11
Note that this is a tighter lower bound than log λ+k
when
λ
√
√
 ≤ λ + k11 − λ. We can swap the order of x1 and x2 ,
to get a bound on the absolute difference, completing the
proof.


B. Generalization to approximate
submodularity
In this section, we generalize our approximate ratio results
for OnlineGreedy to functions that are approximately submodularity.

Adapting Kernel Representations Online Using Submodular Maximization

Assumption 4 (Approximate submodularity). g is monotone increasing and approximately submodular with submodularity ratio γ ≥ 0.

The last inequality follows from the chosen ordering, giving g({z1 , . . ., zi−2 }∪{zi }) ≤ g({z1 , . . ., zi−2 }∪{zi−1 }).


An approximately submodular function (Das & Kempe,
2011) satisfies the looser requirement that
X
γ(g(S ∪ A) − g(S)) ≤
g(S ∪ {a}) − g(S)).

Otherwise, for approximately submodular functions, in the
worst case, there could be an adversarial ordering that results in δi−1 = γδi . Consequently δi = γ k−i δb , which
would lead to a poor approximation ratio for OnlineGreedy.
This worst case behavior, however, is highly unlikely. For
example, in feature selection, it is highly unlikely that all
features interact to cause this worst case behavior. For our
streaming setting, it is highly unlikely that we will see an
adversarial sequence of observations that causes our criteria to have δi = γ k−i δb .

a∈A

For γ ≥ 1, the function is submodular. An example of
an approximately submodular function is feature selection using correlation between features and residuals (Das
& Kempe, 2011). In some cases, adding features does
not satisfy a diminishing returns property. This is due to
interactions between pairs of features, where using both
features can significantly improve prediction performance
even though individually they are insufficient. For many
features and sets, the correlation function is submodular;
however, in the worst case, we can only guarantee approximate submodularity. Our generalized coherence criterion
is guaranteed to be approximately submodular, for a sufficiently small γ. However, we anticipate a γ near one, since
for feature selection, Das & Kempe (2011) demonstrated
empirically that γ was typically above 0.8. The generalized
coherence criterion is similar to feature selection, in that it
selects prototypes to better span φ(x) for all x, according
to a weighted criterion.
Assumption 5 (Probabilistic approximate submodularity).
The stream of data satisfies the probabilistic submodular
property: with probability 1 − δ, for the chosen set of prototypes S = {z1 , . . . , zb }, with zb = argminz∈S g(S) −
g(S\{z}) the single least important element, there exists
an ordering {z1 , . . . , zk−1 } with δi = g({z1 , . . . , zi }) −
g({z1 , . . . , zi−1 }) such that the average difference is apPb
proximately submodular: 1b i=1 δi ≥ γδb .
For a submodular function, this is automatically true, as we
show in the next lemma
Lemma 3. Given a set S and submodular g, let
zi = argmaxs∈St g({z1 , . . . , zi−1 } ∪ {s}) and δi =
g({z1 , . . . , zi }) − g({z1 , . . . , zi−1 }). Then δi−1 ≥ δi .
Proof:
g({z1 , . . . , zi−2 } ∪ {zi−1 }) + g({z1 , . . . , zi−2 } ∪ {zi })
≥ g({z1 , . . . , zi−2 } ∪ {zi−1 , zi }) + g({z1 , . . . , zi−2 })
we get that

Theorem 4. Assume Assumptions 1-4 and that g(S ∗ ) is
finite and g(∅) ≥ 0. Then, for t > ρg(S ∗ )/t , all sets St
chosen by OnlineGreedy using ĝ satisfy with probability
1 − 2δ

g(St ) ≥

b
1
g(S ∗ ) −
(r + 2f + t )
2
2γ

Proof: The proof follows closely to the proof of Krause
& Gomes (2010, Theorem 4). The key difference is that
we cannot do multiple passes through a fixed dataset, but
instead simulate this by the fact that the sampling mixes
sufficiently to see observations close to the set of optimal
prototypes. Further, we relax the requirement of submodularity to approximate submodularity and do not require g
to be bounded for all subsets, but rather only use the upper
bound of the optimal solution.
Case 1: There have been t ≥ ρg(S ∗ )/t iterations, and St
has always changed within ρ iterations (i.e., there has never
been ρ consecutive iterations where St remained the same).
This mean that for each ρ iterations, ĝ(St ) must have been
improved by at least t , which is the minimum threshold for
improvement. This means that over the t iterations, ĝ(S0 )
has improved by at least t each ρ,
ĝ(S0 ) + t t/ρ ≥ t t/ρ
= ĝ(S ∗ )
≥ g(S ∗ ) − f
In this case, the solution is within f of g(S ∗ ), and we are
done.

Case 2: At some time t, St was not changed for ρ iterations,
i.e., St−ρ = St−ρ−1 = . . . St . Let S = {z1 , . . . , zb−1 }
≥ g({z1 , . . ., zi−2 }∪{zi−1 , zi }) − g({z1 , . . ., zi−2 }∪{zi })
and δi = g({z1 , . . . , zi }) − g({z1 , . . . , zi−1 }), with or≥ g({z1 ,. . .,zi−2 }∪{zi−1 , zi })−g({z1 , . . ., zi−2 }∪{zi−1 }) dering given by Assumption 5. Because the point that was
observed ri that was closest to z∗i was not added to S, we
= δi .

δi−1 = g({z1 , . . ., zi−2 } ∪ {zi−1 }) − g({z1 , . . ., zi−2 })

Adapting Kernel Representations Online Using Submodular Maximization

have the following inequalities
|ĝ(S ∪ {ri }) − g(S ∪ {ri })| ≤ f
ĝ(S ∪ {ri }) − ĝ(S ∪ {zb }) ≤ t
|g(S ∪ {ri }) − g(S ∪ {z∗i })| ≤ r
g(S ∪ {zb }) − g(S) = δb .
where the second last inequality is true for all z∗i with probability 1 − δ. Therefore,
g(S ∪ {z∗i }) − g(S)
= g(S ∪ {z∗i }) − g(S ∪ {zb }) + g(S ∪ {zb }) − g(S)
= g(S ∪ {z∗i }) − g(S ∪ {ri })
+ g(S ∪ {ri }) − g(S ∪ {zb }) + δb
≤ r + δb + g(S ∪ {ri }) − g(S ∪ {zb })
= r + δb + g(S ∪ {ri }) − ĝ(S ∪ {ri })
+ ĝ(S ∪ {ri }) − g(S ∪ {zb })
≤ r + δb + f + ĝ(S ∪ {ri }) − g(S ∪ {zb })
= r + δb + f + ĝ(S ∪ {ri }) − ĝ(S ∪ {zb })
+ ĝ(S ∪ {zb }) − g(S ∪ {zb })
≤ r + δb + f + t + f

C. Experimental Details
C.1. Details on Boston Housing Data Set
We conduct experiments on a frequently cited and easily understandable real world data set — Boston housing
(Lichman, 2015). The data set includes 506 samples, each
of which has 13 features. Our purpose is to predict the median value of owner-occupied homes in $1000’s for various Boston neighborhoods. We normalize all the attributes
to a range of [0, 1]. Our experiments follow the parameter
settings specified in the KRLS paper (Engel et al., 2004):
the RBF width as σ = 0.295, and ALD condition threshold
ν = 0.001. We also choose reasonably good parameters for
our algorithms instead of fully optimize them. The budget
is b = 80, the number of blocks c = 20, the regularization parameter for computing log determinant is λ = 1.0,
and the regularization parameter for solving linear system
is η = 0.01. We randomly shuffle the data set with 400
training samples and 106 testing samples to get learning
curve averaged over 50 runs. The prediction error is calculated with the root mean squared error and can be found in
figure 2(a). The utility change as number of samples processed is showed in figure 3(a) and figure 3(b).

= δb + r + 2f + t
C.2. Details on Parkinson’s Telemonitoring Dataset
By definition of approximate submodularity,

The Parkinsons Telemonitoring dataset (Tsanas et al.,
2010) is composed of a range of biomedical voice measureγ(g(S ∪ S ∗ ) − g(S)) ≤
g(S ∪ {s∗i }) − g(S)).
ments from 42 people with early-stage Parkinson’s disease.
i=1
The task is to predict the clinician’s Parkinson’s disease
symptom score on the UPDRS scale. Two out of the 26
Putting this all together, with probability 1 − δ additionally
attributes are targets: motor and total UPDRS scores. We
from Assumption 5, we get with probability 1 − 2δ
choose motor UPDRS as our prediction target. After norg(S ∗ ) ≤ g(S ∪ S ∗ )
malizing the data to range [0, 1], we randomly shuffle the
b
set and use the first 3500 sample as the training set and the
X
1
g(S ∪ {z∗i }) − g(S))
≤ g(S) +
remaining
2375 as the test set. We incrementally process
γ i=1
the training samples and record RMSE of each algorithm
b
at each step to obtain the learning curve, the true log de1X
≤ g(S) +
(δb + r + 2f + t )
terminant is also calculated and stored with the estimated
γ i=1
value used by our algorithms. All experiments using this
!
b
dataset are averaged over 10 runs with randomly shuffled
1 X
b
≤ g(S) + 2
δi + (r + 2f + t )
training and testing sets. The parameter settings are as folγ
γ
i=1
lows: the budget is set to a reasonably large value, 200,
b
for the log determinant measurements and we sweep over
1 X
= g(S) + 2
g({z1 , . . . , zi }) − g({z1 , . . . , zi−1 }) the threshold parameter to find a 
opt = 0.001, we used
γ i=1
a block size of 5 and 25 for measuring the log determib
nant and doing regression respectively. We set the regular+ (r + 2f + t )
γ
izer parameters for calculating the log determinant and for
b
solving the linear system as λ = 1.0 and η = 0.001 re≤ g(S) + g({z1 , . . . , zb }) + (r + 2f + t )
γ
spectively. For Sieve-Streaming the parameter used for determining the coarseness of the generated sieve’s Optimal
b
≤ 2g(St ) + (r + 2f + t )
Estimate is set to 0.01, which gave a good approximation
γ
for the maximization of the submodular function.
where the last inequality follows from monotonicity, giving
KRLS used around 900 prototypes when not bounded, but
g(S) ≤ g(St ).

b
X

Adapting Kernel Representations Online Using Submodular Maximization

this proved to high for use with the full greedy algorithm
so we decided to restrict the budget to 500 prototypes for
all algorithms. We can see that KRLS, Online Greedy,
Block Greedy, and sieve streaming all perform equally as
well. While KRLS does perform slightly better when not
restricted to a small number of prototypes, this behavior
would be unrealistic in more complex state spaces. The
block accuracy is calculated with
1−|

gactual − gestimate
|
gactual

with three variants of our algorithm over various block
sizes ∈ {5, 10, 15, 20, 25, 30, 40, 50, 75, 100}, figure 1(b).
Our algorithm performs very well not only in accuracy,
but also in selecting similar prototypes as the Full Greedy
algorithm. Finally in the time trials, figure 1(c), we remove all regression implementation and sweep over b ∈
{50, 60, 75, 100, 125, 150, 175, 200, 250, 300, 500}. While
it is possible to generate less sieves with SieveStreaming
through a higher  value, this results in a less accurate approximation of the Online-Greedy prototype selection.
C.3. Details on the United States Census 1990 dataset
The USA Census 1990 dataset, found at (Lichman, 2015),
is a large set containing over 2 million samples. Traditionally this set is used for clustering, but is a prime candidate to test efficient methods for submodular function
maximization. Because this set is categorical in nature we
decided to instead use a Hamming Distance type kernel,
where
hamming(x, c)
)
g = exp(−
2σ 2
and the hamming distance hamming(·, ·) is calculated as
the number of mismatching attributes. We set the width parameter as σ = 5, set the budget as b = 100 and we used 20
blocks for our algorithm. You can see the behavior of the
log determinant of the various methods in Figure 3(c). Our
algorithm performs almost as well as the full online greedy
algorithm and sieve streaming, but our method requires sig3
nificantly less time than the full online greedy (about 1000
of the time) and much less memory overhead than the sieve
streaming method.
C.4. Details on Santa Fe Data Set A
The Santa Fe Data Set A (Weigend, 1994) is a difficult time
series prediction data set. Training on the first 1000 time
steps of the set, the task is to predict the values in the next
100 steps. We normalize the data to range [0, 1], similar to
what was done in (Engel et al., 2004). The KRLS paper
also proposed a complicated framework using predictions
as apart of the training set, we decided to approach this
problem simply by directly training on the 1000 samples

through a single iteration and predict using the kernel representation developed during training. Several other parameters are chosen based off settings from the KRLS paper,
and our observations about the number of prototypes used
by KRLS: RBF width σ = 0.9, model order d = 40, ALD
condition ν = 0.01, budget size b = 310, and the number
of blocks 16. To choose the regularizer parameter and utility gain threshold , we use 1 − 900 samples as training set
and use 901 − 1000 samples as a validation set. We set the
final parameters as opt = 0.0001, and λopt = 0.001.
The predictions are in figure 4, and the log determinant
as a function of processed samples can be found in figure
4(b). The NMSE (normalized mean squared error, i.e. mean
square error divided by variance of the prediction series)
our block algorithm achieved is 0.0434. Though slightly
worse than the result from KRLS whose NMSE is 0.026
and the first entry whose NMSE is 0.028, our algorithm significantly outperforms the second entry 0.08 in that competition. While our algorithm is outperformed by KRLS, it is
important to remember our algorithm has a limited number of weights used and was only trained through one iteration of the first 1000 time steps. KRLS also includes a
growing weight vector and other relevant matrices such as
At . In the original KRLS paper they actually trained on
6 × 1000 time steps by iteratively incorporating the predictions, but when trained with a single iteration it performs
significantly worse with a NMSE of 0.0661.

D. Efficient Modification of the Inverse of the
Kernel Matrix
We derive updates when replacing, adding and deleting a
prototype, to obtain the new inverse kernel matrix from the
previous kernel matrix.
D.1. Replacement Update for the Inverse of the Kernel
Matrix
Updating the inverse of the kernel matrix can be regarded as
four rank-one updates, which can be further reduced to two
rank-one udpates via algebra computation. Let the original
kernel matrix be K, we want to replace the ith row and column, k> and k by new row and column k̃> and k̃. Let x =
0, xi = 1, k0 denote the vector by setting ki = 0, and so
as k̃0 . Then to get the inverse of the replaced kernel matrix,
we want to compute (K − xk> − k0 x> + xk̃> + k̃0 x> )−1 ,
which is equal to (K + x(k̃ − k)> + (k̃0 − k0 )x> )−1 . Note
that k̃0 − k0 = k̃ − k, so the final updating rule can be
used as algorithm 6 described. One should note that since
the regularization parameter λ will be canceled via the minus sign, so the updating rule for regularized kernel matrix
will be exactly the same with the one without regularization.

Adapting Kernel Representations Online Using Submodular Maximization

20

20
BlockGreedy with only local replacement

18

BlockGreedy without clustering

18

16

SieveStreaming

16
FullGreedy

14

14

BlockGreedy

FullGreedy
12

12

Log
det(K+I)

Random

SieveStreaming

Log
det(K+I)

BlockGreedy without clustering

8

6

4

4

2

2
50

100

150

200

250

300

350

0

400

Random

BlockGreedy with only
local replacement

8

6

0

BlockGreedy

50

100

Samples Processed

150

200

250

300

350

400

Samples Processed

(a) log det vs steps on boston data t = 0.001

(b) log det vs steps on boston data t = 0.01

120

BlockGreedy Estimation
100
80

Log
60
Determinant

SieveStreaming

FullGreedy
BlockGreedy

40
20

BlockGreedy without clustering

Random

0
2000

4000

6000

8000 10000 12000 14000

Samples Processed

(c) log det Est vs steps on Census data
Figure 3. Figure (a) and (b) show log determinant maximization for each algorithm on boston data. The utility gain threshold is setted
different on the two figures. Note that other parameters are the same: budget is 80 and block size is 4. (c) Census Data (100 prototypes)
- This is the plot showing the true log determinant of each method’s true K matrix as calculated with all the prototypes chosen by the
algorithm. The color scheme is the same as in figure 1(a).

Adapting Kernel Representations Online Using Submodular Maximization

1

FullGreedy

120

0.9

BlockGreedy

0.8

100

0.7
0.6

80

0.5

Log
det(K+I)

Random

0.4
40

0.3
0.2

20
0.1
0

200

400

600

800

0

1000

200
400
600
800
Number of Samples Processed

Training Data: Time Steps 1-1000

(a) Santa Fe Training Data
1
0.9

(b) Santa Fe Log Determinant Change Versus Steps
1

True continuation
KRLS prediction

0.9

0.8

0.8

0.7

0.7

0.6

0.6

0.5

0.5

0.4

0.4

0.3

0.3

0.2

0.2

0.1

0.1

0
1000

1020

1040

1000

1060

1080

0
1000

1100

True continuation

FullGreedy
Prediction

1020

Time Steps 1001-1100

(c) KRLS (one pass) vs True
1

1040

1060

1080

1100

Time Steps 1001-1100

(d) FullGreedy vs True

True continuation

0.9

Random(Center)
prediction

0.8
0.7
0.6
0.5
0.4
0.3
0.2
0.1
0
1000

1020

1040

1060

1080

1100

Time Steps 1001-1100

(e) Random vs True
Figure 4. Figure (a) shows the difficulties on Santa Fe data, it has significant dynamics and noise. (b) is the log determinant utility
change. One can see that it matches our intuition about from which part we should pick prototypes. For example, figure b shows our
algorithm is picking prototypes during the steps 600 − 700 , which corresponds to the sharp change in the training set around those time
steps. Figures (c), (d), (e) show the predictions from KRLS, and regression solutions computed by using prototypes picked randomly
and picked by original online greedy algorithm. The greedy method with full kernel matrix can achieve almost the same NMSE with the
first entry and original KRLS result (Engel et al., 2004).

Adapting Kernel Representations Online Using Submodular Maximization

D.2. Addition Update for the Inverse of Kernel Matrix
Updating the inverse of kernel matrix when a new row and
column attached can be done via block matrix inversion
lemma. Let Kt be the updated matrix from Kt−1 . Then

K−1
t =



Kt−1
k>

k
k(xt , xt ) + λ

−1

Taking logarithmic on both sides, one can get:
log det(K + xy> ) = log(1 + y> K−1 x)
+ log det K
.
K̃ = K + xy>
log det(K̃ + yx> ) = log(1 + x> K̃−1 y)

.

+ log(1 + y> K−1 x)
+ log det K

.
−1
Define v = (kxx + λ − k> K−1
, then we have:
t−1 k)
K−1
t =



−1
> −1
K−1
t−1 + vKt−1 kk Kt−1
> −1
−vk Kt−1

−vK−1
t−1 k
v

To get the term x> K̃−1 y in the above formulae, one can
apply sherman morrison formulae again:



−1

This needs to be used when we delete a prototype from a
block. Assume one wants to get Kt by deleting the ith row
and column in the kernel matrix Kt−1 . To better illustrate
the derivation, in below reasoning we rearrange the ith row
and column to the last. Define x = 0, xi = −1 and y as the
ith column in Kt−1 but with yi = 0. Then one can easily
derive the updating rule as following.


Kt
k>

k
k(x, x) + λ





Kt
0>

0
k(x, x) + λ

−1



K−1
t
0>

Kt−1 =
(Kt−1 + xy> + yx> )−1 =
=

0
(k(x, x) + λ)−1

K−1 xy> K−1
1 + y> K−1 x
x> K−1 xy> K−1 y
−1
x> K̃−1 y = x> K y −
1 + y> K−1 x
K̃−1 = K

D.3. Deletion Update for the Inverse of the Kernel
Matrix



−1

Let K̃t
= (Kt−1 + xy> + yx> )−1 , then one can get
−1
−1
Kt by removing the last row and column in K̃t .

−

Then if we define the following quantities:
.
−1
−1
a = y > K x = x> K y
.
−1
b = x> K x
.
−1
c = y> K y
.
u = log det K
bc
)
log det(K̃ + yx> ) = log(1 + a −
1+a
+ log(1 + a) + u
= log((1 + a)2 − bc) + u
We will get the final updating rule:
log det(K + xy> + yx> ) = log((1 + a)2 − bc) + u

E. Incremental Updating Rule for the Log
Determinant
>

>

E.1. Updating Rule for xy + yx Perturbation
Both prototype replacement and deletion require us to efficiently compute log det(K + xy> + yx> ). Note that
det(I + xy> ) = 1 + x> y. For vectors x, y, we have the
following reasoning.
det(K + xy> ) = det(K(I + K−1 xy> ))
= det(K) det(I + K−1 xy> )
= (1 + y> K−1 x) det(K)

One should note that when this formulae is very efficient
when x is a sparse vector, which is the case when replacement or deletion operation are applied. In this case,
xi = ±1, which make the computation of a linear time
and b = (K−1 )ii , the only quadratic operation is a matrixvector product: y> K−1 y. The total time complexity of this
update is two linear operation and one quadratic operation.
By keeping a copy of the inverse of the kernel matrix, we
can apply this formula because each prototype replacement
can be thought as two rank-one update as described in previous section. With regularization, one can simply replace
K by K + λI. Everything else is the same.

Adapting Kernel Representations Online Using Submodular Maximization

E.2. Update log det for Attaching
Let Kt be the matrix after attaching column and row to
Kt−1 .


Kt−1
k
det Kt = det
k>
k(x, x) + λ
= det Kt−1 det(λ + k(x, x) − k> K−1
t−1 k)
log det Kt = log det Kt−1 + log det(λ + k(x, x)
− k> K−1
t−1 k)
E.3. Update log det for Deletion
First, let Kt be the matrix after deleted ith row and column
from Kt−1 . One can first arrange the ith row and column
of the Kt−1 to the last row and last column. One should
note that:


Kt
0
log det
= log det Kt + log(1 + λ)
0> k(x, x) + λ
(7)
Let x = 0, xi = −1 and y be the ith row (after rearrangement, it becomes the last row) of the Kt−1 matrix but set
yi = 0. Then one has:


Kt
0
= Kt−1 + xy> + yx>
(8)
0> k(x, x) + λ
Plug 8 into 7, one can get the final updating rule as:
log det Kt = log det(Kt−1 + xy> + yx> ) − log(1 + λ)
The part log det(Kt−1 + xy> + yx> ) can be updated by
rank-one update for log det derived in previous section.

F. Time Complexity Analysis
We specify the notations as following. Let r is the block
size, b is the budget size, |B| is the number of blocks, and
d is the number of features of an observation. First, we
need to be clear about three important mathematical operations: update log determinant when attaching, deleting and
replacment. Each of this operation would only take O(r2 ),
in fact only one quadratic operation is required for each update. Please refer to E.2 for attaching update, E.3 for deleting update, and E.1 for replacement update.
We divide the analysis into two stages. The first stage,
t < b, we simply accept every prototype resulting in constant time. At the second stage, we need to do clustering
first, which costs O(b2 d). Because we initialize the clustering with the previous clustering, which should be relatively accurate, the number of required steps is reduced.
Therefore, we do not pursue a precise clustering, and stop
the iteration process after at most b/|B| steps. Since each

clustering step costs |B|bd, and there are at most b/|B| iterations, the worst-case cost is O(b2 d). Then, the rest of
dominating costs come from the following steps.
1. Finding the nearest cluster. This involves computing
distances to all means, costing O(|B|d). Since |B| ≤
b, we get at worst O(bd)
2. Updating the book-keeping maps. When we cluster,
we recompute book-keeping maps for every block,
which costs O(|B|r3 ). Any of the above three updates
for computing the maps for each block cost O(r3 ).
3
Amortized over b steps, this is |B|r
b . Since |B| ≤ b,
we get at worst O(r3 ).
3. Looking for the replacement within the closest block
to the current sample. This would cost O(r3 ) since
each replacement update for log determinant costs
O(r2 ) and there is at most r replacements in a block.
4. Looking for replacement through other blocks. This
would cost only O(|B|), because the length |B| booking map has to be scanned.
As a summary, our algorithm would incur time cost O(bd+
r3 ) at each step. Because r  b, we get an amortized cost
linear in b.

