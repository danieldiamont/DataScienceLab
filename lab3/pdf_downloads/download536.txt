Orthogonalized ALS: A Theoretically Principled Tensor Decomposition
Algorithm for Practical Use

Vatsal Sharan 1 Gregory Valiant 1

Abstract
The popular Alternating Least Squares (ALS) algorithm for tensor decomposition is efficient and
easy to implement, but often converges to poor
local optima—particularly when the weights of
the factors are non-uniform. We propose a modification of the ALS approach that is as efficient as standard ALS, but provably recovers
the true factors with random initialization under standard incoherence assumptions on the factors of the tensor. We demonstrate the significant practical superiority of our approach over
traditional ALS for a variety of tasks on synthetic data—including tensor factorization on exact, noisy and over-complete tensors, as well as
tensor completion—and for computing word embeddings from a third-order word tri-occurrence
tensor.

1. Introduction
From a theoretical perspective, tensor methods have become an incredibly useful and versatile tool for learning
a wide array of popular models, including topic modeling (Anandkumar et al., 2012), mixtures of Gaussians (Ge
et al., 2015), community detection (Anandkumar et al.,
2014a), learning graphical models with guarantees via
the method of moments (Anandkumar et al., 2014b; Chaganty & Liang, 2014) and reinforcement learning (Azizzadenesheli et al., 2016). The key property of tensors that enables these applications is that tensors have a
unique decomposition (decomposition here refers to the
most commonly used CANDECOMP/PARAFAC or CP
decomposition), under mild conditions on the factor matrices (Kruskal, 1977); for example, tensors have a unique
decomposition whenever the factor matrices are full rank.
As tensor methods naturally model three-way (or higherorder) relationships, it is not too optimistic to hope that
1
Stanford University, USA. Correspondence to: Vatsal Sharan
<vsharan@stanford.edu>.

Proceedings of the 34 th International Conference on Machine
Learning, Sydney, Australia, PMLR 70, 2017. Copyright 2017
by the author(s).

their practical utility will only increase, with the rise of
multi-modal measurements (e.g. measurements taken by
“Internet of Things” devices) and the numerous practical
applications involving high order dependencies, such as
those encountered in natural language processing or genomic settings. In fact, we are already seeing exciting
applications of tensor methods for analysis of high-order
spatiotemporal data (Yu & Liu, 2016), health data analysis
(Wang et al., 2015a) and bioinformatics (Colombo & Vlassis, 2015). Nevertheless, to truly realize the practical impact that the current theory of tensor methods portends, we
require better algorithms for computing decompositions—
practically efficient algorithms that are both capable of
scaling to large (and possibly sparse) tensors, and are robust to noise and deviations from the idealized “low-rank”
assumptions.
As tensor decomposition is NP-Hard in the worst-case
(Hillar & Lim, 2013; Håstad, 1990), one cannot hope for
algorithms which always produce the correct factorization.
Despite this worst-case impossibility, accurate decompositions can be efficiently computed in many practical settings. Early work from the 1970’s (Leurgans et al., 1993;
Harshman, 1970) established a simple algorithm for computing the tensor decomposition (in the noiseless setting)
provided that the factor matrices are full rank. This approach, based on an eigendecomposition, is very sensitive
to noise in the tensor (as we also show in our experiments),
and does not scale well for large, sparse tensors.
Since this early work, much progress has been made. Nevertheless, many of the tensor decomposition algorithms
hitherto proposed and employed have strong provable success guarantees but are computationally expensive (though
still polynomial time)—either requiring an expensive initialization phase, being unable to leverage the sparsity of
the input tensor, or not being efficiently parallelizable. On
the other hand, there are also approaches which are efficient to implement, but which fail to compute an accurate
decomposition in many natural settings. The Alternating
Least Squares (ALS) algorithm (either with random initialization or more complicated initializations) falls in this latter category and is, by far, the most widely employed decomposition algorithm despite its often poor performance

Orthgonalized ALS for Tensor Decomposition

and propensity for getting stuck in local optima (which we
demonstrate on both synthetic data and real NLP data).
In this paper we propose an alternative decomposition algorithm, “Orthogonalized Alternating Least Squares” (OrthALS) which has strong theoretical guarantees, and seems to
significantly outperform the most commonly used existing
approaches in practice on both real and synthetic data, for a
number of tasks related to tensor decomposition. This algorithm is a simple modification of the ALS algorithm to periodically “orthogonalize” the estimates of the factors. Intuitively, this periodic orthogonalization prevents multiple
recovered factors from “chasing after” the same true factors, allowing for the avoidance of local optima and more
rapid convergence to the true factors.
From the practical side, our algorithm enjoys all the benefits of standard ALS, namely simplicity and computational
efficiency/scalability, particularly for very large yet sparse
tensors, and noise robustness. Additionally, the speed of
convergence and quality of the recovered factors are substantially better than standard ALS, even when ALS is initialized using the more expensive SVD initialization. As
we show, on synthetic low-rank tensors, our algorithm consistently recovers the true factors, while standard ALS often falters in local optima and fails both in recovering the
true factors and in recovering an accurate low-rank approximation to the original tensor. We also applied Orth-ALS to
a large 3-tensor of word co-occurrences to compute “word
embeddings”.1 The embedding produced by our Orth-ALS
algorithm is significantly better than that produced by standard ALS, as we quantify via a near 30% better performance of the resulting word embeddings across standard
NLP datasets that test the ability of the embeddings to answer basic analogy tasks (i.e. “puppy is to dog as kitten
is to ?”) and semantic word-similarity tasks. Together,
these results support our optimism that with better decomposition algorithms, tensor methods will become an indispensable, widely-used data analysis tool in the near future.
Beyond the practical benefits of Orth-ALS, we also consider its theoretical properties. We show that Orth-ALS
provably recovers all factors under random initialization
for worst-case tensors as long as the tensor satisfies an incoherence property (which translates to the factors of the
tensors having small correlation with each other), which is
satisfied by random tensors with rank k = o(d0.25 ) where
d is the dimension of the tensor. This requirement that k =
o(d0.25 ) is significantly worse than the best known provable recovery guarantees for polynomial-time algorithms
1
Word embeddings are vector representations of words, which
can then be used as features for higher-level machine learning.
Word embeddings have rapidly become the backbone of many
downstream natural language processing tasks (see e.g. (Mikolov
et al., 2013b)).

on random tensors—the recent work Ma et al. (2016) succeeds even in the over-complete setting with k = o(d1.5 ).
Nevertheless, our experiments support our belief that this
shortcoming is more a property of our analysis than the algorithm itself. Additionally, for many practical settings,
particularly natural language tasks, the rank of the recovered tensor is typically significantly sublinear in the dimensionality of the space, and the benefits of an extremely efficient and simple algorithm might outweigh limitations on
the required rank for provable recovery.
Finally, as a consequence of our analysis technique for
proving convergence of Orth-ALS, we also improve the
known guarantees for another popular tensor decomposition algorithm—the tensor power method. We show that
the tensor power method with random initialization converges to one of the factors with small residual error for
rank k = o(d), where d is the dimension. We also show that
the convergence rate is quadratic in the dimension. Anandkumar et al. (2014c) had previously shown local convergence of the tensor power method with a linear convergence rate (and also showed global convergence via a SVDbased initialization scheme, obtaining the first guarantees
for the tensor power method in non-orthogonal settings).
Our new results, particularly global convergence from random initialization, provide some deeper insights into the
behavior of this popular algorithm.
The rest of the paper is organized as follows—Section 2
states the notation. In Section 3 we discuss related work.
Section 4 introduces Orth-ALS, and states the convergence
guarantees. We state our convergence results for the tensor
power method in Section 4.2. The experimental results, on
both synthetic data and the NLP tasks are discussed in Section 5. Proof details have been deferred to the Appendix.

2. Notation
We state our algorithm and results for 3rd order tensors,
and believe the algorithm and analysis techniques should
extend easily to higher dimensions. Given a 3rd order tensor T ∈ Rd×d×d our task is to decompose
the tensor into its
P
factor matrices A, B and C: T = i∈[k] wi Ai ⊗ Bi ⊗ Ci ,
where Ai denotes the ith column of a matrix A. Here
wi ∈ R, Ai , Bi , Ci ∈ Rd and ⊗ denotes the tensor product: if a, b, c ∈ Rd then a ⊗ b ⊗ c ∈ Rd×d×d and
(a ⊗ b ⊗ c)ijk = ai bj ck . We will refer to wi as the weight
of the factor {Ai , Bi , Ci }. This is also known as CP decomposition. We refer to the dimension of the tensor by d
and denote its rank by k. We refer to different dimensions
of a tensor as the modes of the tensor.
We denote T(n) as the mode n matricization of the tensor,
which is the flattening of the tensor along the nth direction
obtained by stacking all the matrix slices together. For example T(1) denotes flattening of a tensor T ∈ Rn×m×p to

Orthgonalized ALS for Tensor Decomposition

a (n × mp) matrix. We denote the Khatri-Rao product of
two matrices A and B as (A  B)i = (Ai ⊗ Bi )(1) , where
(Ai ⊗ Bi )(1) denotes the flattening of the matrix Ai ⊗ Bi
into a row vector. For anyP
tensor T and vectors a, b, c, we
also define T (a, b, c) =
i,j,k Tijk ai bj ck . Throughout,
we say f (n) = Õ(g(n)) if f (n) = O(g(n)) up to polylogarithmic factors.
Though all algorithms in the paper extend to asymmetric
tensors, we prove convergence results under the symmetric setting where A = B = C. Similar to other works
(Tang & Shah, 2015; Anandkumar et al., 2014c; Ma et al.,
2016), our guarantees depend on the incoherence of the
factor matrices (cmax ), defined to be the maximum correlation in absolute value between any two factors, i.e.
cmax = maxi6=j |ATi Aj |. This serves as a natural assumption to simplify the problem as it is NP-Hard in the worst
case. Also, tensors
with randomly drawn factors satisfy
√
cmax ≤ Õ(1/ d), and our results hold for such tensors.

3. Background and Related Work
We begin the section with a brief discussion of related work
on tensor decomposition. We then review the ALS algorithm and the tensor power method and discuss their basic
properties. Our proposed tensor decomposition algorithm,
Orth-ALS, builds on these algorithms.
3.1. Related Work on Tensor Decomposition
Though it is not possible for us to do justice to the substantial body of work on tensor decomposition, we will review
three families of algorithms which are distinct from alternating minimization approaches such as ALS and the tensor power method. Many algorithms have been proposed
for guaranteed decomposition of orthogonal tensors, we
refer the reader to Anandkumar et al. (2014b); Kolda &
Mayo (2011); Comon et al. (2009); Zhang & Golub (2001).
However, obtaining guaranteed recovery of non-orthogonal
tensors using algorithms for orthogonal tensors requires
converting the tensor into an orthogonal form (known as
whitening) which is ill conditioned in high dimensions (Le
et al., 2011; Souloumiac, 2009), and is computationally
the most expensive step (Huang et al., 2013). Another
very interesting line of work on tensor decompositions is
to use simultaneous diagonalization and higher order SVD
(Colombo & Vlassis, 2016; Kuleshov et al., 2015; De Lathauwer, 2006) but these are not as computationally efficient
as alternating minimization2 . Recently, there has been in2

De Lathauwer (2006) prove unique recovery under very general conditions, but their algorithm is quite complex and requires
solving a linear system of size O(d4 ), which is prohibitive for
large tensors. We ran the simultaneous diagonalization algorithm
of Kuleshov et al. (2015) on a dimension 100, rank 30 tensor; and
the algorithm needed around 30 minutes to run, whereas OrthALS converges in less than 5 seconds.

triguing work on provably decomposing random tensors
using the sum-of-squares approach (Ma et al., 2016; Hopkins et al., 2016; Tang & Shah, 2015; Ge & Ma, 2015).
Ma et al. (2016) show that a sum-of-squares based relaxation can decompose highly overcomplete random tensors
of rank up to o(d1.5 ). Though these results establish the
polynomial learnability of the problem, they are unfortunately not practical.
Very recently, there has been exciting work on scalable tensor decomposition algorithms using ideas such as sketching (Song et al., 2016; Wang et al., 2015b) and contraction
of tensor problems to matrix problems (Shah et al., 2015).
Also worth noting are recent approaches to speedup ALS
via sampling and randomized least squares (Battaglino
et al., 2017; Cheng et al., 2016; Papalexakis et al., 2012).
3.2. Alternating Least Squares (ALS)
ALS is the most widely used algorithm for tensor decomposition and has been described as the “workhorse” for tensor
decomposition (Kolda & Bader, 2009). The algorithm is
conceptually very simple: if the goal is to recover a rank-k
tensor, ALS maintains a rank-k decomposition specified by
three sets of d × k dimensional matrices {Â, B̂, Ĉ} corresponding to the three modes of the tensor. ALS will iteratively fix two of the three modes, say Â and B̂, and
then update Ĉ by solving a least-squared regression problem to find the best approximation to the underlying tensor
T having factors Â and B̂ in the first two modes, namely
Ĉnew = arg minC 0 kT − Â⊗ B̂ ⊗ Ĉ 0 k2 . ALS will then continue to iteratively fix two of the three modes, and update
the other mode via solving the associated least-squares regression problem. These updates continue until some stopping condition is satisfied—typically when the squared error of the approximation is no longer decreasing, or when a
fixed number of iterations have elapsed. The factors used in
ALS are either chosen uniformly at random, or via a more
expensive initialization scheme such as SVD based initialization (Anandkumar et al., 2014c). In the SVD based
scheme, the factors are initialized to be the singular vectors of a random projection of the tensor onto a matrix.
The main advantages of the ALS approach, which have led
to its widespread use in practice are its conceptual simplicity, noise robustness and computational efficiency given its
graceful handling of sparse tensors and ease of parallelization. There are several publicly available optimized packages implementing ALS, such as Kossaifi et al. (2016);
Vervliet et al.; Bader et al. (2012); Bader & Kolda (2007);
Smith & Karypis; Huang et al. (2014); Kang et al. (2012).
Despite the advantages, ALS does not have any global
convergence guarantees and can get stuck in local optima
(Comon et al., 2009; Kolda & Bader, 2009), even under
very realistic settings. For example, consider a setting
where the weights wi for the factors {Ai , Bi , Ci } decay

Orthgonalized ALS for Tensor Decomposition

according to a power-law, hence the first few factors have
much larger weight than the others. As we show in the experiments (see Fig. 2), ALS fails to recover the low-weight
factors. Intuitively, this is because multiple recovered factors will be chasing after the same high weight factor, leading to a bad local optima.

expressed in compact tensor notation, for instance step 4
can be equivalently stated as X = arg minC 0 kT − Â ⊗
B̂ ⊗ Ĉ 0 k2 . Similarly, step 9 is the least squares estimate of
the weight wi of each rank-1 component Âi ⊗ B̂i ⊗ Ĉi .

3.3. Tensor Power Method

Input: Tensor T ∈ Rd×d×d , number of iterations N .

The tensor power method is a special case of ALS that only
computes a rank-1 approximation. The procedure is then
repeated multiple times to recover different factors. The
factors recovered in different iterations of the algorithm are
then clustered to determine the set of unique factors. Different initialization strategies have been proposed for the
tensor power method. Anandkumar et al. (2014c) showed
that the tensor power method converges locally (i.e. for
a suitably chosen initialization) for random tensors with
rank o(d1.5 ). They also showed that a SVD based initialization strategy gives good starting points and used this
to prove global convergence for random tensors with rank
O(d). However, the SVD based initialization strategy can
be computationally expensive, and our experiments suggest
that even SVD initialization fails in the setting where the
weights decay according to a power-law (see Fig. 2).
In this work, we prove global convergence guarantees with
random initializations for the tensor power method for random and worst-case incoherent tensors. Our results also
demonstrate how, with random initialization, the tensor
power method converges to the factor having the largest
product of weight times the correlation of the factor with
the random initialization vector. This explains the difficulty
of using random initialization to recover factors with small
weight. For example, if one factor has weight less than a
1/c fraction of the weight of, say, the heaviest k/2 factors,
2
then with high probability we would require at least k Θ(c )
random initializations to recover this factor. This is because
the correlation between random vectors in high dimensions
is approximately distributed as a Normal random variable
and if k/2+1 samples are drawn from the standard Normal
distribution, the probability that one particular sample is at
least a factor of c larger than the other k/2 other samples
2
scales as roughly k −Θ(c ) .

4. The Algorithm: Orthogonalized
Alternating Least Squares (Orth-ALS)
In this section we introduce Orth-ALS, which combines
the computational benefits of standard ALS and the provable recovery of the tensor power method, while avoiding
the difficulties faced by both when factors have different
weights. Orth-ALS is a simple modification of standard
ALS that adds an orthogonalization step before each set of
ALS steps. We describe the algorithm below. Note that
steps 4-6 are just the solution to the least squares problem

Algorithm 1 Orthogonalized ALS (Orth-ALS)

1: Initialize each column of Â, B̂ and Ĉ ∈ Rd×k uni-

formly from the unit sphere
2: for t = 1 : N do
3:
Find QR decomposition of Â, set Â = Q. Orthogo4:
5:
6:
7:
8:
9:
10:

nalize B̂ and Ĉ analogously.
X = T(1) (Ĉ  B̂)
Y = T(2) (Ĉ  Â)
Z = T(3) (B̂  Â)
Normalize X, Y, Z and store results in Â, B̂, Ĉ
end for
Estimate weights ŵi = T (Âi , B̂i , Ĉi ), ∀ i ∈ [k].
return Â, B̂, Ĉ, ŵ

To get some intuition for why the orthogonalization makes
sense, let us consider the more intuitive matrix factorization
problem, where the goal is to compute the eigenvectors of
a matrix. Subspace iteration is a straightforward extension
of the matrix power method to recover all eigenvectors at
once. In subspace iteration, the matrix of eigenvector estimates is orthogonalized before each power method step
(by projecting the second eigenvector estimate orthogonal
to the first one and so on), because otherwise all the vectors
would converge to the dominant eigenvector. For the case
of tensors, the vectors would not all necessarily converge
to the dominant factor if the initialization is good, but with
high probability a random initialization would drive many
factors towards the larger weight factors. The orthogonalization step is a natural modification which forces the estimates to converge to different factors, even if some factors
are much larger than the others. It is worth stressing that
the orthogonalization step does not force the final recovered factors to be orthogonal (because the ALS step follows
the orthogonalization step) and in general the factors output will not be orthogonal (which is essential for accurately
recovering the factors).
From a computational perspective, adding the orthogonalization step does not add to the computational cost as the
least squares updates in step 4-6 of Algorithm 1 involve an
extra pseudoinverse term for standard ALS, which evaluates to identity for Orth-ALS and does not have to be computed. The cost of orthogonalization is O(k 2 d), while the
cost of computing the pseudoinverse is also O(k 2 d). We
also observe significant speedups in terms of the number of
iterations required for convergence for Orth-ALS as compared to standard ALS in our simulations on random tensors (see the experiments in Section 5).

Orthgonalized ALS for Tensor Decomposition

Variants of Orthogonalized ALS. Several other modifications to the simple orthogonalization step also seem natural. Particularly for low-dimensional settings, in practice
we found that it is useful to carry out orthogonalization
for a few steps and then continue with standard ALS updates until convergence (we call this variant Hybrid-ALS).
Hybrid-ALS also gracefully reverts to standard ALS in settings where the factors are highly correlated and orthogonalization is not helpful.
4.1. Performance Guarantees
We now state the formal guarantees on the performance of
Orthogonalized ALS. The specific variant of Orthogonalized ALS that our theorems apply to is a slight modification
of Algorithm 1, and differs in that there is a periodic (every
log k steps) re-randomization of the factors for which our
analysis has not yet guaranteed convergence. In our practical implementations, we observe that all factors seem to
converge within this first log k steps, and hence the subsequent re-randomization is unnecessary.

for random tensors, provided an SVD based initialization
is employed.
Theorem
2. Consider a d-dimensional rank k tensor T =
Pk
i=1 wi Ai ⊗ Ai ⊗ Ai with the factors Ai sampled unimax
formly from the d-dimensional sphere. Define γ = w
wmin
to be the ratio of the largest and smallest weight. Assume k ≤ o(d) and γ ≤ polylog(d). If the initialization
x0 ∈ Rd is chosen uniformly from the unit sphere, then with
high probability the tensor power method updates converge
to one of the true factors (say A1 ) in O(log log d) steps,
and the
√ error at convergence satisfies k A1 − Â1 k2 ≤
Õ(1/ d). Also,√the estimate of the weight ŵ1 satisfies
1
|1 − ŵ
w1 | ≤ Õ(1/ d).
Theorem 2 provides guarantees for random tensors, but it
is natural to ask if there are deterministic conditions on the
tensors which guarantee global convergence of the tensor
power method. Our analysis also allows us to obtain a clean
characterization for global convergence of the tensor power
method updates for worst-case tensors in terms of the incoherence of the factor matrix—

Theorem
1. Consider a d-dimensional rank k tensor T =
Pk
T
w
A
i
i ⊗ Ai ⊗ Ai . Let cmax = maxi6=j |Ai Aj | be
i=1
max
the incoherence between the true factors and γ = w
wmin
be the ratio of the largest and smallest weight. Assume
γcmax ≤ o(k −2 ), and the estimates of the factors are initialized randomly from the unit sphere. Provided that, at
the i(log k + log log d)th step of the algorithm the estimates for all but the first i factors are re-randomized, then
with high probability the orthogonalized ALS updates converge to the true factors in O(k(log k + log log d)) steps,
and the error at convergence satisfies (up to relabelling)
i
k Ai − Âi k22 ≤ O(γk max{c2max , 1/d2 }) and |1 − ŵ
wi | ≤
O(max{cmax , 1/d}), for all i.

Theorem
3. Consider a d-dimensional rank k tensor T =
Pk
T
i=1 wi Ai ⊗ Ai ⊗ Ai . Let cmax = maxi6=j |Ai Aj |
wmax
and γ = wmin be the ratio of the largest and smallest weight, and assume γcmax ≤ o(k −2 ). If the initialization x0 ∈ Rd is chosen uniformly from the unit
sphere, then with high probability the tensor power method
updates converge to one of the true factors (say A1 ) in
O(log k + log log d) steps, and the error at convergence
satisfies k A1 − Â1 k22 ≤ O(γk max{c2max , 1/d2 }) and
1
|1 − ŵ
w1 | ≤ O(max{cmax , 1/d}).

Theorem 1 immediately gives convergence guarantees for
random low rank tensors.
For random d dimensional ten√
sors, cmax = O(1/ d); therefore Orth-ALS converges
globally with random initialization whenever k = o(d0.25 ).
If the tensor has rank much smaller than the dimension,
then our analysis can tolerate significantly higher correlation between the factors. In the Appendix, we also prove
Theorem 1 for the special and easy case of orthogonal tensors, which nevertheless highlights the key proof ideas.

We compare the performance of Orth-ALS, standard ALS
(with random and SVD initialization), the tensor power
method, and the classical eigendecomposition approach,
through experiments on low rank tensor recovery in a few
different parameter regimes, on a overcomplete tensor decomposition task and a tensor completion task. We also
compare the factorization of Orth-ALS and standard ALS
on a large real-world tensor of word tri-occurrence based
on the 1.5 billion word English Wikipedia corpus.3

4.2. New Guarantees for the Tensor Power Method

5.1. Experiments on Random Tensors

As a consequence of our analysis of the orthogonalized
ALS algorithm, we also prove new guarantees on the tensor power method. As these may be of independent interest
because of the wide use of the tensor power method, we
summarize them in this section. We show a quadratic rate
of convergence (in O(log log d) steps) with random initialization for random tensors having rank k = o(d). This
contrasts with the analysis of Anandkumar et al. (2014c)
who showed a linear rate of convergence (O(log d) steps)

Recovering low rank tensors: We explore the abilities
of Orth-ALS, standard ALS, and the tensor power method
(TPM), to recover a low rank (rank k) tensor that has been
constructed by independently drawing each of the k factors
independently and uniformly at random from the d dimensional unit spherical shell. We consider several different

5. Experiments

3

MATLAB, Python and C code for Orth-ALS and HybridALS is available at http://web.stanford.edu/
˜vsharan/orth-als.html

Orthgonalized ALS for Tensor Decomposition

combinations of the dimension, d, and rank, k. We also
consider both the setting where all of the factors are equally
weighted, as well as the practically relevant setting where
the factor weights decay geometrically, and consider the
setting where independent Gaussian noise has been added
to the low-rank tensor.
In addition to random initialization for standard ALS and
the TPM, we also explore SVD based initialization (Anandkumar et al., 2014c) where the factors are initialized via
SVD of a projection of the tensor onto a matrix. We also
test the classical technique for tensor decomposition via simultaneous diagonalization (Leurgans et al., 1993; Harshman, 1970) (also known as Jennrich’s algorithm, we refer
to it as Sim-Diag), which first performs two random projections of the tensor, and then recovers the factors by an
eigenvalue decomposition of the projected matrices. This
gives guaranteed recovery when the tensors are noiseless
and factors are linearly independent, but is extremely unstable to perturbations.
We evaluate the performance in two respects: 1) the ability
of the algorithms to recover a low-rank tensor that is close
to the input tensor, and 2) the ability of the algorithms to
recover accurate approximations of many of the true factors. Fig. 1 depicts the performance via the first metric.
We evaluate the performance in terms of the discrepancy
between the input low-rank tensor, and the low-rank tensor
recovered by the algorithms, quantified via the ratio of the
Frobenius norm of the residual, to the Frobenius norm of
the actual tensor: kTkT−kT̂FkF , where T̂ is the recovered tensor.
Since the true tensor has rank k, the inability of an algorithm to drive this error to zero indicates the presence of
local optima. Fig. 1 depicts the performance of Orth-ALS,
standard ALS with random initialization and the hybrid algorithm that performs Orth-ALS for the first five iterations
before reverting to standard ALS (Hybrid-ALS). Tests are
conducted in both the setting where factor weights are uniform, as well as a geometric spacing, where the ratio of the
largest factor weight to the smallest is 100. Fig. 1 shows
that Hybrid ALS and Orth-ALS have much faster convergence and find a significantly better fit than standard ALS.
Fig. 2 quantifies the performance of the algorithms in terms
of the number of the original factors that the algorithms
accurately recover. We use standard ALS, Orth-ALS (Algorithm 1), Hybrid-ALS, TPM with random initialization
(TPM), ALS with SVD initialization (ALS-SVD), TPM
with SVD initialization (TPM-SVD) and the simultaneous
diagonalization approach (Sim-Diag). We run TPM and
SVD-TPM with 100 different initializations and find a rank
k = 30 decomposition for ALS, ALS-SVD, Orth-ALS,
Hybrid-ALS and Sim-Diag. We repeat the experiment (by
sampling a new tensor) 10 times. We perform this evaluation in both the setting where we receive an actual low-

rank tensor as input, as well as the setting where each entry Tijk of the low-rank tensor has been perturbed by independent Gaussian noise of standard deviation equal to
0.05Tijk . We can see that Orth-ALS and Hybrid-ALS perform significantly better than the other algorithms and are
able to recover all factors in the noiseless case even when
the weights are highly skewed. Note that the reason the
Hybrid-ALS and Orth-ALS fail to recover all factors in the
noisy case when the weights are highly skewed is that the
magnitude of the noise essentially swamps the contribution
from the smallest weight factors.
Recovering over-complete tensors: Overcomplete tensors are tensors with rank higher than the dimension, and
have found numerous theoretical applications in learning
latent variable models (Anandkumar et al., 2015). Even
though orthogonalization cannot be directly applied to the
setting where the rank is more than the dimension (as the
factors can no longer be orthogonalized), we explore a deflation based approach in this setting. Given a tensor T with
dimension d = 50 and rank r > d, we find a rank d decomposition T1 of T , subtract T1 from T , and then compute a
rank d decomposition of T1 to recover the next set of d factors. We repeat this process to recover subsequent factors.
After every set of d factors has been estimated, we also refine the factor estimates of all factors estimated so far by
running an additional ALS step using the current estimates
of the extracted factors as the initialization. Fig. 3a plots
the number of factors recovered when this deflation based
approach is applied to a dimension d = 50 tensor with a
mild power low distribution on weights. We can see that
Hybrid-ALS is successful at recovering tensors even in the
overcomplete setup, and gives an improvement over ALS.
Tensor completion: We also test the utility of orthogonalization on a tensor completion task, where the goal is to
recover a large missing fraction of the entries. Fig. 3b suggests Hybrid-ALS gives considerable improvements over
standard ALS. Further examining the utility of orthogonalization in this important setting, in theory and practice,
would be an interesting direction.
5.2. Learning Word Embeddings via Tensor
Factorization
A word embedding is a vector representation of words
which preserves some of the syntactic and semantic relationships in the language. Current methods for learning
word embeddings implicitly (Mikolov et al., 2013b; Levy
& Goldberg, 2014) or explicitly (Pennington et al., 2014)
factorize some matrix derived from the matrix of word cooccurrences M , where Mij denotes how often word i appears with word j. We explore tensor methods for learning
word embeddings, and contrast the performance of standard ALS and Orthogonalized ALS on standard tasks.

Orthgonalized ALS for Tensor Decomposition

0.3
0.2
0.1
0

10

Iteration

20

0.4
0.3
0.2
0.1
0

30

(a) k = 30, d = 100,
uniform weights

Normalized Error

0.4

0.6
Hybrid−ALS
Orth−ALS
ALS

0.5

10

Iteration

20

30

(b) k = 30, d = 100,
wmax
= 100
wmin

0.6
Hybrid−ALS
Orth−ALS
ALS

0.5

Normalized Error

0.6

Hybrid−ALS
Orth−ALS
ALS

0.5

Normalized Error

Normalized Error

0.6

0.4
0.3
0.2
0.1
0

10

Iteration

20

0.4
0.3
0.2
0.1
0

30

(c) k = 100, d = 1000,
uniform weights

Hybrid−ALS
Orth−ALS
ALS

0.5

10

Iteration

20

30

(d) k = 100, d = 1000,
wmax
= 100
wmin

−T̂ kF
Figure 1. Plot of the normalized discrepancy between the recovered rank k tensor T̂ and the true tensor T : kTkT
, as a function of the
kF
iteration. In all settings, the Orth-ALS and the hybrid algorithm drive this discrepancy nearly to zero, with the performance of Orth-ALS
improving for the higher dimensional cases, whereas standard ALS algorithm has slower convergence and gets stuck in bad local optima.

30
No of factors recovered

No of factors recovered

30
25
20
15

Hybrid−ALS/
Orth−ALS/
Sim−Diag
ALS−SVD
ALS
TPM−SVD
TPM

10
5
0

1

10
100
Ratio of weights

20
15

wmax
wmin

Hybrid−ALS/
Orth−ALS
ALS−SVD
ALS
TPM−SVD
TPM
Sim−Diag

10
5
0

1000

(a) Noiseless case, ratio of weights equals

25

1

10
100
Ratio of weights

1000

(b) Noisy case, ratio of weights equals

wmax
wmin

max
, the ratio of the maximum factor
Figure 2. Average number of factors recovered by different algorithms for different values of w
wmin
weight to minimum factor weight (with the weights spaced geometrically), along with error bars for the standard deviation in the number
of factors recovered, across independent trials. The true rank k = 30, and the dimension d = 100. We say a factor {Ai , Bi , Ci } of the
tensor T is successfully recovered if there exists at least one recovered factor {Âj , B̂j , Ĉj } with correlation at least 0.9 in all modes.
Orth-ALS and Hybrid-ALS recover all factors in almost all settings, whereas ALS and the tensor power method struggle when the
weights are skewed, even with the more expensive SVD based initialization.

ALS
Hybrid-ALS

12.5%

300
200
Rank
ALS
Hybrid−ALS

100

Normalized MSE

10%
7.5%
5.0%
2.5%

350

400

(a) No. of factors recovered for a dimension d = 50
tensor with varying rank. The weights of the factors
are geometrically spaced and the ratio of the weights
between every pair of consecutive factors is 1.05

4

3

2

0.

300

0.

250
Rank

0.

200

06
0.
1

150

0.

100

02

0%

0

0.

No. of factors recovered

400

Sampling probability (p)

(b) Average error on the missing entries for tensor
completion where each entry is sampled with probability p, on a 100 different runs with each setting of p.
The tensor has dimension d = 50 and rank k = 10.

Figure 3. Experiments on overcomplete tensors and tensor completion. Even though our theoretical guarantees do not apply to these
settings, we see that orthogonalization leads to significantly better performance over standard ALS.

Orthgonalized ALS for Tensor Decomposition

Methodology. We used the English Wikipedia as our corpus, with 1.5 billion words. We constructed a word cooccurrence tensor T of the 10,000 most frequent words,
where the entry Tijk denotes the number of times the words
i, j and k appear in a sliding window of length w across the
corpus. We consider two different window lengths, w = 3
and w = 5. Before factoring the tensor, we apply the
non-linear element-wise scaling f (x) = log(1 + x) to the
tensor. This scaling is known to perform well in practice
for co-occurrence matrices (Pennington et al., 2014), and
makes some intuitive sense in light of the Zipfian distribution of word frequencies. Following the application of this
element-wise nonlinearity, we recover a rank 100 approximation of the tensor using Orth-ALS or ALS.
We concatenate the (three) recovered factor matrices into
one matrix and normalize the rows. The ith row of this
matrix is then the embedding for the ith word. We test the
quality of these embeddings on two tasks aimed at measuring the syntactic and semantic structure captured by these
word embeddings.
We also evaluated the performance of matrix SVD based
methods on the task. For this, we built the co-occurrence
matrix M with a sliding window of length w over the corpus. We applied the same non-linear element-wise scaling
and performed a rank 100 SVD, and set the word embeddings to be the singular vectors after row normalization.
It is worth highlighting some implementation details for
our experiments, as they indicate the practical efficiency
and scalability inherited by Orth-ALS from standard ALS.
Our experiments were run on a cluster with 8 cores and
48 GB of RAM memory per core. Most of the runtime
was spent in reading the tensor, the runtime for Orth-ALS
was around 80 minutes, with 60 minutes spent in reading
the tensor (the runtime for standard ALS was around 100
minutes because it took longer to converge). Since storing
a dense representation of the 10,000×10,000×10,000 tensor is too expensive, we use an optimized ALS solver for
sparse tensors (Smith & Karypis; 2015) which also has an
efficient parallel implementation.
Evaluation: Similarity and Analogy Tasks. We evaluated the quality of the recovered word embeddings produced by the various methods via their performance on
two different NLP tasks for which standard, human-labeled
data exists: estimating the similarity between a pair of
words, and completing word analogies.
The word similarity tasks (Bruni et al., 2012; Finkelstein
et al., 2001) contain word pairs along with human assigned
similarity scores, and the objective is to maximize the correlation between the similarity in the embeddings of the
two words (according to a similarity metric such as the dot
product) and human judged similarity.

Algorithm

Similarity tasks

Analogy tasks

Standard ALS, w = 3
Standard ALS, w = 5

0.50
0.50

30.92%
37.38%

Orth-ALS, w = 3
Orth-ALS, w = 5

0.59
0.60

40.00%
46.37%

Matrix methods, w = 3
Matrix methods, w = 5

0.68
0.67

53.29%
57.40%

Table 1. Results for word analogy and word similarity tasks for
different window lengths w over which the co-occurrences are
counted. The embeddings recovered by Orth-ALS are significantly better than those recovered by standard ALS. Despite
this, embeddings derived from word co-occurrences using matrix SVD still outperform the tensor embeddings, and we are unsure whether this is due to the relative sparsity of the tensor, suboptimal element-wise scaling (i.e. the f (x) = log(1+x) function
applied to the counts), or something more fundamental.

The word analogy tasks (Mikolov et al., 2013a;c) present
questions of the form “a is to a∗ as b is to ?” (e.g. “Paris
is to France as Rome is to ?”). We find the answer to “a
is to a∗ as b is to b∗ ” by finding the word whose embedding
is the closest to wa∗ − wa + wb in cosine similarity, where
wa denotes the embedding of the word a.
Results. The performances are summarized in the Table
1. The use of Orth-ALS rather than standard ALS leads to
significant improvement in the quality of the embeddings
as judged by the similarity and analogy tasks. However,
the matrix SVD method still outperforms the tensor based
methods. We believe that it is possible that better tensor
based approaches (e.g. using better renormalization, additional data, or some other tensor rather than the symmetric tri-occurrence tensor) or a combination of tensor and
matrix based methods can actually improve the quality of
word embeddings, and is an interesting research direction.
Alternatively, it is possible that natural language does not
contain sufficiently rich higher-order dependencies among
words that appear close together, beyond the co-occurrence
structure, to truly leverage the power of tensor methods.
Or, perhaps, the two tasks we evaluated on—similarity and
analogy tasks—do not require this higher order. In any
case, investigating these possibilities seems worthwhile.

6. Conclusion
Our results suggest the theoretical and practical benefits of
Orthogonalized ALS, versus standard ALS. An interesting
direction for future work would be to more thoroughly examine the practical and theoretical utility of orthogonalization for other tensor-related tasks, such as tensor completion. Additionally, its seems worthwhile to investigate
Orthogonalized ALS or Hybrid ALS in more applicationspecific domains, such as natural language processing.

Orthgonalized ALS for Tensor Decomposition

References
Anandkumar, Animashree, Liu, Yi-kai, Hsu, Daniel J, Foster, Dean P, and Kakade, Sham M. A spectral algorithm
for latent dirichlet allocation. In Advances in Neural Information Processing Systems, pp. 917–925, 2012.
Anandkumar, Animashree, Ge, Rong, Hsu, Daniel, and
Kakade, Sham M. A tensor approach to learning mixed
membership community models. The Journal of Machine Learning Research, 15(1):2239–2312, 2014a.
Anandkumar, Animashree, Ge, Rong, Hsu, Daniel,
Kakade, Sham M, and Telgarsky, Matus. Tensor decompositions for learning latent variable models. Journal of
Machine Learning Research, 15(1):2773–2832, 2014b.
Anandkumar, Animashree, Ge, Rong, and Janzamin, Majid. Guaranteed non-orthogonal tensor decomposition via alternating rank-1 updates. arXiv preprint
arXiv:1402.5180, 2014c.
Anandkumar, Animashree, Ge, Rong, and Janzamin, Majid. Learning overcomplete latent variable models
through tensor methods. In Proceedings of The 28th
Conference on Learning Theory, pp. 36–112, 2015.
Azizzadenesheli, Kamyar, Lazaric, Alessandro, and
Anandkumar, Animashree. Reinforcement learning of
POMDPs using spectral methods. In 29th Annual Conference on Learning Theory, pp. 193–256, 2016.
Bader, Brett W. and Kolda, Tamara G. Efficient MATLAB
computations with sparse and factored tensors. SIAM
Journal on Scientific Computing, 30(1), December 2007.
Bader, Brett W., Kolda, Tamara G., et al. Matlab tensor
toolbox version 2.5. Available online, January 2012.
Battaglino, Casey, Ballard, Grey, and Kolda, Tamara G. A
practical randomized CP tensor decomposition. arXiv
preprint arXiv:1701.06600, 2017.
Bruni, Elia, Boleda, Gemma, Baroni, Marco, and Tran,
Nam-Khanh. Distributional semantics in technicolor. In
Proceedings of the 50th Annual Meeting of the Association for Computational Linguistics, 2012.
Chaganty, Arun Tejasvi and Liang, Percy. Estimating
latent-variable graphical models using moments and
likelihoods. In ICML, pp. 1872–1880, 2014.
Cheng, Dehua, Peng, Richard, Liu, Yan, and Perros,
Ioakeim. SPALS: Fast alternating least squares via implicit leverage scores sampling. In Advances In Neural
Information Processing Systems, pp. 721–729, 2016.
Colombo, Nicolo and Vlassis, Nikos. FastMotif: spectral
sequence motif discovery. Bioinformatics, 31(16), 2015.

Colombo, Nicolo and Vlassis, Nikos. Tensor decomposition via joint matrix schur decomposition. In Proceedings of The 33rd International Conference on Machine
Learning, pp. 2820–2828, 2016.
Comon, Pierre, Luciani, Xavier, and De Almeida,
André LF. Tensor decompositions, alternating least
squares and other tales. Journal of chemometrics, 23
(7-8):393–405, 2009.
De Lathauwer, Lieven. A link between the canonical decomposition in multilinear algebra and simultaneous matrix diagonalization. SIAM journal on Matrix Analysis
and Applications, 28(3):642–666, 2006.
Duembgen, Lutz. Bounding standard gaussian tail probabilities. arXiv preprint arXiv:1012.2063, 2010.
Finkelstein, Lev, Gabrilovich, Evgeniy, Matias, Yossi,
Rivlin, Ehud, Solan, Zach, Wolfman, Gadi, and Ruppin,
Eytan. Placing search in context: The concept revisited.
In Proceedings of the 10th international conference on
World Wide Web, pp. 406–414. ACM, 2001.
Ge, Rong and Ma, Tengyu. Decomposing overcomplete
3rd order tensors using sum-of-squares algorithms. Approximation, Randomization, and Combinatorial Optimization. Algorithms and Techniques, pp. 829, 2015.
Ge, Rong, Huang, Qingqing, and Kakade, Sham M. Learning mixtures of gaussians in high dimensions. In Proceedings of the Forty-Seventh Annual ACM on Symposium on Theory of Computing, pp. 761–770. ACM, 2015.
Harshman, Richard A. Foundations of the parafac procedure: Models and conditions for an” explanatory” multimodal factor analysis. 1970.
Håstad, Johan. Tensor rank is NP-Complete. Journal of
Algorithms, 11(4):644–654, 1990.
Hillar, Christopher J and Lim, Lek-Heng. Most tensor
problems are NP-Hard. Journal of the ACM, 60(6), 2013.
Hopkins, Samuel B, Schramm, Tselil, Shi, Jonathan, and
Steurer, David. Fast spectral algorithms from sumof-squares proofs: tensor decomposition and planted
sparse vectors. In Proceedings of the 48th Annual ACM
SIGACT Symposium on Theory of Computing, 2016.
Huang, Furong, Niranjan, UN, Hakeem, Mohammad Umar, and Anandkumar, Animashree. Fast detection of overlapping communities via online tensor methods. arXiv preprint arXiv:1309.0787, 2013.
Huang, Furong, Matusevych, Sergiy, Anandkumar, Anima,
Karampatziakis, Nikos, and Mineiro, Paul. Distributed
latent dirichlet allocation via tensor factorization. In
NIPS Optimization Workshop, 2014.

Orthgonalized ALS for Tensor Decomposition

Kang, U, Papalexakis, Evangelos, Harpale, Abhay, and
Faloutsos, Christos. Gigatensor: scaling tensor analysis
up by 100 times-algorithms and discoveries. In Proceedings of the 18th ACM SIGKDD international conference
on Knowledge discovery and data mining. ACM, 2012.

Papalexakis, Evangelos E, Faloutsos, Christos, and
Sidiropoulos, Nicholas D. Parcube: Sparse parallelizable tensor decompositions. In Joint European Conference on Machine Learning and Knowledge Discovery in
Databases, pp. 521–536. Springer, 2012.

Kolda, Tamara G and Bader, Brett W. Tensor decompositions and applications. SIAM review, 51(3), 2009.

Pennington, Jeffrey, Socher, Richard, and Manning,
Christopher D. Glove: Global vectors for word representation. In Empirical Methods in Natural Language
Processing (EMNLP), pp. 1532–1543, 2014.

Kolda, Tamara G and Mayo, Jackson R. Shifted power
method for computing tensor eigenpairs. SIAM Journal
on Matrix Analysis and Applications, 32(4), 2011.
Kossaifi, Jean, Panagakis, Yannis, and Pantic, Maja. Tensorly: Tensor learning in python.
arXiv preprint
arXiv:1610.09555, 2016.
Kruskal, Joseph B. Three-way arrays: rank and uniqueness
of trilinear decompositions, with application to arithmetic complexity and statistics. Linear algebra and its
applications, 18(2):95–138, 1977.
Kuleshov, Volodymyr, Chaganty, Arun Tejasvi, and Liang,
Percy. Tensor factorization via matrix factorization. In
AISTATS, 2015.
Le, Quoc V, Karpenko, Alexandre, Ngiam, Jiquan, and Ng,
Andrew Y. ICA with reconstruction cost for efficient
overcomplete feature learning. In Advances in Neural
Information Processing Systems, pp. 1017–1025, 2011.
Leurgans, SE, Ross, RT, and Abel, RB. A decomposition
for three-way arrays. SIAM Journal on Matrix Analysis
and Applications, 14(4):1064–1083, 1993.
Levy, Omer and Goldberg, Yoav. Neural word embedding
as implicit matrix factorization. In Advances in Neural
Information Processing Systems, pp. 2177–2185, 2014.
Ma, Tengyu, Shi, Jonathan, and Steurer, David.
Polynomial-time tensor decompositions with sum-ofsquares. In Foundations of Computer Science (FOCS),
2016 IEEE 57th Annual Symposium on, 2016.
Mikolov, Tomas, Chen, Kai, Corrado, Greg, and Dean, Jeffrey. Efficient estimation of word representations in vector space. arXiv preprint arXiv:1301.3781, 2013a.
Mikolov, Tomas, Sutskever, Ilya, Chen, Kai, Corrado,
Greg S, and Dean, Jeff. Distributed representations of
words and phrases and their compositionality. In Advances in Neural Information Processing Systems, pp.
3111–3119, 2013b.
Mikolov, Tomas, Yih, Wen-tau, and Zweig, Geoffrey. Linguistic regularities in continuous space word representations. In HLT-NAACL, pp. 746–751, 2013c.

Shah, Parikshit, Rao, Nikhil, and Tang, Gongguo. Sparse
and low-rank tensor decomposition. In Advances in Neural Information Processing Systems, 2015.
Smith, Shaden and Karypis, George. SPLATT: The Surprisingly ParalleL spArse Tensor Toolkit.
Smith, Shaden and Karypis, George. DMS: Distributed
sparse tensor factorization with alternating least squares.
Technical report, 2015.
Song, Zhao, Woodruff, David, and Zhang, Huan. Sublinear
time orthogonal tensor decomposition. In Advances in
Neural Information Processing Systems, 2016.
Souloumiac, Antoine. Joint diagonalization: Is nonorthogonal always preferable to orthogonal? In 3rd
IEEE International Workshop on Computational Advances in Multi-Sensor Adaptive Processing, 2009.
Tang, Gongguo and Shah, Parikshit. Guaranteed tensor decomposition: A moment approach. In Proceedings of
the 32nd International Conference on Machine Learning (ICML-15), pp. 1491–1500, 2015.
Vervliet, N., Debals, O., Sorber, L., Van Barel, M., and
De Lathauwer, L. Tensorlab 3.0, Mar. . Available online.
Wang, Yichen, Chen, Robert, Ghosh, Joydeep, Denny,
Joshua C, Kho, Abel, Chen, You, Malin, Bradley A, and
Sun, Jimeng. Rubik: Knowledge guided tensor factorization and completion for health data analytics. In Proceedings of the 21th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining, pp.
1265–1274. ACM, 2015a.
Wang, Yining, Tung, Hsiao-Yu, Smola, Alexander J, and
Anandkumar, Anima. Fast and guaranteed tensor decomposition via sketching. In Advances in Neural Information Processing Systems, pp. 991–999, 2015b.
Yu, Rose and Liu, Yan. Learning from multiway data: Simple and efficient tensor regression. In Proceedings of
the 33nd International Conference on Machine Learning (ICML-16), pp. 238–247, 2016.
Zhang, Tong and Golub, Gene H. Rank-one approximation
to high order tensors. SIAM Journal on Matrix Analysis
and Applications, 23(2):534–550, 2001.

Orthgonalized ALS for Tensor Decomposition

A. Proof Overview: the Orthogonal Tensor Case
In this section, we will consider Orthogonalized ALS for the special case when the factors matrix of the tensor is an
orthogonal matrix. Although this special case is easy and numerous algorithms provably work in this setting, it will serve
to highlight the high level analysis approach that we apply to the more general settings.
The analysis of Orth-ALS hinges on an analysis of the tensor power method. For completeness we describe the tensor
power method in Algorithm 2. We will go through some preliminaries for our analysis of the tensor power method. Let
the iterate of the tensor power method at time t be Zt . The tensor power method update equations can be written as (refer
to (Anandkumar et al., 2014c))
Pk
wi hZt−1 , Ai i2 Ai
(A.1)
Zt = Pki=1
k i=1 wi hZt−1 , Ai i2 Ai k2
Eq. A.1 is just the tensor analog of the matrix power method updates. For tensors, the updates are quadratic in the previous
inner products, in contrast to matrices where the updates are linear in the inner products in the previous step.
Algorithm 2 Tensor power method to recover all factors (Anandkumar et al., 2014c)
Input: Tensor T ∈ Rd×d×d , number of initializations L, number of iterations N .
1: for τ = 1 : L do
(τ ) (τ ) (τ )
2:
Initialize x0 , y0 , z0 ∈ Rd uniformly from the unit sphere or using the SVD based method
3:
for t = 1 : N do
(τ )
(τ )
(τ )
4:
Rank-1 ALS/Power method updates-xt+1 = T(1) (ẑt  ŷt )
5:

(τ )

(τ )
(τ )
 x̂t )
(τ )
(τ )
T(3) (ŷt  x̂t )
τ
τ
in x̂τt+1 , ŷt+1
, ẑt+1
.

Rank-1 ALS/Power method updates-yt+1 = T(2) (ẑt
(τ )
updates-zt+1

6:
Rank-1 ALS/Power method
=
τ
τ
7:
Normalize xτt+1 , yt+1
, zt+1
and store results
8:
end for
(τ ) (τ ) (τ )
9:
Estimate weights-ŵ(τ ) = T (x̂N , ŷN , ẑN )
10: end for
(τ ) (τ ) (τ )
11: Cluster set {(ŵ(τ ) , x̂N , ŷN , ẑN ), τ ∈ [L]} into k clusters.

12: return the centers {(ŵi , âi , b̂i , ĉi ), i ∈ [k]} of the k clusters as the estimates

Observe from Algorithm 1 (Orth-ALS) that the ALS steps in step 4-6 have the same form as tensor power method updates,
but on the orthogonalized factors. This is the key idea we use in our analysis of Orth-ALS. Note that the first factor
estimate is never affected by the orthogonalization, hence the updates for the first estimated factor have exactly the same
form as the tensor power method updates, as this factor is unaffected by orthogonalization. The subsequent factors have
an orthogonalization step before every tensor power method step. This ensures that they never have high correlation with
the factors which have already been recovered, as they are projected orthogonal to the recovered factors before each ALS
step. We then use the incoherence of the factors to argue that orthogonalization does not significantly affect the updates of
the factors which have not been recovered so far, while ensuring that the factors which have already been recovered always
have a small correlation.
Note that Eq. A.1 is invariant with respect to multiplying the weights of all the factors by some constant. Hence for ease of
max
exposition, we assume that all the weights lie in the interval [1, γ], where γ = w
wmin . We also define η = max{cmax , 1/d}.
Pk
Proposition 1. Consider a d-dimensional rank k tensor T = i=1 wi Ai ⊗Ai ⊗Ai where the factor matrix A is orthogonal.
max
Define γ = w
wmin to be the ratio of the largest and smallest weight. If the initial estimates for all the factors are initialized
randomly from the unit sphere and the factors {Aj , j ≥ i + 1} are re-randomized after i(log k + log log d) steps where i is
an integer, then with high probability the orthogonalized ALS updates converge to the true factors in O(k(log k+log log d))
ŵi
steps, and the error at convergence satisfies k Ai − Âi k22 ≤ O(γk/d2 }) and |1 − w
| ≤ O(1/d) for all i.
i
Proof. Without loss of generality, we assume that the ith recovered factor converges to the ith true factor. As mentioned
earlier, the iterations for the first factor are the usual tensor power method updates and are unaffected by the remaining
factors. Therefore to show that orthogonalized ALS recovers the first factor, we only need to analyze the tensor method
updates. We show that the tensor power method with random initialization converges in O(log k + log log d) steps with

Orthgonalized ALS for Tensor Decomposition

probability at least (1 − 1/k 1+ ), for any  > 0. Hence this implies that Orth-ALS correctly recovers the first factor in
O(log k + log log d) steps with probability at least (1 − 1/k 1+ ), for any  > 0.
The main idea of our proof of convergence of the tensor power method is the following – with decent probability, there is
some separation between the correlations of the factors with the random initialization. By the tensor power method updates
(Eq. A.1), this gap is amplified at every stage. We analyze the updates for all the factors together by a simple recursion.
We then show that this recursion converges in in O(log k + log log d) steps.
Let Zt be the iterate of the tensor power method updates at time t. Without loss of generality, we will be proving convergence to the first factor A1 . Let ai,t be the correlation of the ith factor Ai with Zt , i.e. ai,t = hAi , Zt i (note that this
should technically be called the inner product, but we refer to it as the correlation). We will refer to wi ai,t as the weighted
correlation of the ith factor.
The first step of the proof is that with decent probability, there is some separation between the weighted correlation of the
factors with the initial random estimate. This is Lemma 1.


5
|wi ai,0 |
k
1+
Lemma 1. If γkcmax ≤ 1/k 1+ for some  > 0, then with probability at least 1 − log
k1+ , maxi |wi ai,0 | ≤ 1 − 5/k
∀ i 6= arg maxi |wi ai,0 |.
The proof of Lemma 1 is a bit technical, but relies on basic concentration inequalities for Gaussians. Then using Eq. A.1
the correlation at the end of the (t + 1)th time step is given by
ai,t+1 = wi a2i,t /κt
where κt = k

Pk

i=1

wi hZt−1 , Ai i2 k2 is the normalizing factor at the tth time step.

Because the estimate is normalized at the end of the updates, we only care about the ratio of the correlations of the
factors with the estimate rather than the magnitude of the correlations themselves. Hence, it is convenient to normalize all
the correlations by the correlation of the largest factor and normalize all the weights by the weight of the largest factor.
ai,t
wi
Therefore, let âi,t = a1,t
and ŵi = w
. The new update equation for the ratio of correlations âi,t is1
âi,t+1 = ŵi â2i,t

(A.2)

Our goal is to show that ai,t becomes small for all i 6= 1 in O(log k + log log d) steps. Instead of separately analyzing the
different ai,t for different factors Ai , we upper bound ai,t for all i via a simple recursion. Consider the recursion,




β0 = max ŵi âi,0 
(A.3)
i6=1

βt+1 = βt2

(A.4)

We claim that |ŵi âi,t | ≤ βt for all t and i 6= 1. By Eq. A.3, this is true for t = 0 by definition. We prove our claim via
2
induction. Assume that |ŵi âi,t | ≤ βt for t = p. Note that by Eq. A.2, ŵi âi,p+1 = ŵi2 â2i,p . Therefore wi âi,p+1 ≤ βp+1
for
all i 6= 1. Hence |ŵi âi,t | ≤ βt for all t and i 6= 1. Note that as the weights lie in the interval [1, γ], âi,t ≤ βt .
To show convergence, we will now analyze the recursion in Eq. A.3. We will show that βt becomes sufficiently small in
t
O(log k + log log d) steps. Note that βt = (β0 )2 and β0 ≤ 1 − 5/k 1+ . Therefore βt ≤ 0.1 for t = 2 log k. In another
log log d steps, βt ≤ 1/d. Hence βt ≤ 1/d in O(log k + log log d) steps. As βt is an upper bound for the correlation of all
but the first factor, hence |âi,t | ≤ 1/d for all i 6= 1 in O(log k + log log d) steps.
To finish the proof of convergence for the tensor power method, we need to show that the estimate Zt is close to A1 if it
has small correlation with every factor other than A1 . Lemma 2 shows that if the ratio of the correlation of every other
factor with A1 is small, then the residual `2 error in estimating A1 is also small.
Lemma 2. Let γkcmax ≤ 1/k 1+ . Without loss of generality assume convergence to the first factor A1 . Define
ai,t
âi,t = | a1,t
|- the ratio of the correlation of the ith and 1st factor with the iterate at time t. If âi,t ≤ 2η ∀ i 6= 1,
then k A1 − Â1 k22 ≤ 10γkη 2 in the subsequent iteration. Also, if k A1 − Â1 k22 ≤ O(γkη 2 ) the relative error in the
estimation of the weight w1 is at most O(η).

Orthgonalized ALS for Tensor Decomposition
1
Using Lemma 2, it follows that the estimate Â1 and ŵ1 for the factor A1 satisfies k A1 − Â1 k22 ≤ 10γk/d2 and |1 − ŵ
w1 | ≤
O(1/d). Hence we have shown that Orth-ALS correctly recovers the first factor.

We now prove that Orth-ALS also recovers the remaining factors. The proof proceeds by induction. We have already
shown that the base case is correct and the algorithm recovers the first factor. We next show that if the first (m − 1) factors
have converged, then the mth factor converges in O(log k + log log d) steps with failure probability at most Õ(1/k 1+ ).
The main idea is that as the factors have small correlation with each other, hence orthogonalization does not affect the
factors which have not been recovered but ensures that the mth estimate never has high correlation with the factors which
have already been recovered. Recall that we assume without loss of generality that the ith recovered factor Xi converges
ˆ i for i < m, where k ∆
ˆ i k2 ≤ 10γk/d2 . This is our induction hypothesis,
to the ith true factor, hence Xi = Ai + ∆
which is true for the base case as we just showed that the tensor power method updates converge with residual error at most
10γk/d2 .
Let Xm,t denote the mth factor estimate at time t and let Ym denote it’s value at convergence. We will first calculate the
effect of the orthogonalization step on the correlation between the factors and the estimate Xm,t . Let {X̄i , i < m} denote
an orthogonal basis for {Xi , i < m}. The basis {X̄i , i < m} is calculated via QR decomposition, and can be recursively
written down as follows,
P
Xi − j<i X̄jT Xi X̄j
P
(A.5)
X̄i =
k Xi − j<i X̄jT Xi X̄j k2
Note that the estimate Xm,t is projected orthogonal to this basis. Define X̄m,t as this orthogonal projection, which can be
written down as follows –
X
X̄m,t = X̄m,t −
X̄jT Xm,t X̄j
j<m

In the QR decomposition algorithm X̄m,t is also normalized to have unit norm but we will ignore the normalization of
Xm,t in our analysis because as before we only consider ratios of correlations of the true factors with X̄m,t , which is
unaffected by normalization.
We will now analyze the orthogonal basis {X̄i , i < m}. The key idea is that the orthogonal basis {X̄i , i < m} is close to
the original factors {Ai , i < m} as the factors are incoherent. Lemma 3 proves this claim.
Lemma 3. Consider a stage of the Orthogonalized ALS iterations when the first (m − 1) factors have converged. Without
ˆ i , i < m, wherek ∆
ˆ i k2 ≤ 10γkη 2 . Let {X̄i , i < m} denote an orthogonal basis for
loss of generality let Xi = Ai + ∆
{Xi , i < m} calculated using Eq. A.5. Then,
1. X̄i = Ai + ∆i , ∀ i < m and k ∆j k2 ≤ 10kη.
2. |ATj ∆i | ≤ 3η, ∀ i < m, j < i.
3. |ATj ∆i | ≤ 20γkη 2 , ∀ i < m, j > i.
Using Lemma 3, we will find the effect of orthogonalization on the correlations of the factors with the iterate Xm,t . At a
high level, we need to show that the iterations for the factors {Ai , i ≥ m} are not much affected by the orthogonalization,
while the correlations of the factors {Ai , i < m} with the estimate Xm,t are ensured to be small. Lemma 3 is the key tool
to prove this, as it shows that the orthogonalized basis is close to the true factors.
We will now analyze the inner product between X̄m,t and factor Ai . This is given byATi X̄m,t = ATi Xm,t −

X

T
Xm,t
X̄j ATi X̄j

j<m

As earlier, we normalize all the correlations by the correlation of the largest factor, let āi,t be the ratio of the correlations
of Ai and Am with the orthogonalized estimate X̄m,t at time t. We can write āi,t asP
T
ATi Xm,t − j<m Xm,t
X̄j ATi X̄j
P
āi,t = T
T X̄ AT X̄
Am Xm,t − j<m Xm,t
j m j

Orthgonalized ALS for Tensor Decomposition

We can multiply both sides by ŵi and substitute X̄j from Lemma 3 and then rewrite as followsP
T
ŵi ATi Xm,t − j<m ŵi Xm,t
(Aj + ∆j )ATi ∆j
P
ŵi āi,t =
T (A + ∆ )AT ∆
ATm Xm,t − j<m Xm,t
j
j
m j
We divide the numerator and denominator by ATm Xm,t to derive an expression in terms of the ratios of correlations. Let
δi,t =

T
Xm,t
∆j
.
T A
Xm,t
m

ŵi āi,t =

ŵi âi,t −
1−

P

Pj<m

(ŵi âj,t + ŵi δi,t )ATi ∆j

j<m (âj,t

+ δi,t )ATm ∆j

We now need to show ŵi āi,t is small for all i < m and is close to ŵi ai,t , the weighted correlation before orthogonalization,
for all i > m. Lemma 4 proves this, and shows that the weighted correlation of factors which have not yet been recovered,
{Ai , i ≥ m}, is not much affected by orthogonalization, but the factors which have already been recovered. {Ai , i < m},
are ensured to be small after the orthogonalization step.
Lemma 4. Let |ŵi âi,t | ≤ βt ∀ i 6= m at the end of the tth iteration. Let āi,t be the ratio of the correlation of the ith and
the mth factor with Xm,t , the iterate at time t after the orthogonalization step. Then,
1. |ŵi āi,t | ≤ βt (1 + 1/k 1+ )), ∀ i > m.
2. |ŵi āi,t | ≤ 50γkηβt , ∀ i < m.
We are now ready to analyze the Orth-ALS updates for the mth factor. First, we argue about the initialization step.
Lemma 4 shows that an orthogonalization step performed after a random initialization ensures that the factors which have
already been recovered have small correlation with the orthogonalized initialization. This is where we need a periodic
re-randomization of the factors which have not converged so far.
Lemma 5. Let Xm,0 be initialized randomly and the result be projected orthogonal to the (m − 1) previously estimated
factors, let these be {Xi , i < m} without
Then arg maxi |wi ai,0 | ≥ m with high probability. Also, with

  loss of generality.
 wi āi,0 
log5 k
failure probability at most 1 − k1+ ,  maxi {wi āi,0 }  ≤ 1 − 4/k 1+ ∀ i 6= arg maxi |wi ai,0 | after the orthogonalization
step.
Lemma 5 shows that with high probability, the initialization for the mth recovered factor has the largest weighted correlation with a factor which has not been recovered so far after the orthogonalization step. It also shows that the separation
condition in Lemma 1 is satisfied for all remaining factors with probability (1 − log5 k/k 1+ ).
Now, we combine the effects of the tensor power method step and the orthogonalization step for subsequent iterations to
show that that Xm,t converges to Am . Consider a tensor power method step followed by an orthogonalization step. By our
previous argument about the convergence of the tensor power method, if |ŵi âi,t−1 | ≤ βt−1 i 6= m at some time (t − 1),
2
then |ŵi âi,t | ≤ βt−1
for i 6= m after a tensor power method step. Lemma 4 shows that the correlation of all factors
other than the mth factor is still small after the orthogonalization step, if it was small before. Combining the effect of the
2
orthogonalization step via Lemma 4, if |ŵi âi,t−1 | ≤ βt−1 i 6= m for some time (t − 1), then |ŵi âi,t | ≤ βt−1
(1 + 1/k 1+ )
for i 6= m after both the tensor power method and the orthogonalization steps. By also using Lemma 5 for the initialization,
can now write the updated combined recursion analogous to Eq. A.3 and Eq. A.4, but which combines the effect of the
tensor power method step and the orthogonalization step.




β0 = max ŵi âi,0 
(A.6)
i6=1

βt+1 = βt2 (1 + 1/k 1+ )

(A.7)

By the previous argument, |wi āi,t | ≤ βt . Note that β0 ≤ 1 − 4/k 1+ by Lemma 5. By expanding the recursion A.7, βt =
t
(β0 (1+1/k 1+ ))2 . Hence βt ≤ 1/d in 2 log k+log log d steps as was the case for the analysis for the tensor power method.
This shows that the correlation of the estimate Xm,t with all factors other than Am becomes small in 2 log k + log log d.

Orthgonalized ALS for Tensor Decomposition

We now again use Lemma 2 to argue that this implies that the recovery error is small, i.e. k Am − Âm k22 ≤ 10γk/d2 and
m
|1 − ŵ
wm | ≤ O(1/d).
ˆ i where k ∆
ˆ i k2 ≤ 10γk/d2 , ∀ i < m
Hence we have shown that if the first (m−1) factors have converged to Xi = Ai + ∆
2
ˆ
ˆ
then themth factor 
converges to Xm = Am +∆m where k ∆m k2 ≤ 10γk/d in O(log k+log log d) steps with probability
at least 1 −

log5 k
k1+

. This proves the induction hypothesis.

We can now do a union bound to argue that each factor converges with `2 error at most O(γk/d2 ) in O(k(log k+log log d))
with overall failure probability at most Õ(1/k − ),  > 0. This finishes the proof of convergence of Orth-ALS for the special
case of orthogonal tensors.

B. Global convergence of the tensor power method for incoherent tensors
In this section, we will analyze the tensor power method updates for worst-case incoherent tensors. This is a necessary
step before analyzing Orth-ALS, because as was pointed out in the proof of convergence of Orth-ALS in the orthogonal
tensor case, analyzing Orth-ALS updates reduces to analyzing a perturbed version of the tensor power method updates.
Our convergence results for the tensor power method are interesting independent of Orth-ALS though, as they prove global
convergence under random initialization. The proof idea is similar to the proof of convergence of the tensor power method
in the orthogonal case, but we now need to analyze the cross-terms which come in because the factors are no longer
orthogonal.
Pk
T
Theorem 3. Consider a d-dimensional rank k tensor T =
i=1 wi Ai ⊗ Ai ⊗ Ai . Let cmax = maxi6=j |Ai Aj | and
wmax
−2
γ = wmin be the ratio of the largest and smallest weight, and assume γcmax ≤ o(k ). If the initialization x0 ∈
Rd is chosen uniformly from the unit sphere, then with high probability the tensor power method updates converge to
one of the true factors (say A1 ) in O(log k + log log d) steps, and the error at convergence satisfies k A1 − Â1 k22 ≤
1
O(γk max{c2max , 1/d2 }) and |1 − ŵ
w1 | ≤ O(max{cmax , 1/d}).
Proof. Without loss of generality, we will prove convergence to the first factor A1 . The proof is similar in spirit to the
proof of convergence of the tensor power method in the orthogonal case in Section A.
As in the orthogonal case, Lemma 1 states that with high probability there is some separation between the weighted
correlation of the largest and second largest factors.


5
|w a |
k
Lemma 1. If γkcmax ≤ 1/k 1+ for some  > 0, then with probability at least 1 − log
, maxi i|wi,0
≤ 1 − 5/k 1+
1+
k
i ai,0 |
∀ i 6= arg maxi |wi ai,0 |.
a

i,t
and normalize all the weights by
We normalize all the correlations by the correlation of the largest factor, let âi,t+1 = a1,t
wi
the weight of the largest factor, ŵi = w1 . The new update equations in terms of the ratio of correlations âi,t become-

âi,t+1

P
ŵi â2i,t + ci,1 + j:j6={i,1} ci,j ŵj â2j,t
P
=
1 + j:j6=1 c1,j ŵj â2j,t

(B.1)

Notice that we have cross terms in Eq. B.1 as compared to Eq. A.2 in the orthogonal case, due to the correlation ci,j
between the factors being non-zero. The goal of the analysis for the non-orthogonal case is to bound these cross-terms
using the incoherence between the factors.
As in the orthogonal case, we will analyze all the correlations âi,t via a single recursion. We define βt in the non-orthogonal
case keeping in mind the cross-terms because of the correlations between the factors being non-zero.




β0 = max wi âi,0 
(B.2)
i6=1

βt+1 = γcmax + βt2 + 3γkcmax βt2
We now show that |wi âi,t | ≤ βt , ∀ i 6= 1 and all t.

(B.3)

Orthgonalized ALS for Tensor Decomposition

Lemma 6. If |ŵi âi,m | ≤ βm for some time m and for all i 6= 1, then at time (m + 1) for all i 6= 1,
1. |ŵi âi,m+1 | ≤ βm+1 .
2
2. |âi,m+1 − ci,1 | ≤ 2βm

Proof. Note that by Lemma 7, βt < 1 ∀ t =⇒ ŵi â2i,m ≤ 1. Therefore
we can write,
1+

P

j

|ci,j ŵj â2j,m | ≤ kcmax ≤ 1/k 1+ ∀ i. Hence

X
1
=1−
c1,j ŵj â2j,m + 1
2
j:j6=1 c1,j ŵj âj,m

P

j:j6=1

2
P


where 1 is the residual term, and |1 | ≤  j:j6=1 c1,j ŵj â2j,m  ≤ k 2 c2max ≤ 1/k 2 . We can now rewrite the updates for
âi,m+1 as
âi,m+1 = ci,1 + ŵi â2i,m +

X

ci,j ŵj â2j,m



1−

j:j6={i,1}

Let ρi,m = ci,1 + ŵi â2i,m +

P

2
j:j6={i,1} ci,j ŵj âj,m .

c1,j ŵj â2j,m + 1



j:j6=1

We can write,

X

âi,m+1 = ci,1 + ŵi â2i,m +

X

ci,j ŵj â2j,m − ρi,m

j:j6={i,1}


   
 

   
 
=⇒ âi,m+1  ≤ ci,1  + ŵi â2i,m  + 

X

c1,j ŵj â2j,m + ρi,m 1

(B.4)

j:j6=1

X

 
 

X
 
 

ci,j ŵj â2j,m  + ρi,m
c1,j ŵj â2j,m  + ρi,m 1 

j:j6={i,1}

(B.5)

j:j6=1

We claim that ρi,m ≤ 1. We verify this as follows,
ρi,m = ci,1 + ŵi â2i,m +

X

ci,j ŵj â2j,m

j:j6={i,1}


   
 

   
 
=⇒ ρi,m  ≤ ci,1  + ŵi â2i,m  + 

X



ci,j ŵj â2j,m 

j:j6={i,1}



  
 


  
 
=⇒ ŵi ρi,m  ≤ γ ci,1  + ŵi2 â2i,m  + 



ci,j ŵi ŵj â2j,m 

X
j:j6={i,1}

2
2
≤ γcmax + βm
+ γkcmax βm

≤ βm+1 ≤ 1




=⇒ ρi,m  ≤ 1
where we used the fact that the weights lie in the interval [1, γ]. Hence |ρi,m | ≤ 1. Therefore, by Eq. B.5,

   
 

   
 
âi,m+1  ≤ ci,1  + ŵi â2i,m  + 

  X
  
 
  
ci,j ŵj â2j,m  + 
c1,j ŵj â2j,m  + 1 

X
j:j6={i,1}



  
 


  
 
=⇒ ŵi âi,m+1  ≤ γ ci,1  + ŵi2 â2i,m  + 

X

j:j6=1

  X

 
 

 
ci,j ŵi ŵj â2j,m  + 
c1,j ŵi ŵj â2j,m  + γ 1 

j:j6={i,1}

≤ γcmax +

2
βm

+

2
3γkcmax βm

j:j6=1

= βm+1

2
To show that |âi,m+1 − ci,1 | ≤ 2βm
we use Eq. B.4 and repeat the steps used to show that |ŵi âi,m+1 | ≤ βm+1 ∀ t.

By using induction and Lemma 6, the iterates at all time t satisfy the following properties, for all i 6= 1,

(B.6)

Orthgonalized ALS for Tensor Decomposition

1. |ŵi âi,t | ≤ βt ∀ t.
2
2. |âi,t − ci,1 | ≤ 2βt−1

This allows us to analyze the iterations of βt instead of keeping track of the different ai,t . We will now analyze the recursion
for βt . The following Lemma shows that βt becomes sufficiently small in O(log k + log log d) steps.
Lemma 7. βt ≤ 3γη ∀ t ≥ O(log k + log log d), also βt < 1 ∀ t
Proof. We divide the updates into three stages.
1. 0.1 ≤ βt ≤ 1 − 5/k 1+ :
As βt ≥ 0.1, therefore kβt2 ≥ 1 in this regime and hence γcmax ≤ γkcmax βt2 , and we can writeβt+1 = γcmax + βt2 + 3γkcmax βt2
βt+1 ≤ βt2 + 4γkcmax βt2
We claim that βt < 0.1 for t = O(log d). To verify, note thatt

βt ≤ (β0 (1 + 4γkcmax ))2

2t
≤ (1 − 5/k 1+ )(1 + 1/k 1+ )

2t
≤ 1 − 1/k 1+

(B.7)

t

where we used the fact that γkcmax ≤ 1/k 1+ . Note that (1 − 1/k 1+ )2 ≤ 0.1 for t = 2 log k and hence we stay in
this regime for at most 2 log k steps.
2.

√

γη ≤ βt ≤ 0.1 :

For notational convenience, we restart t from 0 in this stage. Because γcmax ≤ γη ≤ βt2 in this regime and
3γkcmax βt2 ≤ 0.1βt2 as γkcmax ≤ 1/k 1+ , we can writeβt+1 = γcmax + βt2 + 3γkcmax βt2
≤ βt2 + βt2 + 0.3βt2 ≤ 2.5βt2
We claim that βt <

√

γη for t = O(log log γη −1 ). To verify, note thatt

t

βt ≤ (2.5βt )2 ≤ (0.25)2

(B.8)

t
√
Note that (0.25)2 ≤ γη for t = O(log log(γη)−1 ) and hence we stay in this stage for at most O(log log(γη)−1 )
−1
steps. As η = O(d), this stage continues for at most O(log log d) steps.

3. Note that in the next step, βt ≤ γcmax + 1.1γη ≤ 3γη. This is again because 3γkcmax βt2 ≤ 0.1βt2 and βt ≤
the end of the previous stage.

√

γη at

Hence βt ≤ 3γη for t = O(log log d+log k). By Lemma 6, |âi,t −ci,1 | ≤ 18γ 2 η 2 , i 6= 1. Hence |âi,t | ≤ 2η. By Lemma 2,
1
the error at convergence satisfies k A1 − Â1 k2 ≤ 10γkη 2 and the estimate of the weight ŵ1 satisfies |1− ŵ
w1 | ≤ O(η).

Orthgonalized ALS for Tensor Decomposition

C. Global convergence of the tensor power method for random tensors
The previous section gives global convergence guarantees for the tensor power method for incoherent tensors. Applying
Theorem 3 to a tensor whose factors are chosen uniformly at random, we can say that the tensor power method converges
with random initialization whenever the rank k = o(d0.25 ). Theorem 3 also proves a linear convergence rate. However,
this is quite suboptimal for random tensors. In this section, we use the randomness in the tensor to get much stronger
convergence results.
The techniques used in this section are very different from the rest of the paper. Instead of recursively analyzing the tensor
power method updates by showing that the algorithm makes progress at every step by boosting its correlation with some
fixed factor, we directly express the correlation of the factors with the estimate Zτ after a fixed number of τ = O(log log d)
time steps in terms of the initial correlations of the factors with the random initialization. This allows us to then skillfully
use the randomness in the factors to get strong results. The difficulty with the recursive approach is that all the randomness
in the tensor is “lost” after just one tensor power method update, i.e. the correlations of different factors with the estimate
are no longer independent of each other, which makes the analysis much more difficult.
Pk
Theorem 2. Consider a d-dimensional rank k tensor T = i=1 wi Ai ⊗ Ai ⊗ Ai with the factors Ai sampled uniformly
max
from the d-dimensional sphere. Define γ = w
wmin to be the ratio of the largest and smallest weight. Assume k ≤ o(d)
and γ ≤ polylog(d). If the initialization x0 ∈ Rd is chosen uniformly from the unit sphere, then with high probability
the tensor power method updates converge √to one of the true factors (say A1 ) in O(log log d) steps, and the
√ error at
1
convergence satisfies k A1 − Â1 k2 ≤ Õ(1/ d). Also, the estimate of the weight ŵ1 satisfies |1 − ŵ
w1 | ≤ Õ(1/ d).
Proof. Without loss of generality, we will prove convergence to the first factor A1 . Let τ = 5 log log d2 . As before, define
ai,t = hAi , Zt i where Zt is the iterate at time t. For the analysis of the tensor power method updates for random tensors
we ignore the normalization step of the updates, till the last iteration. It is easy to see that this makes no difference in the
analysis, though in practice it is important to normalize after every step to prevent the vectors from becoming too small
and causing numerical errors. Recall that the update equations for ai,t for any t areX

ai,t = wi a2i,t−1 + ci,1 w1 a21,t−1 +

ci,j wj a2j,t−1

(C.1)

j:j6={i,1}

and the iterate Xτ +1 at time τ + 1 can be written as
Zτ +1 = w1 a21,τ A1 +

X

wi a2i,τ Ai

i6=1
τ

On expanding w1 a21,τ recursively using Eq. C.1, one of the terms that appears in the expansion is (w1 a1,0 )2 /w1 . Define
√
P
τ
ατ = |w1 a1,0 |2 /w1 . Let ∆τ = (1/ατ ) i6=1 wi a2i,τ Ai . We show that k ∆τ k2 ≤ Õ(1/ d) with failure probability at
most log−1 d. We can write (1/ατ )w1 a21,τ , the coefficient for first factor A1 normalized by ατ , as follows

Let λτ =

1
ατ



w1 a21,τ

τ
τ
w1 a21,τ
(w1 a1,0 )2
1 
(w1 a1,0 )2 
2
=
+
w1 a1,τ −
ατ
w1 ατ
ατ
w1

2τ 
1
(w1 a1,0 )
=1+
w1 a21,τ −
ατ
w1

τ
(w a )2
− 1 w1,0
. Let Zτ0 +1 = Zτ +1 /ατ . We can write Zτ0 +1 as
1

Zτ0 +1 = (1 + λτ )A1 + ∆τ
Note that

Zτ0 +1
kZτ0 +1 k2

=

Zτ +1
kZτ +1 k2 .

Let

Zτ0 +1
kZτ0 +1 k2

√
= Z̃τ +1 . We desire to show that the residual k Z̃τ +1 − A1 k2 ≤ Õ(1/ d).

We can bound k Z̃τ +1 − A1 k2 as follows using the triangle inequality,


k Z̃τ +1 − A1 k2 ≤ 


1 + λτ
k ∆τ k2

− 1 +
k (1 + λτ )A1 + ∆τ k2
k (1 + λτ )A1 + ∆τ k2

Orthgonalized ALS for Tensor Decomposition

√
If k ∆τ k2 ≤ Õ(1/ d) and |λτ | ≤ d− then,

1
k ∆ τ k2

− 1 +
k A1 + ∆τ /(1 + λτ ) k2
1 − |λτ | − k ∆τ k2
√
2k ∆τ k2
k ∆τ k 2
≤
+
≤ Õ(1/ d)
1 − |λτ |
1 − |λτ | − k ∆τ k2



k Z̃τ +1 − A1 k2 ≤ 

√
√
1
If k Z̃τ +1 − A1 k2 ≤ Õ(1/ d) then, by Lemma 2, the estimate of the weight ŵ1 satisfies |1 − ŵ
w1 | ≤ Õ(1/ d).
√
2
Hence we will show that k ∆τ k2 ≤ Õ(1/ d) and |λτ | ≤ d− with failure probability at most log−1 d. Let τ = k ∆τ k2 .
We can write τ as
2

τ = k ∆τ k2 =

X

(1/ατ2 )wi wj a2i,τ a2j,τ ci,j

i6=1,j6=1

We can also write λ2τ as followsτ

(w1 a1,0 )2 2
λ2τ = (1/ατ2 )w12 a21,τ −
w12

τ

Note that λτ has the same form as τ with the restriction that i = j = 1 and the
removed.

(w1 a1,0 )2
w12

in the expansion of a21,τ is

Our approach will be to recursively expand the a2i,τ terms to express τ and λτ only in terms of ai,0 (the initial correlations
at time 0), the correlation between factors ci,j and the weights wi . We use the recursion Eq. C.1 to do this.
We first consider the expansion of a2i,τ for any i using recursion Eq. C.1. a2i,t can be written as a weighted sum of
correlations of the factors with the iterate at the (t − 1)st time step as follows using recursion Eq. C.1
2
X
a2i,t = wi a2i,t−1 +
ci,j wj a2j,t−1
(C.2)
j6=i

=

X

wj wk ci,j ci,k a2j,t−1 a2k,t−1

(C.3)

j,k

Each term in the summation corresponds to two choices for the terms at time (t − 1), the j and k variables. Continuing
this recursive expansion for τ time steps, we can represent each monomial in the expansion by a complete binary tree with
depth τ . We label a node of the binary tree as j if it corresponds to factor Aj . For ease of exposition, we will consider
the initialization Z0 as the 0th factor for the graph representation, hence ci,0 = ai,0 . The root of the tree is labeled as i as
it corresponds to the factor Ai . The descendants of the root i are labelled as j and k if a2i,τ is expanded into a2j,τ −1 and
a2k,τ −1 using recursion Eq. C.1. The process is repeated at any step of the recursion, by expanding a2j,t in terms of a2k,t−1
and a2l,t−1 for some k and l. Refer to Fig. 4 for an example of a monomial and it’s binary tree representation.
Given any complete binary tree B, the monomial associated with the tree can be written down recursively. We write down
the procedure for finding the monomial corresponding to a binary tree B explicitly in Algorithm 3 for clarity.
Therefore, by successively using Eq. C.1, we expand wi a2i,1 in terms of the correlations of the factors with the random
initialization Z0 (the a2j,0 factors) and define a complete binary tree Bf for every monomial f in the expansion. We also
define a graph Gf for the monomial f by coalescing nodes of the binary tree having the same label and removing self-loops.
We allow more than one edge between two nodes.
For any monomial f in the expansion of (1/ατ2 )wi wj a2i,τ a2j,τ ci,j in t , we construct two binary trees corresponding to
the expansion of wi a2i,τ and wj a2j,τ . We construct the graph Gf by adding an edge between the roots of the two binary
trees (this corresponds to the ci,j term) and then coalescing nodes of the new graph having the same label and removing
self-loops, while allowing multiple edges between two nodes. The same procedure is followed for the expansion of λ2τ ,
τ

with the difference that now i = j = 1, and the

(w1 a1,0 )2
w12

term in the expansion of a21,τ is removed.

Orthgonalized ALS for Tensor Decomposition

Figure 4. Example of a monomial in the expansion of wi a2i,2 represented as a binary tree.
ci,j ci,j cj,l cj,m ci,k ck,n ck,o wi wj wl wm wk wn wo a2l,0 a2m,0 a2n,0 a2o,0

The monomial is

Algorithm 3 Finding monomial f from binary tree B
Input: Binary tree B, root u
monomial(B, u)
1: while u is not a leaf do
2:
Set i to be the factor corresponding to u
3:
Set v to be the left child of u, set j to be the factor corresponding to v
4:
Set w to be the right child of u, set j to be the factor corresponding to w
5:
f = f wi
6:
f = f ci,j monomial(B, v)
7:
f = f ci,j monomial(B, w)
8: end while
9: return f
C.1. Choosing a suitable basis for the factors
Without loss of generality, assume that the first (n − 1) factors are present in Gf , for some n. The (n − 1) vectors
corresponding to the (n − 1) factors and the initialization Z0 span a n dimensional subspace. We will choose a particular
basis {vi }, i ∈ [n] for the n dimensional subspace and express the factors with respect to that basis. v1 = Z0 , and vi
is unit vector along the projection of Ai−1 orthogonal to {Aj , j < i − 1}. In terms of this basis, Z0 = (1, 0, · · · , 0).
Let the 1st factor A1 have component x1,1 along the first coordinate axis and u1,2 along the second coordinate
qP axis.
ũ1,2
x̃1,1
d
2
Note that x1,1 is distributed as r1 and u1,2 is distributed as r1 where x̃1,1 ∼ N (0, 1/d), ũ1,2 ∼ v1
i=2 ỹ1,i
q
x̃21,1 + ũ21,2 . Here ỹ1,i ∼ N (0, 1/d) and v1 is uniform on {−1, +1}. Similarly, the 2nd factor A2 has
and r1 =


x̃
x̃2,2 ũ2,3
components (x2,1 , x2,2 , u2,3 ) ∼ r2,1
,
,
along the first three coordinate axes. Here x̃2,1 , x̃2,2 ∼ N (0, 1/d) and
r
r
2
2
qP
q2
d
2
ũ2,3 ∼ v2
x̃22,1 + x̃22,2 + ũ22,3 , where ỹ2,i ∼ N (0, 1/d) and v2 is uniform on {−1, +1}. We
i=3 ỹ2,i and r2 =
continue this projection for all subsequent factors.
We first prove a Lemma that bounds the magnitude of the projection of any factor along the basis vectors.
Lemma 8. The projection of n factors along the basis defined above has the following properties√

1
≤ ri2 ≤ 1 + d0.25
∀ i ∈ [n] with failure probability at most 2ne− d/8 .
√
8
2. |x̃i,j | ≤ log5 d/ d for all valid i, j (i.e. for all j < i, i ∈ [n]) with failure probability at most n( d1 )log d .

1. 1 −

1

d0.25

Proof. The proof relies on basic concentration inequalities.
1. Consider the vector (xi,1 , · · · , ui,i+1 , 0 · · · , 0) corresponding to factor i. The squared scaling factor ri2 is distributed
2
2
as ri2 ∼ (x̃2i,1 + · · · + x̃2i,i + ũ2i,i+1 ), where ũ2i,i+1 ∼ ỹi,i+1
+ · · · + ỹi,d
, the ỹi,j are independent N (0, 1/d) random
2
variables. ri is the sum of squares of independent zero mean Gaussian random variables each having variance 1/d,
and hence x2i = dri2 is a χ2 random variable with d degrees of freedom. We use the following tail bound on a χ2

Orthgonalized ALS for Tensor Decomposition

random variable x with d degrees of freedom (the bound follows from the sub-exponential property of the χ2 random
variable)
2

P[|x2 − d| ≥ dt] ≤ 2e−dt
√

/8

Choosing t = d−0.25 , P[|x2i − d| ≥ d0.75 ] ≤ 2e− d/8 . Therefore√P[|ri − 1| ≥ d−0.25 ] ≤ 2e−
1
|ri2 − 1| ≤ d0.25
∀ i ∈ [n] with failure probability at most 2ne− d/8 .

√

d/8

. By a union bound,

2. The bound follows directly from basic Gaussian tail bounds (refer to Eq. E.1) and a union bound.

Note that as τ = 5 log log d2 , the total number of nodes of the binary tree corresponding to a monomial is at most
2τ +1 = 2 log5 d2 . As each monomial corresponds to two binary trees, the number of number in the graph Gf can be at
most 4 log5 d2 . Let N = 4 log5 d2 . We can now use a union bound to argue
of the factors in Lemma 8
 properties
o
n that the
t
 w xi,1 
i
=
6
1
and
βt = β02 for any t.
hold with high probability for any set of N factors. We define β0 = max  w1i x1,1
,
5 2
log d
Lemma 9.
, |xi,j | ≤
√ Consider the projection of any set of N = 4 log d factors. With failure probability at most 1/d
3
2 log d/ d for all valid i, j (i.e. for all j < i, i ∈ [N ]). Also, with failure probability at most 1/ log d, β0 ≤ 1 − 1/ log4 k.

√
1
Proof. Using Lemma 8 and a union bound, |x̃i,j | ≤ (log d)5 / d for all valid i, j and |ri2 − 1| ≤ d0.25
∀ i ∈ [N ] with
√
√
8
8
1 log d
1 log d
− d/8
failure probability at most N ( d )
≤ 2N ( d )
+ 2N e
. As xi,j = x̃i,j /ri , therefore xi,j ≤ 2 log5 d/ d
√
1
whenever x̃i,j ≤ log5 d/ d and ri ≥ 1 − d0.25
. Therefore, as the total number of sets of N factors is at most k N ≤ dN ,
√
by doing a union bound over all possible sets of N factors, |xi,j | ≤ 2 log5 d/ d for all valid i, j with failure probability at
8
most 2dN N ( d1 )log d ≤ 1/dlog d .


 w x̃i,1 
1
∀i∈
Using Lemma 14, with failure probability at most 1/ log d,  w1i x̃1,1
 ≤ 1 − 1/ log5 k for all i 6= 1. As |ri2 − 1| ≤ d0.25


√
 w xi,1 
[k] with failure probability at most 2ke− d/8 , therefore with failure probability at most 2/ log d,  w1i x1,1
 ≤ 1−0.5/ log5 k
for all i 6= 1.
√
Let E be the event that for any projection of up to N factors |xi,j | ≤ 2 log3 d/ d for all valid i, j (i.e. for all j < i, i ∈ [n])
and β0 ≤ 1 − 1/ log4 k. By Lemma 9, probability of the event E is at least (1 − 3/ log d). We condition on the event E
for the rest of the proof.
C.2. Characterizing when the monomial has non-zero expectation
Let f2 refer to the product of all a2i,0 terms, all the weights wi for any i appearing in f and 1/ατ2 . Let f1 refer to all the
terms in f not present in f2 , hence f = f1 f2 . Let G0f be the graph obtained by removing the node corresponding to the
initialization X0 and all it’s edges from Gf . Note that G0f is a connected graph, as the 0th factors only appears in the leaves
of the binary tree.
As the ci,j terms are inner products between the factors, we can write ci,j in terms of the co-ordinates of the vectors Ai and
Aj , in terms of the basis we described previously. Note that ai,0 = xi,1 hence there is only one term in the inner product
ai,0 . f1 is a product of the cross-correlation terms ci,j , hence it can be written as the summation of a product of a choices
of coordinate for every ci,j term. Let the terms obtained on rewriting f1 in terms of the coordinates of the vectors be gi ,
PK
hence f1 = i=1 gi .
Lemma 10. f has non-zero expectation only if Gf is Eulerian. Also, every term gi having non-zero expectation corresponds to choosing a split of G0f into a disjoint union of cycles and then choosing a single coordinate for all inner products
ci,j which are part of a particular cycle.
Proof. We claim that every node in Gf must have even degree for f to have non-zero expectation. To verify, consider any
node j which has odd degree. Note that the 0th node corresponding to the initialization X0 always has even degree, hence

Orthgonalized ALS for Tensor Decomposition

j 6= 0. E[f] is the expectation of the product of all correlation terms ci,j and ai,0 appearing in the monomial. Each inner
product ci,j involves a xi,t term or ui,t term for some coordinate t. Hence if node i has odd degree, then there is at least
some t such that xi,t or ui,t is raised to an odd power. Note that the sign of xi,t or ui,t is an independent zero mean random
variable, hence the expectation evaluates to 0 in this case. Hence every node in Gf must have even degree for f to have
non-zero expectation. By Euler’s theorem every node in a graph has even degree if and only if the graph is Eulerian (there
exists a trail in the graph which uses every edge exactly once and returns to its starting point). Also, an Eulerian graph can
be written as a disjoint union of cycles (Veblen’s theorem).
G0f is also Eulerian and can be written as a disjoint union of cycles as every node has an even number of edges to node 0
and hence removal of these edges preserves the Eulerian property.
We now prove the second part of the Lemma, that every term gi having non-zero expectation corresponds to choosing a
split of G0f into a disjoint union of cycles and then choosing a single coordinate for all inner products ci,j which are part of
a particular cycle. To verify this, let’s start at any node i and consider it’s inner product with a neighbor j. Say we choose
coordinate t for the inner product ci,j which leads to a xi,t xj,t term in gi . To ensure that gi has non-zero expectation,
xj,t must appear in the term an even number of times (as the sign of xj,t is an independent zero mean random variable).
Hence the coordinate t must be chosen in the inner product of node j with some neighbor of j. By repeating this argument,
there must exist a cycle C with node i such that the coordinate t is chosen for all correlation terms in that cycle C. We
then repeat the process on the graph obtained by removing the edges corresponding to cycle C from G0f . Hence every gi
term having non-zero expectation corresponds to choosing a split of G0f into a disjoint union of cycles and then choosing
a single coordinate for all inner products ci,j which are part of a particular cycle.
P
We let f10 = i:E[gi ]6=0 gi and f 0 = f10 f2 . We claim that E[f ] = E[f 0 ]. Consider any term gi , such that E[gi ] = 0. We
claim that E[gi f2 ] also equals 0, hence E[f ] = E[f 0 ]. This is because if gi has zero expectation, then there is some xi,t
term raised to an odd power, as otherwise the expectation is non-zero. But, as all terms are raised to an even power in f2 ,
the xi,t term is also raised to an odd power in gi f2 , which implies that E[gi f2 ] = 0. This verifies the claim that E[gi f2 ] = 0
if E[gi ] = 0.
C.3. Bounding expected value of monomial
We are now ready to bound the expected value of f. Note that E[f] = 0 if Gf is not Eulerian. If Gf and hence G0f are Eulerian, split G0f into some disjoint union of cycles. Say we split G0f into p cycles {C1 , C2 , · · · , Cp } with m1 , m2 , · · · , mp
edges. Let D(Cj ) refer to the choice of coordinate D(Cj ) for cycle Cj . Let g(∪j Cj (D(Cj ))) be the term in the expansion
of f corresponding to a split of Gf into cycles {C1 , C2 , · · · , Cp } and the choice of coordinate D(Cj ) for cycle Cj . We
also define h(Cj (D(Cj ))) as the product of terms corresponding to cycle Cj and the choice of coordinate D(Cj ) for the
cycle Cj . Note that g(∪j Cj (D(Cj ))) = Πpj=1 h(Cj (D(Cj ))). We can write
g(∪j Cj (D(Cj )))] = Πj h(Cj (D(Cj )))
h(Cj (D(Cj ))) is the product of the square of the D(Cj )-th co-ordinate of all the factors appearing
in the cycle Cj .
√
Conditioned on the event E, there is only one factor having a component greater than log5 d/ d in absolute value along
the D(Cj )-th co-ordinate axis, hence
h(Cj (D(Cj ))) ≤

(log10 d)m1 −1
dm1 −1

Hence, conditioned on event E, we can bound g(∪j Cj (D(Cj ))) asg(∪j Cj (D(Cj ))) ≤

(log10 d)m/2
dm−p

Let c(Gf ) be the largest p such that G0f can be decomposed into a union of p disjoint cycles. There can be at most m/2
disjoint cycles in G0f as there are m edges, therefore c(Gf ) ≤ m/2. Each edge can be placed in one of the total number
of possible cycles, hence the total number of ways of splitting G0f into a disjoint union of cycles is at most (m/2)m . Also,
there are n possible choices for a coordinate for each cycle, hence there are at most n(m/2) terms corresponding to the same
split of G0f into a disjoint union of cycles. Hence for any particular monomial f , the number of possible gi terms having

Orthgonalized ALS for Tensor Decomposition

non-zero expectation is at most (m/2)m n(m/2) . Note that m ≤ 2 log5 d2 as the graph G0f is constructed by collapsing the
two binary trees corresponding to monomial f . Each binary tree has depth τ = 5 log log d2 , hence the number of edges is
at most 2 log5 d2 . Hence the total number of edges in graph G0f is at most 4 log5 d2 ≤ log6 d. Hence we can bound E|E [f]
asE|E [f] ≤ f 0 ≤ (m/2)m n(m/2)

(log10 d)m/2
(log10 d)5m/2
f
≤
f2
2
dm−c(Gf )
dm−c(Gf )

(C.4)

o
n
w x 
We will now bound the f2 term. Let θ = max  w1i xi,1
 over all nodes i ∈ G0f . Clearly θ ≤ β0 if node 1 is not in G and
1,1
is at most 1 otherwise. We will consider the representation of the monomial f as two complete binary trees. Recall that
the leaves of the binary tree correspond to the 0th factor. Each pair of leaves having the factor i as their parent corresponds
to a a2i,0 term. We will pair every leaf node with it’s successor, regarding the binary tree as a binary search tree. Note that
the left child of any node has the same node as it’s successor. Let the right child of the node with factor i have a node with
factor j as it’s successor. We group the wi term due to the successor of the left child and wj term due to the successor of
the right child together with the a2i,0 term. We bound the wj wi a2i,0 term by γ(wi ai,0 )2 whenever j 6= i and by (wi ai,0 )2
when j = i. If all the edges from the successor to the leaf are self-loops of the form cj,j , then j = i. Note that the paths of
all leaves of a binary tree to their successor are disjoint, hence each cross-correlation term ci,j , i 6= j can lead to at most
one leaf with j 6= i. The number of cross-correlation terms equals m, the number of edges in the graph G0f . Recall that
τ
τ
ατ = |w1 a1,0 |2 /w1 . Therefore the product of all the wi and a2i,0 terms normalized by ατ is at most γ m θ2 .
As an example, consider the monomial f = w22 w14 (c1,2 )4 (a1,0 )8 . The binary tree Bf corresponding to f is given in
Fig. 6. Both binary trees are the same in this case. The graph Gf obtained by coalescing the two binary trees is given
in Fig. 5.
1. Projecting factors onto suitable basis: We can write the initialization Z0 as the vector (1, 0 · · · , 0). We write the
factor A1 as (x1,1 , u1,2 , 0, · · · , 0). Similarly,
the 2nd factor A2 has components (x2,1 , x2,2 , u2,3 ). Using Lemma
√
9, max{|x1,1 |, |x2,1 |, |x2,2 |} ≤ log5 d/ d.
2. Writing expectation of f as product of expectation of cycles: Let f1 = (c1,2 )4 . Let f2 = (a1,0 )8 = (x1,0 )8 .
f can be expanded by choosing a coordinate corresponding to each c1,2 term, and then summing across all
choices. Let
terms obtained on rewriting f1 in terms of the co-ordinates of the factors A1 and A2 be gi ,
Pthe
K
hence f = j=1 gi . By Lemma 10, every term gi having non-zero expectation corresponds to choosing a split
of G0f into a disjoint union of cycles and then choosing a single coordinate for all inner products ci,j which are
part of a particular cycle. Say we split G0f into the union of cycles C1 and C2 where C1 and C2 are 2 edge
cycles between node 1 and node 2. Say we choose the 2nd coordinate for both the cycles C1 and C2 . Following
the notation of subsection C.3, D(C1 ) = D(C2 ) = 2 and g(C1 (2) ∪ C2 (2)) is the term in the expansion of f
corresponding to split of G0f into cycles C1 and C2 and then choosing the second coordinate for both cycles.
g(C1 (2) ∪ C2 (2)) = h(C1 (2))h(c2 (2)) = x41,2 u41,2 ≤ log10 d/d2 , again following the notation of subsection
C.3. Recalling the definition of c(Gf ) be the largest p such that G0f can be decomposed into a union of p disjoint
cycles, for our example, c(Gf ) = 2. As each edge can be placed in one of the two possible cycles and there are 4
edges, the total number of ways of splitting G0f into a disjoint union of cycles is at most 24 . There are 2 possible
choices for coordinates for each cycle as we have two factors. Hence we can bound f 0 and E[f ] as E[f] ≤ f 0 ≤ 24 42

(log10 d)2
(log10 d)10
f
≤
f2
2
d2
d2

(C.5)

Orthgonalized ALS for Tensor Decomposition

Figure 5. Graph Gf for f = w22 w14 (c1,2 )4 (a1,0 )8

Figure 6. Binary tree Bf for f = w22 w14 (c1,2 )4 (a1,0 )8 (both binary trees for f are the same)

We are now ready to bound τ . We will divide τ into 2 sets of monomials and bound each one of them separately1. All monomials with root nodes i and j and with either no path from node i to node 1 or no path from node j to node
1. We call this set S1 .
2. All monomials with root nodes i and j and at least two paths from node i to node 1 and at least two paths from node
j to node 1. We call this set S2 .
Note that the number of paths between two nodes in the graph G0f is always even if f has non-zero expectation, as G0f
is Eulerian in that case. We need to relate the number of nodes and edges of an Eulerian graph for the rest of the proof,
Lemma 11 provides a simple bound.
Lemma 11. For any connected Eulerian graph G, let N be the number of nodes and M be the number of edges. Consider
any decomposition of G into a edge-disjoint set of p cycles. Then, N ≤ M − p + 1. Moreover, if G has four edge-disjoint
paths between a pair of nodes then N ≤ M − p.
We first consider the set S1 . As there are no paths from node i to node 1 or from node j to node 1, therefore θ ≤ β0 for
τ
at least one of the binary trees. Therefore f2 ≤ γ m β02 = γ m βτ . For any graph Gf with n nodes, there can be at most
k n ≤ dn monomials having a graph isomorphic to Gf as their representation. By Lemma 11, n ≤ m − c(Gf ) + 1. The
total number of graphs with n nodes and m edges is be at most (n2 )m . As the graph G0f is connected, n ≤ m. Note that
the number of edges can be at most 4 log5 d2 ≤ log6 d. Hence we can bound the contribution of all monomials in the set
S1 as followsX

E[f ] ≤

f :f ∈S1

6
log
Xd

k m−c(Gf )+1

(m2 )m (log10 d)5m/2 γ m
βt
dm−c(Gf )

k m−c(Gf )+1

(γ log55 d)m 1
dm−c(Gf ) d2

m=0

≤

6
log
Xd

m=0
6

log d
 k m−c(Gf )
1 X
(γ log55 d)m
≤
d m=0
d
6

log d
∞
 1 m/2
1 X
1 X  γ log55 d m
2
≤
(γ log55 d)m 
≤
≤
d m=0
d
d m=0
d0.5
d

We next consider the set S2 . For any graph Gf with n nodes with at least one of the nodes corresponding to factor A1 ,
there can be at most nk n−1 ≤ ndn−1 monomials having a graph isomorphic to Gf as their representation as there are n
possible positions to place the factor A1 and at most dn−1 ways to label the remaining nodes. We claim that by Lemma 11,
n ≤ m − c(Gf ). This is because there are two paths from node i to node 1 and two paths from node j to node 1. Note that

Orthgonalized ALS for Tensor Decomposition

there is always an edge between nodes i and j, as we connect the roots of the binary trees by an edge. Hence there are at
least three edge-disjoint paths between nodes i and j. But there cannot be an odd number of edge-disjoint paths between 2
nodes in an Eulerian graph, hence there must be at least four edge-disjoint paths between nodes i and j. Hence by Lemma
11, n ≤ m − c(Gf ). Also, note that the number of edges m ≥ 4 for monomials in S2 as there are two paths from node
i to node 1 and two paths from node j to node 1. Hence we can bound the contribution of all monomials in the set S2 as
followsX

E[f ] ≤

f :f ∈S2

6
log
Xd

k m−c(Gf )−1

m(m2 )m (log10 d)5m/2 γ m
dm−c(Gf )

k m−c(Gf )−1

(γ log55 d)m
dm−c(Gf )

m=4

≤

6
log
Xd

m=4
6

log d
 k m−c(Gf )−1
1 X
(γ log55 d)m
≤
d m=4
d
6

6

log d
log d
 1 m/2−1
 1 m/10
1 X
1 X
≤
(γ log55 d)m 
(γ log55 d)m 
≤
d m=4
d
d m=4
d
6

log d
∞
1 X  γ log55 d m
1 X  γ log55 d m
2
≤
≤
≤
d m=4
d0.1
d m=4
d0.1
d

λτ is composed of monomials with at least one correlation (c1,i ) term for i 6= 1. Also, all graphs for monomials corresponding to the expansion of λτ must include a node with label A1 . As before, for any graph Gf with n nodes with at least
one of the nodes corresponding to factor A1 , there can be at most nk n−1 ≤ ndn−1 monomials having a graph isomorphic
to Gf as their representation. By Lemma 11, n ≤ m − c(Gf ) + 1. Hence we can bound λτ as follows,
E[λτ ] ≤

6
log
Xd

k m−c(Gf )

m(m2 )m (log10 d)5m/2 γ m
dm−c(Gf )

k m−c(Gf )

(γ log55 d)m
dm−c(Gf )

m=1

≤

6
log
Xd

m=1

≤

6
log
Xd

(γ log55 d)m

m=1
6

≤
≤

log
Xd

(γ log

m=1
∞ 
X
m=1

55

 k m−c(Gf )
d

6
 1 m/2 log
Xd  γ log55 d m
d)
≤
d
d0.5
m=1

m

γ log55 d m
1
≤ 0
d0.5
d

for some 0 > 0. We now use Markov’s inequality to get high probability guarantees
h
i
P τ ≥ log d/d ≤ 4/log2 d
h
i
0
P λτ ≥ log d/d ≤ 1/log2 d
√
Hence we have shown that k ∆τ k2 ≤ Õ(1/ d) and |λτ | ≤ d− with failure probability at most log−1 d.

D. Proof of convergence for Orth-ALS
The proof of convergence of Orth-ALS for incoherent tensors mirrors the proof for orthogonal tensors in Section A. For
clarity, we will try to stick to the proof for the orthogonal case as far possible, while also providing proofs for intermediate
Lemmas which were stated without proof in Section A.

Orthgonalized ALS for Tensor Decomposition

Pk
Theorem 1. Consider a d-dimensional rank k tensor T = i=1 wi Ai ⊗ Ai ⊗ Ai . Let cmax = maxi6=j |ATi Aj | be the
max
incoherence between the true factors and γ = w
wmin be the ratio of the largest and smallest weight. Assume γcmax ≤
−2
o(k ), and the estimates of the factors are initialized randomly from the unit sphere. Provided that, at the i(log k +
log log d)th step of the algorithm the estimates for all but the first i factors are re-randomized, then with high probability
the orthogonalized ALS updates converge to the true factors in O(k(log k + log log d)) steps, and the error at convergence
ŵi
| ≤ O(max{cmax , 1/d}), for all i.
satisfies (up to relabelling) k Ai − Âi k22 ≤ O(γk max{c2max , 1/d2 }) and |1 − w
i
Proof. Without loss of generality, we assume that the ith recovered factor converges to the ith true factor. Note that
the iterations for the first factor are the usual tensor power method updates and are unaffected by the remaining factors.
Hence by Theorem 3, Orth-ALS correctly recovers the first factor O(log k + log log d) steps with probability at least
(1 − log5 k/k 1+ ), for any  > 0.
We now prove that Orth-ALS also recovers the remaining factors. The proof proceeds by induction. We have already
shown that the base case is correct and the algorithm recovers the first factor. We next show that if the first (m − 1) factors
have converged, then the mth factor converges in O(log k + log log d) steps with failure probability at most Õ(1/k 1+ ).
The main idea is that as the factors have small correlation with each other, hence orthogonalization does not affect the
factors which have not been recovered but ensures that the mth estimate never has high correlation with the factors which
have already been recovered. Recall that we assume without loss of generality that the ith recovered factor Xi converges
ˆ i for i < m, where k ∆
ˆ i k2 ≤ 10γkη 2 . This is our induction hypothesis, which
to the ith true factor, hence Xi = Ai + ∆
is true for the base case as by Theorem 3 the tensor power method updates converge with residual error at most 10γkη 2 .
Let Xm,t denote the mth factor estimate at time t and let Ym denote it’s value at convergence. We will first calculate the
effect of the orthogonalization step on the correlation between the factors and the estimate Xm,t . Let {X̄i , i < m} denote
an orthogonal basis for {Xi , i < m}. The basis {X̄i , i < m} is calculated via QR decomposition, and can be written down
as follows,
P
Xi − j<i X̄jT Xi X̄j
P
X̄i =
k Xi − j<i X̄jT Xi X̄j k2
Note that the estimate Xm,t is projected orthogonal to this basis. Define X̄m,t as this orthogonal projection, which can be
written down as follows –
X
X̄m,t = X̄m,t −
X̄jT Xm,t X̄j
j<m

In the QR decomposition algorithm X̄m,t is also normalized to have unit norm but we will ignore the normalization of
Xm,t in our analysis because as before we only consider ratios of correlations of the true factors with X̄m,t , which is
unaffected by normalization.
We will now analyze the orthogonal basis {X̄i , i < m}. The key idea is that the orthogonal basis {X̄i , i < m} is close to
the original factors {Ai , i < m} as the factors are incoherent. Lemma 3 proves this claim.
Lemma 3. Consider a stage of the Orthogonalized ALS iterations when the first (m − 1) factors have converged. Without
ˆ i , i < m, wherek ∆
ˆ i k2 ≤ 10γkη 2 . Let {X̄i , i < m} denote an orthogonal basis for
loss of generality let Xi = Ai + ∆
{Xi , i < m} calculated using Eq. A.5. Then,
1. X̄i = Ai + ∆i , ∀ i < m and k ∆j k2 ≤ 10kη.
2. |ATj ∆i | ≤ 3η, ∀ i < m, j < i.
3. |ATj ∆i | ≤ 20γkη 2 , ∀ i < m, j > i.
ˆ 1 where k ∆
ˆ 1 k2 ≤ 10γkη 2 , the base
Proof. We argue the result by induction. As the first estimate converges to A1 + ∆
case is correct. Assume that the result is true for the first p − 1 vectors in the basis. After orthogonalization, the pth basis
vector has the following form
X
1
ˆ p) −
ˆ p )T X̄j )X̄j
(Ap + ∆
((Ap + ∆
X̄p =
κ
j<p

Orthgonalized ALS for Tensor Decomposition

where κ is the normalizing factor which ensures k X̄p k2 = 1. Define µp,j = (ATp (Aj + ∆j ). As |ATp ∆j | ≤ 20γkη 2 by
the induction hypothesis and |ATp Aj | ≤ η by definition of η, |µp,j | ≤ 2η. Using the induction hypothesis, we can write
κX̄p = Ap −



X
X
ˆp −
ˆ Tp (Aj + ∆j ) (Aj + ∆j )
ATp (Aj + ∆j ) (Aj + ∆j ) + ∆
∆
j<p

= Ap −

X

k<p

ˆ
µp,j (Aj + ∆j ) + ∆

j<p



ˆ T (Aj + ∆j ) (Aj + ∆j ). As ∆
ˆ  is a projection of ∆
ˆ p orthogonal to the basis {X̄i , i < p},
∆
p
k<p

ˆ = ∆
ˆp −
where ∆
ˆ  k2 ≤ k ∆
ˆ p k2 ≤ 10γkη 2 . We can writek∆
P

κX̄p = Ap −

X

X

µp,j Aj −

j<p

ˆ
µp,j ∆j + ∆

j<p

= Ap + ∆0p
where ∆0p = −

P

j<p

µp,j Aj −

P

j<p

ˆ  . We bound k ∆0p k2 as followsµp,j ∆j + ∆

k ∆0p k2 ≤

X

k µp,j Aj k2 +

j<p

X

ˆ  k2
k µp,j ∆j k2 + k ∆

j<p

≤ 2kη + 20k 2 η 2 + 10γkη 2 ≤ 3kη
Note that κ = k Ap + ∆0p k2 =⇒ 1 − 3kη ≤ κ ≤ 1 + 3kη by the triangle inequality. Hence 1 − 3kη ≤ 1/κ ≤ 1 + 6kη.
Therefore we can rewrite X̄p as1
(Ap + ∆0p )
κ
1
1
= Ap + (1 − )Ap + ∆0p
κ
κ
= Ap + c1 Ap + c2 ∆0p

X̄p =

= Ap + ∆ p
where c1 = (1 − κ1 ), c2 =
k ∆p k2 ≤ 10kη.

1
κ

and ∆p = c1 Ap + c2 ∆0p . Note that |c1 | ≤ 6kη and 1 − 3kη ≤ c2 ≤ 1 + 6kη. Hence

We now show that |ATi ∆p | ≤ 3η, i < p,
 X

X
ˆ
∆p = c1 Ap + c2 −
µp,j Aj −
µp,j ∆j + ∆
j<p

j<p




X

X




ˆ  
=⇒ ATi ∆p | = c1 ATi Ap  + c2 
µp,j ATi Aj −
µp,j ATi ∆j − µp,i ATi ∆i + ATi ∆
j<p

j<p,j6=i

2

≤ 6kη + (1 + 6kη)(2η(1 + kη) + 6kη 2 + 20kη 2 + 10γkη 2 )
≤ 3η
Finally, we show that |ATi ∆p | ≤ 20γkη 2 , i > p,



X

X
 T



ˆ  
µp,j ATi Aj −
µp,j ATi ∆j + ATi ∆
Ai ∆p | = c1 ATi Ap  + c2 
j<p
2

j<p

≤ 6kη + (1 + 6kη)(2kη + 40γk η + 10γkη 2 )
≤ 20γkη 2

2

2 3

Orthgonalized ALS for Tensor Decomposition

Using Lemma 3, we will find the effect of orthogonalization on the correlations of the factors with the iterate Xm,t . At a
high level, we need to show that the iterations for the factors {Ai , i ≥ m} are not much affected by the orthogonalization,
while the correlations of the factors {Ai , i < m} with the estimate Xm,t are ensured to be small. Lemma 3 is the key tool
to prove this, as it shows that the orthogonalized basis is close to the true factors.
We will now analyze the inner product between X̄m,t and factor Ai . This is given byATi X̄m,t = ATi Xm,t −

X

T
Xm,t
X̄j ATi X̄j

j<m

As earlier, we normalize all the correlations by the correlation of the largest factor, let āi,t be the ratio of the correlations
of Ai and Am with the orthogonalized estimate X̄m,t at time t. We can write āi,t asP
T
ATi Xm,t − j<m Xm,t
X̄j ATi X̄j
P
āi,t = T
T X̄ AT X̄
Am Xm,t − j<m Xm,t
j m j
We can multiply both sides by ŵi and substitute X̄j from Lemma 3 and then rewrite as followsP
T
ŵi ATi Xm,t − j<m ŵi Xm,t
(Aj + ∆j )ATi ∆j
P
ŵi āi,t =
T
ATm Xm,t − j<m Xm,t (Aj + ∆j )ATm ∆j
We divide the numerator and denominator by ATm Xm,t to derive an expression in terms of the ratios of correlations. Let
δi,t =

T
Xm,t
∆j
.
T A
Xm,t
m

ŵi āi,t =

ŵi âi,t −
1−

P

Pj<m

(ŵi âj,t + ŵi δi,t )ATi ∆j

j<m (âj,t

+ δi,t )ATm ∆j

Lemma 12 upper bounds δi,t .
2
Lemma 12. Let |ŵi âi,t−1 | ≤ βt−1 ∀ i 6= m and some time (t − 1). Also, let βt ≤ γη + βt−1
. Then for all i < m,
δi,t ≤ 40γkηβt .
P

w λ A

Proof. By the power method updates Xm,t = kP iwiiλiiAiik2 where λi = a2i,t−1 . Note that δi,j is normalized by the
i
P
correlation of the largest factor Am , hence the normalizing factor k i wi λi Ai k2 does not matter and we will ignore it.
We use Lemma 3 to bound |ATi ∆j |. Hence,
 X T ∆  P ŵ â2 |AT ∆ |
j
 m,t j 
i
i i i,t−1
 T
≤ P
2
TA
Xm,t Am
ŵ
â
A
i
m
i,t−1 i
i
P
|ATm ∆j | + i6=j,m ŵi â2i,t−1 |ATi ∆i | + ŵi â2j,t−1 |ATj ∆j |
P
=
1 + i6=m ci,m ŵi â2i,t−1
≤

2
2
20γkη 2 + 3kηβt−1
+ 10kηβt−1
2
1 − γkηβt−1

2
kη(20γη + 13βt−1
)
1 − 0.5
≤ 40γkηβt

≤

We now need to show ŵi āi,t is small for all i < m and is close to ŵi ai,t , the weighted correlation before orthogonalization,
for all i > m. Lemma 4 proves this, and shows that the weighted correlation of factors which have not yet been recovered,
{Ai , i ≥ m}, is not much affected by orthogonalization, but the factors which have already been recovered. {Ai , i < m},
are ensured to be small after the orthogonalization step.

Orthgonalized ALS for Tensor Decomposition

Lemma 4. Let |ŵi âi,t | ≤ βt ∀ i 6= m at the end of the tth iteration. Let āi,t be the ratio of the correlation of the ith and
the mth factor with Xm,t , the iterate at time t after the orthogonalization step. Then,
1. |ŵi āi,t | ≤ βt (1 + 1/k 1+ )), ∀ i > m.
2. |ŵi āi,t | ≤ 50γkηβt , ∀ i < m.
Proof. We can bound āi,t for all i ≥ m as
 P

 ŵi âi,t  +  j<m (ŵi âj,t + ŵi δj,t )ATi (Aj + ∆j )




P
ŵi āi,t  ≤


1 −  j<m (âj,t + δj,t )ATm (Aj + ∆j )



 P






ŵi âi,t  + j<m (ŵi âj,t + ŵi δj,t )ATi (Aj + ∆j )




≤
P



1 − j<m (âj,t + δj,t )ATm (Aj + ∆j )

 P
 






 
 

ŵi âi,t  + j<m ŵi âj,t  + ŵi δj,t  ATi (Aj + ∆j )

   
≤
P

    
1 − j<m âj,t  + δj,t  ATm (Aj + ∆j )
Note that |ŵi âi,t | ≤ βt , |ŵi âj,t | ≤ γβt and |ŵi δj,t | ≤ 40γkηβt . Also, |ATi (Aj + ∆j )| ≤ 4η using Lemma 3. Hence we
can write,


1 + 8γkη


ŵi āi,t  ≤ βt
1 − 4kηβt
≤ βt (1 + 8γkη)(1 + 8kηβt )
≤ βt (1 + 20γkη)
≤ βt (1 + 1/k 1+ )
Similarly, we can bound āi,t for all i < m asŵi āi,t =

ŵi âi,t −
1−

P

Pj<m

(ŵi âj,t + ŵi δj,t )ATi (Aj + ∆j )

j<m (âj,t

+ δj,t )ATm (Aj + ∆j )

P
ŵi âi,t − (ŵi âi,t + ŵi δj,t )ATi (Ai + ∆i ) − j<m,j6=i (ŵi âj,t + ŵi δj,t )ATi (Aj + ∆j )
P
=
1 − j<m (âj,t + δj,t )ATm (Aj + ∆j )
P
ŵi δj,t ATi (Ai + ∆i ) − j<m,j6=i (ŵi âj,t + ŵi δj,t )ATi (Aj + ∆j )
P
=
1 − j<m (âj,t + δj,t )ATm (Aj + ∆j )


 P 
 






 
 

ŵi δj,t ATi (Ai + ∆i ) + j6=i ŵi âj,t  + ŵi δj,t  ATi (Aj + ∆j )

≤
P    

1 − j,m âj,t  + δj,t  ATm (Aj + ∆j )
40γkηβt + 8γkηβt
1 − 4kηβt
≤ 50γkηβt
≤

where we have again used the relations |ŵi âi,t | ≤ βt , |ŵi âj,t | ≤ γβt , |ŵi δj,t | ≤ 40γkηβt and |ATi (Aj + ∆j )| ≤ 4η.
We are now ready to analyze the Orth-ALS updates for the mth factor. First, we argue about the initialization step. Lemma
4 shows that an orthogonalization step performed after the initialization ensures that the factors which have already been
recovered have small correlation with the orthogonalized initialization –

Orthgonalized ALS for Tensor Decomposition

Lemma 5. Let Xm,0 be initialized randomly and the result be projected orthogonal to the (m − 1) previously estimated
factors, let these be {Xi , i < m} without
Then arg maxi |wi ai,0 | ≥ m with high probability. Also, with

  loss of generality.
 wi āi,0 
log5 k
failure probability at most 1 − k1+ ,  maxi {wi āi,0 }  ≤ 1 − 4/k 1+ ∀ i 6= arg maxi |wi ai,0 | after the orthogonalization
step.
Proof. We first show that arg maxi |wi ai,0 | ≥ m. From Lemma 4, the ratio of the weighted correlation of all factors
{Ai , i < m} with the random initialization and the weighted correlation of all factors {Ai , i ≥ m} with the random
initialization is shrunk by a factor of O(k −(1+) ) after the orthogonalization step. Hence no factor {Ai , i < m} will have
maximum weighted correlation after the orthogonalization step.
Lemma 1 can now be applied on all remaining factors, to get the initialization condition. Without loss of generality,
assume that argmax |wi ai,0
 |  = m.  Consider the set of factors {Ai , m ≤ i ≤ n}. From Lemma 1, with prob wa 
log5 k
ability at least 1 − k1+ ,  wmi ai,0
 ≤ 1 − 5/k 1+ ,  > 0 ∀ i 6= 1. Applying Lemma 4 once more, |ŵi āi,t | ≤
m,0


5
k
βt (1 + 1/k 1+ ), ∀ i > m. Therefore combining Lemma 1 and Lemma 4, with failure probability at most 1 − log
,
1+
k


 wi āi,0 
 wm ām,0  ≤ 1 − 4/k 1+ ∀ i 6= m after the orthogonalization step.

Lemma 5 shows that with high probability, the initialization for the mth recovered factor has the largest weighted correlation with a factor which has not been recovered so far after the orthogonalization step. It also shows that the separation
condition in Lemma 1 is satisfied for all remaining factors with probability (1 − log5 k/k 1+ ).
Now, we combine the effects of the tensor power method step and the orthogonalization step for subsequent iterations to
show that that Xm,t converges to Am . Consider a tensor power method step followed by an orthogonalization step. By
2
2
Lemma 6, if |ŵi âi,t−1 | ≤ βt−1 i 6= m at some time (t − 1), then |ŵi âi,t | ≤ (γcmax + βt−1
+ 3γkcmax βt−1
) for i 6= m
after a tensor power method step. Lemma 4 shows that the correlation of all factors other than the mth factors is still small
after the orthogonalization step if it was small before. Combining the effect of the orthogonalization step via Lemma 4, if
2
2
|ŵi âi,t−1 | ≤ βt−1 i 6= m for some time (t − 1), then |ŵi âi,t | ≤ (γcmax + βt−1
+ 3γkcmax βt−1
)(1 + 1/k 1+ ) for i 6= m
after both the tensor power method and the orthogonalization steps. By also using Lemma 5 for the initialization, can now
write the updated combined recursion analogous to Eq. B.2 and Eq. B.2, but which combines the effect of the tensor power
method step and the orthogonalization step.




β0 = max wi âi,0 
(D.1)
i6=1

βt+1 = (γcmax + βt2 + 3γkcmax βt2 )(1 + 1/k 1+ )
By the previous argument, |wi āi,t | ≤ βt . Note that β0 ≤ 1 − 4/k 1+ by Lemma 5
Lemma 13. βt ≤ 3γcmax ∀ t ≥ O(log k + log log d), also βt < 1 − 1/k 1+ ∀ t
Proof. The proof is very similar to the proof for Lemma 7. We divide the updates into three stages.
1. 0.1 ≤ βt ≤ 1 − 4/k 1+ :
As βt ≥ 0.1 therefore kβt2 ≥ 1 in this regime and hence γcmax ≤ γkβt2 cmax , and we can writeβt+1 = (γcmax + βt2 + 3γkcmax βt2 )(1 + 1/k 1+ )
βt+1 ≤ (βt2 + 4γkcmax βt2 )(1 + 1/k 1+ )
We claim that βt < 0.1 for t = 2 log k. To verify, note thatt

βt ≤ (β0 (1 + 4γ 2 kcmax )(1 + 1/k 1+ ))2

2t
≤ (1 − 4/k 1+ )(1 + 1/k 1+ )(1 + 1/k 1+ )

2t
≤ 1 − 1/k 1+

(D.2)

Orthgonalized ALS for Tensor Decomposition
t

This follows because γkcmax ≤ 1/k 1+ . Note that (1 − 1/k 1+ )2 ≤ 0.1 for t = 2 log k and hence we stay in this
regime for at most 2 log k steps.
2.

√

γη ≤ βt ≤ 0.1 :

For notational convenience, we restart t from 0 in this stage. Because γcmax ≤ γη ≤ βt2 in this regime and
3γkβt2 cmax ≤ 0.1βt2 as γkcmax ≤ 1/k 1+ , we can writeβt+1 = (γcmax + βt2 + 4γkcmax βt2 )(1 + 1/k 1+ )
≤ (βt2 + βt2 + 0.1βt2 )(1 + 1/k 1+ )
≤ 2.5βt2
We claim that βt <

√

γη for t = O(log log(γη)−1 ). To verify, note thatt

βt ≤ (2.5(1 + O(log−2 k))βt1 )2
≤ (0.25)2

t

t
√
Note that (0.25)2 ≤ γη for t = O(log log(γη)−1 ) and hence we stay in this stage for at most O(log log(γη)−1 )
steps. As η −1 = O(d), this stage continues for at most O(log log d) steps.

3. Note that in the next step, βt ≤ (γcmax + 1.1γη)(1 + 1/k 1+ ) ≤ 3γη. This is again because 3γ 2 kβt2 η ≤ 0.1βt2 and
√
βt ≤ γη at the end of the previous stage.

Therefore βt ≤ 3γη for some t = O(log log d + log k). By Lemma 6, |âi,t − ci,1 | ≤ 18γ 2 η 2 , i 6= 1. Hence |âi,t | ≤ 2η.
By Lemma 2, the error at convergence satisfies k Am − Âm k22 ≤ 10γkη 2 and the estimate of the weight w̄m satisfies
m
|1 − ŵ
wm | ≤ O(η).
ˆ i where k ∆
ˆ i k2 ≤ 10γk/d2 , ∀ i < m
Hence we have shown that if the first (m−1) factors have converged to Xi = Ai + ∆
2
ˆ m where k ∆
ˆ m k2 ≤ 10γk/d in O(log k+log log d) steps with probability
then themth factor 
converges to Xm = Am +∆
at least 1 −

log5 k
k1+

. This proves the induction hypothesis.

We can now do a union bound to argue that each factor converges with `2 error at most O(γk/d2 ) in O(log k + log log d)
with overall failure probability at most Õ(1/k − ),  > 0.

E. Proof of additional Lemmas
In this section, we will prove the initialization condition which we used at several points in the proof of convergence of
the tensor power method and Orth-ALS updates. We also provide the proof for a few Lemmas whose proofs were omitted
earlier.


5
|wi ai,0 |
k
1+
Lemma 1. If γkcmax ≤ 1/k 1+ for some  > 0, then with probability at least 1 − log
k1+ , maxi |wi ai,0 | ≤ 1 − 5/k
∀ i 6= arg maxi |wi ai,0 |.
Proof. Without loss of generality, assume arg maxi |wi ai,0 | = 1. We will first express all factors in terms of a particular choice of orthonormal basis vectors {vi }, i ∈ [k]. v1 = A1 , and vi is unit vector along the projection of Ai
orthogonal to {Aj }, j < i. In terms of this basis, A1 = (1, 0, · · · , 0), let A2 = (x1,2 , u2,2 , 0 · · · , 0) and in general
Ai = (xi,1 , xi,2 , · · · , xi,i−1 , ui,i , 0, · · · , 0). We will show that |xi,j | ≤ O(cmax ) for all valid i, j i.e. for all j < i, i ∈ [k].
We claim that |xi,j | ≤ cmax (1 + jcmax ) for all valid i, j. We prove this via induction on j. It is clear that xi,1 ≤
cmax (1+cmax ) for all valid i as hAi , A1 i ≤ cmax , i 6= 1. The induction step is that xi,j ≤ cmax (1+pcmax ) for all valid i and
j ≤ p. We show that this implies that xi,p+1 ≤ cmax (1+(p+1)cmax ) for all valid i. Note that |hAi , Ap+1 i| ≤ cmax ∀ i ≥ p

Orthgonalized ALS for Tensor Decomposition

therefore,
|up+1,p+1 xi,p+1 | ≤ cmax +

p
X

c2max (1 + icmax )2

i=1
p
X
(1 + 4icmax )

≤ cmax +

c2max

≤ cmax +

i=1
2
pcmax + 4p2 c3max

From
hypothesis, |up+1,p+1 | ≥ 1 − 2kc2max . This is because |xi,j | ≤ cmax (1 + jcmax ) ≤ 2cmax =⇒
P 2the induction
2
2
j xi,j ≤ 4cmax =⇒ |up+1,p+1 | ≥ 1 − 2kcmax . Hence,
|xi,p+1 | ≤ (cmax + pc2max + 4p2 c3max )(1 − 2kc2max )−1
≤ (cmax + pc2max + 4p2 c3max )(1 + 4kc2max )
≤ cmax + pc2max + 4k 2 c3max + 4kc3max + 4k 2 c4max + 16k 3 c5max
≤ cmax (1 + (p + 1)cmax )
Therefore |xi,j | ≤ cmax (1 + jcmax ) ≤ 2cmax for all valid i, j. Let the random initialization be (t1 /r, t2 /r,
 · · · , tk/r)
P 2
 wi ti 
10 log4 k
where ti ∼ N (0, 1/d) and r = i ti . Let ui = wi ti . By Lemma 14 with probability at least 1 − k1+ ,  w
≤
1 t1


 
 wi ai,0 
 ti 
1+
1+
1+
1 − 10/k ,  > 0 ∀ i 6= 1. We claim that  w1 a1,0  ≤ 1 − 5/k ,  > 0 ∀ i 6= 1 whenever  t1  ≤ 1 − 10/k ,  >
0 ∀ i 6= 1. This follows becauseP
wi
wi ti ui,i + j<i xi,j wj tj w
wi ai,0
j
=
w1 a1,0
w1 t1
w a  w t  X
w t 
 i i,0   i i 
 i i
=⇒ 
2cmax 
≤
+
γ
w1 a1,0
w 1 t1
w1 t1
j<i
≤ 1 − 10/k 1+ + 2γkcmax
≤ 1 − 10/k 1+ + 1/k 1+
≤ 1 − 5/k 1+

Lemma14. Let ui 
∼ N (0, wi2 ), i ∈ [k] be independent Gaussian random variables. For log4 k ≤ h ≤ k 2 , with probability
4
|wi ui |
at least 1 − logh k , max
≤ 1 − 1/h for all i 6= arg maxi |wi ai,0 |.
i |wi ui |
Proof. We refer to the pdf of ui by fi (x). Without loss of generality, assume arg maxi |wi ai,0 | = 1. As we are only
interested in the ratio of the absolute value of random variables {ui }, we will assume without loss of generality that the
standard deviations or the weights wi have been scaled such that wi ≥ 1. We will use the following tail bound on the
standard Gaussian random variable x (refer to (Duembgen, 2010))2

2

e−t /2
4
2e−t /2
√
√
≤ P[|x| > t] ≤ √
2π 4 + t2 + t
t 2π

(E.1)

Let κ be some variable which satisfies the following relation–
3 log k
1−
≤
k

Pk

i=1

P[|ui | ≤ κ]
2 log k
≤1−
k
k

Let m = maxi ui . As the ui are independent,
P[m > κ] = 1 − Πi P[|ui | ≤ κ]

(E.2)

Orthgonalized ALS for Tensor Decomposition

By the AM-GM inequality Pk

P[|ui | ≤ κ] k
k

2 log k k
1
≤ 1−
≤ 2
k
k

Πi P[|ui | ≤ κ] ≤

i=1

Hence with failure probability at most 1/k 2 the maximum is at least κ.
Instead of drawing k samples from the k distributions corresponding to the k factors, we first draw the maximum m from
the distribution of the maximum of the k samples, and then draw the remaining samples conditioned on the maximum
being m. We have shown that m > κ with high probability. We condition on the maximum m > κ. We now show that
with high probability no sample lies in the range [m(1 − 1/h), m)], given that the maximum is at least κ. After drawing
the maximum from its distribution, we will draw samples from the distributions corresponding to all the k factors even
though one of the factors would already be the maximum m. Clearly this can only increase the probability of a sample
lying in the interval [m(1 − 1/h), m], and as we only want an upper bound this is fine. Let the conditional pdf of the
ith random variable ui conditioned on the maximum being m be gi|m (x). Conditioned on the maximum being m, all
remaining samples are at most m and hence gi|m (x) = fi (x)/P[|ui | ≤ m] for all x ≤ m and is 0 otherwise. We will now
upper bound 1/P[|ui | ≤ m]. We rely on the following observation about the distribution of a standard Normal random
variable x(
0.5t t ∈ [0, 1]
P[|x| ≤ t] ≥
0.5 t > 1

The bound for t ∈ [0, 1] follows from the concavity of the Gaussian cumulative distribution function for t > 0, the bound
for t > 1 is easily verified. Using this, we can write

P[|ui | ≤ m] ≥ 0.5 min

nm
wi

,1

o

We will now find a upper bound on fi (m(1 − 1/k)), the pdf of the samples at m(1 − 1/h). Let ti =

p
fi (m) ≤

m
wi .

Using Eq. E.1-


4 + t2i + ti P[|ui | ≥ m]

4wi
(2ti + 2)P[|ui | ≥ κ]
=⇒ gi|m (m) ≤
4wi P[|ui | ≤ m]
(2ti + 2)P[|ui | ≥ κ]
n
o
≤
2wi min wmi , 1
(ti + 1)P[|ui | ≥ κ]
min{m, wi }
X
X (ti + 1)P[|ui | ≥ κ]
=⇒
gi|m (m) ≤
m/ log k
i:ti ≤log k
i:ti ≤log k
P
2 log2 k i P[|ui | ≥ κ]
≤
m
≤ 6 log3 k/m
≤

(E.3)

Orthgonalized ALS for Tensor Decomposition

where we used Eq. E.2 in the last step. We will now relate gi|m (m) and gi|m (m(1 − 1/h)). We can write,


m2
2+2
)
exp − 2w
2 (1 − 2/h + 1/k
√ i
gi|m (m(1 − 1/h)) =
2πwi P[|ui | ≤ m]


exp − t2i (1 − 2/h)/2
≤ √
2πwi P[|ui | ≤ m]
2

 2
e−ti /2
= √
eti /h
2πwi P[|ui | ≤ m]
2

=⇒

= gi|m (m)eti /h
X
2
gi|m (m(1 − 1/h)) ≤
gi|m (m)eti /h

X
i:ti ≤log k

i:ti ≤log k

≤ 20 log3 k/m
where we used Eq. E.3 in the last step. For all i : ti > log k, we can write,
2

gi|m (m(1 − 1/h)) ≤ √

e−ti (1/2−1/h)
2πwi P[|ui | ≤ m]
2

≤√

2e−ti /3
2π min{m, wi }
2

2e−ti /3
≤√
2πm/ti
2

2ti e−ti /3
≤ √
≤ 1/(k 2 m)
2πm
Therefore,
X

gi|m (m(1 − 1/h)) ≤ 1/(km)

i:ti >log k

=⇒

X

gi|m (m(1 − 1/h)) ≤ 25 log3 k/m

i

Hence the probability of a sample lying in the interval [m(1 − 1/h), m] can be bounded byP[∪(ui ∈ [m(1 − 1/h), m])] ≤

X

P[ui ∈ [m(1 − 1/h), m]]

i

≤

X

gi|m (m(1 − 1/h))

i

m
h

mX
=
gi|m (m(1 − 1/h))
h i
≤
Hence with probability at least (1 − k12 )(1 − 25 log
h
in the interval [m(1 − 1/h), m].

3

k

25 log3 k
h
4

) = 1 − logh

k

the maximum is greater than κ and there are no samples

Lemma 11. For any connected Eulerian graph G, let N be the number of nodes and M be the number of edges. Consider
any decomposition of G into a edge-disjoint set of p cycles. Then, N ≤ M − p + 1. Moreover, if G has four edge-disjoint
paths between a pair of nodes then N ≤ M − p.

Orthgonalized ALS for Tensor Decomposition

Proof. Consider any decomposition of G into a disjoint set of p cycles C1 ∪ C2 · · · ∪ Cp . We will consider the number of
unique nodes in C1 ∪ C2 · · · ∪ Ct for t ≤ p. Let N (C1 ∪ C2 · · · ∪ Ct ) be the number of unique nodes in C1 ∪ C2 · · · ∪ Ct .
Similarly, let M (C1 ∪ C2 · · · ∪ Ct ) be the number of edges in C1 ∪ C2 · · · ∪ Ct . Note that N (C1 ) ≤ M (C1 ). There
must be a cycle in C2 · · · ∪ Cp with at least one node common to C1 as G is connected. Assume C2 has this property.
Then N (C1 ∪ C2 ) ≤ M (C1 ) + M (C2 ) − 1 as C1 and C2 have one node in common. Repeating this argument, at any
stage when we have selected t cycles, there mustP
be a cycle which has not been selected yet but has a node common to the
p
selected cycles. Hence N (C1 ∪ C2 · · · ∪ Cp ) ≤ 1 M (Ci ) − p + 1.
To prove the second part of the Lemma, we claim that if N = M − p + 1 for some decomposition C of G into a disjoint
set of p cycles, then there cannot be more than two disjoint paths between any pair of nodes. By our previous argument, if
N = M − p + 1 then for any union S of connected cycles, any cycle not in S can have at most one node common with the
nodes in S. Note that the number of disjoint set of paths between any pair u and v must be even as the graph is Eulerian.
Assume for the sake of contradiction that there are at least four disjoint paths between two nodes u and v. Consider any set
of cycles S in C which cover any two of the disjoint paths. Say that P is some path which is not covered by S. Then, there
must exist nodes s and t such that s and t are present in C but a segment of the path P is not present in C. We claim that
this implies that for some union S 0 of cycles such that there is some cycle having two nodes common with S 0 . To verify
this, we simply add cycles to S to grow our subgraph from node s till it reaches node t. At some point, there must be a
cycle with two nodes common to the cycles already selected, because we have to reach the node t which has already been
included.

Lemma 2. Let γkcmax ≤ 1/k 1+ . Without loss of generality assume convergence to the first factor A1 . Define
ai,t
âi,t = | a1,t
|- the ratio of the correlation of the ith and 1st factor with the iterate at time t. If âi,t ≤ 2η ∀ i 6= 1,
then k A1 − Â1 k22 ≤ 10γkη 2 in the subsequent iteration. Also, if k A1 − Â1 k22 ≤ O(γkη 2 ) the relative error in the
estimation of the weight w1 is at most O(η).
Proof. Consider any step τ of the power iterations at the end of which |âi,τ | ≤ 2η ∀ i 6= 1. Let the first (largest) factor
have true correlation a1,τ with the iterate at this time step. Consider the next tensor power method update. From the update
formula, the result Zτ +1 isZτ +1 =

Let κ =

k

w1 a21,τ
.
2
2
i=1 w1 ŵi a1,τ âi,τ Ai k2

Pk

Pk

w1 ŵi a21,τ â2i,τ Ai

Pk

w1 ŵi a21,τ â2i,τ Ai k2

i=1

k

i=1

Hence the estimate at the end of the mth iteration is-

Xτ +1 = κ

k
X

ŵi â2i,τ Ai

i=1

= κ(A1 +

X

ŵi â2i,τ Ai )

i6=1

P
ˆ 1 . Note that k ∆
ˆ 1 k2 ≤ 4γkη 2 as |âi,τ | ≤ 2η =⇒ ŵi â2 ≤ 4γη 2 and the factors Ai have
Denote i6=1 ŵi â2i,τ Ai = ∆
i,τ
ˆ 1 k2 . From the triangle inequality,
unit norm. As k Xτ +1 k2 = 1, κ = 1/k A1 + ∆
ˆ 1 k2 ≤ k A1 + ∆
ˆ 1 k2 ≤ 1 + k ∆
ˆ 1 k2
1−k∆
ˆ 1 k2 ≤ 1 + 4γkη 2
=⇒ 1 − 4γkη 2 ≤ k A1 + ∆
1
1
≤κ≤
2
1 + 4γkη
1 − 4γkη 2
2
=⇒ 1 − 4γkη ≤ κ ≤ 1 + 5γkη 2
=⇒

Orthgonalized ALS for Tensor Decomposition

We can now write the error k A1 − Xτ +1 k2 asˆ 1 ) k2
k A1 − Xτ +1 k2 = k A1 − κ(A1 + ∆
ˆ 1 k2
= k A1 (1 − κ) + κ∆
ˆ 1 k2
≤ k A1 (1 − κ) k2 + κk ∆
≤ 5γkη 2 + 4γkη 2 (1 + 5γkη 2 )
≤ 10γkη 2
We also show that the error in estimating the weight w1 of factor A1 is small once we have good estimate of the factor.
w̄1 =

X

=

X

wi hÂ1 , Ai i3

i

ˆ 1 , Ai i3
wi hA1 + ∆

i



 X

ˆ 1 , A1 i3 − w1  + 
ˆ 1 , Ai i3 
wi hA1 + ∆
=⇒ |w1 − w̄1 | ≤ w1 hA1 + ∆
i6=1

≤ 3w1 η + 8

X

wi η 3

i

≤ 3w1 η + 8wi kη 3 ≤ 4w1 η


w̄1 

=⇒ 1 −
 ≤ O(η)
w1
ˆ 1| ≤ k ∆
ˆ 1 k2 ≤ η.
where Eq. E.4 follows as |ATi ∆

(E.4)

