Probabilistic Path Hamiltonian Monte Carlo

6. Appendix

tree space. Moreover, using the same arguments, we can
prove that likelihood function is smooth up to the boundary of each orthant.

6.1. Properties of the phylogenetic posterior
distribution

Now fixing all but two branch lengths te , tf , the likelihood
can be rewritten as
0
1
S
Y
X
@
LT (te , tf ) =
bsij (te )Pijf (tf )A

Assumption 2.3 for the phylogenetic posterior distribution.
Recall that L(⌧, q) denotes the likelihood function of the
tree T = (⌧, q), we have
U (⌧, q) =

log L(⌧, q)

log ⇡0 (⌧, q)

s=1

Since log ⇡0 (⌧, q) is assumed to satisfy the Assumption
2.3, we just need to prove that the phylogenetic likelihood
function is smooth while each orthant and is continuous on
the whole space.
Without loss of generality, we consider the case when a
single branch length of some edge e is contracted to zero.
To investigate the changes in the likelihood function and
its derivatives, we first fix all other branches, partition the
set of all extensions of according to their labels at the
end points of e, and split E(T ) into two sets of edges Eleft
and Eright corresponding to the location of the edges with
respect to e. The likelihood function of the tree T = (⌧, q)
can be rewritten as
0
1
S X X
Y
Y
@
L(T ) =
Pauv
(quv )A
u av
s=1 ij a2Aij

⇥

(u,v)2Eleft

⌘(i)Pije (t)

0

⇥@

Y

(u,v)2Eright

s=1

ij

Consider the tree T 0 obtained by collapsing edge e of the
tree T to zero. The likelihood of T 0 can be written as
0
1
!
S
S
Y
X
Y
X
0
s
e
s
@
L(T ) =
bij Pij (0)A =
bii
s=1

i=j

s=1

and the derivative of the log likelihood is

f 0
S P
s
X
1
@LT
ij bij (te )(Pij ) (tf )
(te , tf ) =
.
P s
f
LT (te , tf ) @tf
ij bij (te )Pij (tf )
s=1

By using the same argument as above, we have that bsij (te )
is continuous in te up to zero and so
lim

te !0

i

since Pij (0) = 1 if i = j and 0 otherwise. Thus
lim LT (t) = L(T 0 ).

t!0

Since this is true for all (⌧, q) and t 2 E(⌧, q), we deduce
that the likelihood function is continuous up to the boundary of each orthant, and thus, is continuous on the whole

1
@LT
1 @L 0
(te , tf ) =
(T ).
LT (te , tf ) @tf
L(T 0 ) @tf

Thus, when a Hamiltonian particle crosses a boundary between orthants, partial derivatives of the energy function
with respect to positive branch lengths are continuous.
6.2. Theoretical properties of the leap-prog integrator
1

Pauv
(quv )A
u av

where t is the branch length of e, ⌘ is the stationary distribution, Aij denotes the set of all extensions of
for
which the labels at the left end point and the right end point
of e are i and j, respectively. By grouping the products
over Eleft and Eright , the stationary frequency ⌘(·), and the
sum over a in a single term bsij , we can define the onedimensional log-likelihood function as a univariate function of the branch length of e
0
1
S
Y
X
@
LT (t) =
bsij Pije (t)A.

ij

Proof of Lemma 3.5. Note that for PPHMC, in a single
leap-prog step of finite size ✏, the algorithm only reevaluates the gradient of the energy function at the end
of the step when the final position q 0 has been fixed, and
changes in topology on the path have no effect on the
changes of position and momentum. Thus, the projection ˜ of to the (q, p) space is just a deterministic reflected Hamiltonian path. As a result, for any s(1) =
(⌧ (1) , q (1) , p(1) ), s(2) = (⌧ (2) , q (2) , p(2) ) 2 R(s), we have
(q (1) , p(1) ) = (q (2) , p(2) ). This, along with the fact that set
of topologies is countable, implies that R(s) is countable.
Now denote by {t(1) < t(2) < . . . < t(n) < . . .  ✏}
the set of time points at which ˜ hits the boundary. Since
this set is strictly increasing, it is countable. Moreover, the
⌧ -component of is only updated with finite choices at
{t(i) }. This implies that K(s) is countable.
Finally, consider any leap-prog step that connects s and
s0 through infinite number of topological changes. We
note that at each t(i) , the next topology is chosen among
x(i)
2 neighboring topologies. Denote by P (s, s0 ) the
probability of moving from s to s0 via path , we have
1
Y
1
= 0.
P (s, s ) 
(i)
x
i=1
0

Since K(s) is countable, we deduce that P1 (s, s0 ) = 0.

Probabilistic Path Hamiltonian Monte Carlo

Proof of Lemma 2.1. Consider any possible path
that
connects s and s0 . By definition, one can find a sequence
of augmented states (s = s(0) , s(1) , s(2) , . . . , s(k) = s0 )
such that can be decomposed into segments on which
the topology does not change. From standard result about
Hamiltonian dynamics, the Hamiltonian is constant on each
segment.
For PPHMC, since the potential energy is continuous
across the boundary and the magnitude of the momentum
does not change when moving from one orthant to another
one, we deduce that the Hamiltonian is constant along that
path.
Similarly, for PPHMC with surrogates, the algorithm is designed in such a way that any changes in potential energy is
balanced by a change in momentum, which conserves the
total energy from one segment to another. We also deduce
that the Hamiltonian is constant along the whole path.
Proof of Lemma 3.1. Define (⌧, q, p) := (⌧, q, p).
Consider any possible leap-prog step
that connects
s and s0 ; say the sequences of augmented states
(s = s(0) , s(1) , s(2) , . . . , s(k) = s0 ), topologies
(⌧ = ⌧ (0) , ⌧ (1) , ⌧ (2) , . . . , ⌧ (k) = ⌧ 0 ) and times (t =
t(0) , t(1) , t(2) , . . . , t(k) = t0 ) decompose into segments
on which the topology is unchanged. Denote by P (s, s0 )
the probability of moving from s to s0 via path , we have
0

P (s, s ) =

Y
i

⇥

P(s

(i+1)

Y
j

(i)

(i+1)

| s ,t

(i)

t )

P(⌧ (j+1) | ⌧ (j) ),

where each sub-step of the algorithm is a leapfrog update ( (i) ) with some momentum reversing ( (i) ), that is
s(i+1) = (i) ( (i) (s(i) )) and (i) is a map that changes the
sign of some momentum coordinates.
If we start the dynamics at (s(i+1) ), then since the particle is crossing the boundary, the momenta corresponding
to the crossing coordinates are immediately negated and the
system is instantly moved to the augmented state
(i)

(s(i+1) ) =

(i)

(s(i+1) ) = (

(i)

(s(i) )).

A standard result about reversibility of Reflective Hamiltonian dynamics implies that the system starting at
( (i) (s(i) )) will end at (s(i) ) after the same period of
time t(i+1) t(i) . We deduce that
P(s(i+1) | s(i) , t(i+1)

t(i) ))

= P( (s(i) ) | (s(i+1) ), t(i+1)

t(i) )).

On the other hand, at time t(j) , (⌧ (j) , q (j) ) and

(⌧ (j+1) , q (j) ) are neighboring topologies, hence
P(⌧ (j+1) | ⌧ (j) ) =
1

1
=
|N (⌧ (j) , q (j) )|

|N (⌧ (j+1) , q (j) )|

= P(⌧ (j) | ⌧ (j+1) ).

Therefore
P (s, s0 ) = P ( (s0 ), (s))
for any path . This completes the proof.
Proof of Lemma 3.2. We denote by C the set of pairs
(s, s0 ) 2 A ⇥ B such that P (s, s0 ) > 0. Let us consider any
possible leap-prog step that connects s 2 A and s0 2 B
crossing a finite number of boundaries and the sequences
of augmented states (s = s(0) , s(1) , s(2) , . . . , s(k) = s0 ),
topologies (⌧ = ⌧ (0) , ⌧ (1) , ⌧ (2) , . . . , ⌧ (k) = ⌧ 0 ), times
(t = t(0) , t(1) , t(2) , . . . , t(k) = t0 ) and indices ↵ =
(↵(0) , ↵(1) , . . . , ↵(k) ) (each ↵(i) is a vector of ±1 entries
characterizing the coordinates crossing zero in each substep) that decompose into segments on which the topology is unchanged. By grouping the members of C by the
value of ↵ and !, we have:
[
C=
C↵,! .
(↵,!)

Because there will typically be many paths between s and
s0 , the C↵,! need not be disjoint. However, we can modify
the (countable number of) sets by picking one set for each
(s, s0 ) and dropping it from the rest, making a collection
of disjoint sets {Cj } such that each Cj is a subset of some
C↵,! and
[
C=
Cj .
j2J

We will write s 2 Aj (s0 ) and s0 2 Bj (s) if (s, s0 ) 2 Cj
and denote
[
[
Aj =
Aj (s0 )
and
Bj =
Bj (s).
s0 2B

s2A

We note that although the leap-prog algorithm is stochastic,
if (↵, !) has been pre-specified, the whole path depends deterministically on the initial momentum. Thus, by denoting
the projection of C↵,! to A by A↵,! , we have that the transformation ↵,! that maps s to s0 is well-defined on A↵,! .
Since the projection of the particles (in a single leap-prog
step) to the (q, p) space is exactly Reflective Hamiltonian
Monte Carlo on Rn 0 . Using Lemma 1, Lemma 2 and Theorem 1 in (Afshar and Domke, 2015), we deduce that the
determinant of the Jacobian of ↵,! is 1.
Now consider any j 2 J such that Cj ⇢ C↵,! . Because
P (s, s0 ) = P (s0 , s) for all s, s0 2 T and the determinant of

Probabilistic Path Hamiltonian Monte Carlo

the Jacobian of
Z
X

Bj s2A (s0 )
j

is 1, we have
Z
0
0
P (s , s) ds =
P (s0 ,
↵,!

1
0
↵,! (s ))

Bj

=
=
=

Z
Z
Z

P(

↵,! (s), s)

ds0

ds

i,! (p)

Aj

P (s,

↵,! (s))

ds

X

P (s, s0 ) ds.

Aj s0 2B (s)
j

[

Aj

and

B⇤ =

j

[

(6.1)

Bj .

j

Summing (6.1) over all possible values of j gives
Z
Z
X
X
P (s0 , s) ds0 =
P (s, s0 ) ds.
B ⇤ s2A(s0 )

A⇤ s0 2B(s)

Moreover, we note that for s 2
/ A⇤ , B(s) = ;. Similarly, if
0
⇤
0
s 2
/ B , A(s ) = ;. We deduce that
Z
Z
X
X
P (s0 , s) ds0 =
P (s, s0 ) ds.
B s2A(s0 )

:= q (i)

8p 2 IB,! ,

are well-defined.

Aj

Denote
A⇤ =

our leap-prog algorithm is stochastic, if the sequence of
topologies crossed by a path ⌃ has been pre-specified,
the whole path depends deterministically on the sequence
of momenta p = (p(0) , . . . , p(m) ) along ⌃. Thus, the
functions

A s0 2B(s)

Proof of Lemma 3.3. By definition of k, for any state
(⌧ 0 , q 0 ) 2 B, we can find a sequence of topologies (⌧ =
⌧ (0) , ⌧ (1) , ⌧ (2) , . . . , ⌧ (k) = ⌧ 0 ) for some l  k such that
⌧ (i) and ⌧ (i+1) are adjacent topologies. From the construction of the state space, let (⌧ (i) , q (i) ) denote a state on the
boundary between the orthants for the two topologies ⌧ (i)
and ⌧ (i+1) . Moreover, since (⌧ (i) , q (i) ) and (⌧ (i+1) , q (i+1) )
lie in the same orthant, we can find momentum values p(i)
and (p(i) )0 such that
P ((⌧ (i) , q (i) , p(i) ) ! (⌧ (i+1) , q (i+1) , (p(i+1) )0 )) > 0

We will prove that n! ,! is Lipschitz by induction on n! .
For the base case n! = 0, the sequence ! is of length 1,
which implies no topological changes along the path. The
leap-prog algorithm reduces to the baseline leapfrog algorithm and from standard results about HMC on Euclidean
spaces (see, e.g., Cances et al., 2007), we deduce that 1,!
is Lipschitz.
Now assume that the results holds true for n! = n. Consider a sequence ! of length n + 1. For all (⌧ 0 , q 0 ) 2 B! ,
let ⌃(⌧ 0 , q 0 ) be a (k, T )-path connecting (⌧ (0) , q (0) ) and
(⌧ 0 , q 0 ). We recall that
F⌃(⌧ 0 ,q0 )
= {(⌧ (0) , q (0) ), (⌧ (1) ,

1,! (p)), . . . , (⌧

(n! )

,

n! ,! (p))},

where n! ,! (p)) = (⌧ 0 , q 0 ), is the set of states that join the
topologies on the path ⌃(⌧ 0 , q 0 ).
Define ! 0 = {⌧ (0) , ⌧ (1) , . . . , ⌧ (n! 1) } and B 0 =
n! 1 (IB,! ), the induction hypothesis implies that the
function n!0 ,!0 = n! 1,! is Lipschitz on IB 0 ,!0 = IB,! .
On the other hand, since (⌧ (n) , q (n) ) and (⌧ (n+1) , q (n+1) )
belong to the same topology, the base case implies that
q (n+1) is a Lipschitz function in p and q (n) = n! 1,! (p).
Since compositions of Lipschitz functions are also Lipschitz, we deduce that n! ,! is Lipschitz.
Since Lipschitz functions map zero measure sets to zero
measure sets (see, e.g., Section 2.2, Theorem 2 and Section
2.4, Theorem 1 of Evans and Gariepy, 2015), this implies
µ(B! ) = 0 which completes the proof.
6.3. Ergodicity of PPHMC

for all i. That is, we can get from (⌧ (i) , q (i) , p(i) ) to
(⌧ (i+1) , q (i+1) , (p(i+1) )0 ) by a sequence of leapfrog steps
⌃(i) with length T . By joining the ⌃(i) ’s, we obtain a
path ⌃ of k PPHMC steps that connects (⌧ (0) , q (0) ) and
(⌧ 0 , q 0 ).

Proof of Lemma 3.6 . We denote

Proof of Lemma 3.4. For a path ⌃ of k PPHMC
steps connecting (⌧ (0) , q (0) ) and (⌧ 0 , q 0 ), we define
F⌃
=
{(⌧ (0) , q (0) ), (⌧ (1) , q (1) ), . . . , (⌧ (n! ) , q (n! ) )},
(i) (i)
where (⌧ , q ) denotes the state on ⌃ that joins the
topologies ⌧ (i) and ⌧ (i+1) . We first note that although

and refer to it as the canonical distribution.

1
exp( U (⌧, q)) exp ( K(p))
Z
1
= exp( H(⌧, q, p))
Z

⌫(⌧, q, p) =

It is straightforward to check that for all s, s0 2 T, we have
⌫(s)r(s, s0 ) = ⌫(s0 )r(s0 , s). Lemma 3.2 implies that
P (s, ds0 )ds = P (s0 , ds)ds0

Probabilistic Path Hamiltonian Monte Carlo

in term of measures. This gives the detailed balance condition
Z Z
⌫(s)r(s, s0 )P (s, ds0 )ds
A B
Z Z
=
⌫(s0 )r(s0 , s)P (s0 , ds)ds0
B

A

for all A, B ⇢ T.

We deduce that every update step of the second step of
PPHMC satisfies detailed balance with respect to ⌫ and
hence, leaves ⌫ invariant. On the other hand, since ⌫ is a
function of |p|, the negation of the momentum p at the end
of the second step also fixes ⌫. Similarly, in the fist step,
p is drawn from its correct conditional distribution given q
and thus leaves ⌫ invariant.

We can bound the second-order term by
✓
◆2 ✓
◆2
@V (1)
@V (0)
(q )
(q )
@qi
@qi
Z ✏
@V (0)
@2V
=2
(q + tp) 2 (q (0) + tp)pi dt
@qi
0 @qi
@W
@2W
= O(✏) ·
sup
(z) 2 (z).
@qi
@qi
z,W =V + ,V
On the other hand for the potential energy,
V = V (q (1) )

V (q (0) )

= V (q (1) )

V (x) + dV (x) + V + (x)
Z ✏
= dV (x) +
rV (q (0) + tp) · p dt
✏1
Z ✏1
+
rV (q (0) + tp) · p dt

Since the target distribution ⇡ is the marginal distribution of
⌫ on the position variables, PPHMC also leaves ⇡ invariant.

V (q (0) )

0

6.4. Approximation error of reflective leapfrog
algorithm
In this section, we investigate the local approximation error of the reflective leapfrog algorithm (Afshar and Domke,
2015) without using surrogates. Recall that V + and V
are the restrictions of the potential function V on the sets
{x1 0} and {x1  0}, and we assume that V + and V
are smooth up to the boundary of their domains.
Consider a reflective leapfrog step with potential energy
(0)
function V starting at (q (0) , p(0) ) (with q1 > 0), ending
(1)
at (q (1) , p(1) ) (with q1 < 0) and hitting the boundary at x
(with x1 = 0, i.e., a refraction event happens on the hyperplane of the first component).
Proof of Proposition 3.1. Let p and p0 denote the half-step
momentum of a leapfrog step before and after the refraction events, respectively. Recall that in a leapfrog approximation with refraction at x1 = 0, we have
(0)

pi

= pi +

✏ @V (0)
(q ),
2 @qi

where
p01 =

q

p21

(1)

pi

= p0i

where ✏1 and ✏2 := ✏ ✏1 denote the integration times
before and after refraction. By the trapezoid rule for integration,
◆
X ✏ ✓ @V
@V (1)
V = dV (x) +
pi
(q (0) ) + p0i
(q )
2
@qi
@qi
i>1
p01 ✏2 @V (1)
p0 ✏2 @V
(q ) + 1
(x)
2 @q1
2 @q1
p1 ✏1 @V (0)
p1 ✏1 @V +
+
(q ) +
(x)
2 @q1
2 @q1
✓ 3
◆
X
@ W
+ O(✏3 ) · sup
(z)
.
@qi3
z
+
+

i,W =V

We recall that the error of the trapezoid rule on [a, b] with
resolution h is a constant multiple of h2 (b a), which is of
order ✏3 in our case. We deduce that
H=

V +

✏ @V (1)
(q ),
2 @qi

2dV (x),

K=

p01 ✏1 @V (1)
(q ) +
2 @q1
p1 ✏2 @V (0)
(q ) +
2 @q1
+ O(✏3 ).

p01 ✏2 @V
(x)
2 @q1
p1 ✏1 @V +
(x)
2 @q1

Using Taylor expansion, we have

p0i = pi for i > 1, and dV (x) = V (x) V + (x) denotes
the change in potential energy across the hyper-plane.
The change in kinetic energy after this leapfrog step is
✓
◆
✏X
@V (0)
0 @V
(1)
K = dV (x)
pi
(q ) + pi
(q )
2 i
@qi
@qi
✓
◆2 ✓
◆2 !
✏2 X
@V (1)
@V (0)
+
(q )
(q )
.
8 i
@qi
@qi

,V

@V (1)
@V
(q ) =
(x) + O(✏),
@q1
@q1
and

@V (0)
@V
(q ) =
(x) + O(✏).
@q1
@q1

This implies
H = (✏2

✓
@V
✏1 ) p01
(x)
@q1

p1

◆
@V +
(x) + O(✏2 ).
@q1

Probabilistic Path Hamiltonian Monte Carlo

In general, there is no dependency between ✏1 and ✏2 , and
the only cases where H is not of order O(✏) are when
q
p21

2dV (x)

@V
(x)
@q1

p1

@V +
(x) = 0.
@q1

In order for this to be true for all p, we need to have either

or

@V
@V +
(x) =
(x),
@q1
@q1

and

dV (x) = 0

@V
@V +
(x) =
(x) = 0.
@q1
@q1

In both cases, the first derivative of V with respect to the
first component must be continuous. This completes the
proof.
6.5. Estimated posterior tree distributions for the
simulated data

EstiPDtHd postHrior proEDEility

EstiPDtHd 3ostHrior DistriEution for trHHs
0rBDyHs
33H0C

0.12
0.10
0.08
0.06
0.04
0.02

0
B1

B9

HH
tr

tr

HH

B8

B7

HH
tr

tr

HH

B6

B5

HH
tr

B4

HH
tr

B3

HH
tr

B2

HH
tr

HH
tr

tr

HH

B1

0.00

Figure 3. Estimated posterior distributions for the top 10 trees
from the ground truth for MrBayes (blue) and PPHMC (orange),
respectively.

6.6. Coordinate systems for branch lengths on trees
In this section we verify Assumption 2.1 for phylogenetic
trees. Further explanation of the framework used here can
be found in (Semple and Steel, 2003; Bryant, 2004).
Assume we are considering phylogenetic trees on N leaves,
and that those leaves have labels [N ] := {1, . . . , N }. Every possible edge in such a phylogenetic tree can be described by its corresponding split, which is a partition of
[N ] into two non-empty sets, by removing that edge of the
tree and observing the resulting partitioning of the leaf labels. If a split can be obtained by deleting such an edge
of a given phylogenetic tree, we say that the tree displays

that split. We use a vertical bar (|) to denote the division
between the two sets of the bipartition. For example, if we
take the unrooted tree with four leaves such that 1 and 2 are
sister to one another, the tree displays splits 1|234, 12|34,
134|2, 124|3, and 123|4. Two splits A|B and C|D on the
same leaf set are called compatible if one of A \ C, B \ C,
A \ D, or B \ D is empty. A set of splits that are pairwise
compatible can be displayed on a phylogenetic tree (Buneman, 1971), and in fact the set of pairwise compatible sets
of splits is in one-to-one correspondence with the set of
(potentially multifurcating) unrooted phylogenetic trees.
When a single branch length goes to zero, N (⌧, q) will
have three elements: ⌧ itself and its two NNI neighbors.
When multiple branch lengths go to zero, one can reexpand branch lengths for any set of splits that are compatible with each other and with the splits that did not originally
go to zero. This generalizes the NNI condition. However,
the correspondence between the branches that went to zero
and the newly expanded branches is no longer obvious.
One can define such a correspondence using a global splitsbased coordinate system. Namely, such a coordinate system can be achieved by indexing branch length vectors by
splits, with the proviso that for any two incompatible splits
r and s, one of qr or qs is zero. We could have used such
a coordinate system for this paper, such that branch length
N 1
vectors q would live in R2
.
However, for simplicity of notation, we have indexed the
branch lengths (e.g. in Algorithm 1) with integers [n] corresponding to the actual branches of a phylogenetic tree.
Thus our branch length vectors q live in 2N 3 dimensions. One can use a total order on the splits to unambiguously define which branches map to which others when the
HMC crosses a boundary. We will describe how this works
when two branch lengths, qi and qj , go to zero. The extension to more branch lengths is clear.
Our branch indices i, j 2 [2N 3] are always associated
with a phylogenetic tree ⌧ with numbered edges. For any
branch index i on ⌧ , one can unambiguously take the split
si . Assume without loss of generality that si < sj in the
total order on splits. Now, when qi and qj go to zero, one
can transition to a new tree ⌧ 0 which may differ from ⌧ by
up to two splits. We assume without loss of generality that
these are actually new splits (if not, we are in a previously
defined setting) which we call s01 and s02 such that s01 < s02 .
We carry all of the branch indices for branches that aren’t
shrinking to zero across to ⌧ 0 . Then map branch i in ⌧ to
the branch in ⌧ 0 corresponding to the split s01 , and branch j
to the branch in ⌧ 0 corresponding to the split s02 . Thus, for
example, the momentum qi in the ⌧ orthant is carried over
to this corresponding qi in the ⌧ 0 orthant.

