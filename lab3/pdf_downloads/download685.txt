Canopy â€” Fast Sampling with Cover Trees

A. Alias Sampler
A key component is the alias sampler of (Walker, 1977). Given an arbitrary discrete probability distribution on n outcomes, it
allows for O(1) sampling once an O(n) preprocessing step has been performed. Hence, drawing n observations a distribution
over n outcomes costs an amortized O(1) per sample. Given probabilities Ï€i with Ï€ âˆˆ Pn the algorithm proceeds as follows:
â€¢ Decompose {1, . . . n} into sets L, H with i âˆˆ L if Ï€i < nâˆ’1 and i âˆˆ H otherwise.
â€¢ For each i âˆˆ L pick some j âˆˆ H.
â€“ Append the triple (i, j, Ï€i ) to an array A
â€“ Set residual Ï€j0 := Ï€j + Ï€i âˆ’ nâˆ’1
â€“ If Ï€j0 > nâˆ’1 return Ï€j0 to H, otherwise to L.
Preprocessing takes O(n) computation and memory since we remove one element at a time from L.
â€¢ To sample from the array pick u âˆ¼ U (0, 1) uniformly at random.
â€¢ Choose the tuple (i, j, Ï€i ) at position bunc.
â€¢ If u âˆ’ nâˆ’1 bunc < Ï€i return i, else return j.
This step costs O(1) operations and it follows by construction that i is returned with probability Ï€i . Now we need a data
structure that will allow us to sample many objects in bulk without the need to inspect each item individually. Cover trees
satisfy this requirement.

B. Rejection Sampling
B.1. Flat Clusters
The proof for the proposed rejection sampler in case of sampling a cluster for a single observation x is as follows. If we
approximate p(x|Î¸z ) by some qz such that
eâˆ’ p(x|Î¸z ) â‰¤ qz â‰¤ e p(x|Î¸z )

(13)

then it follows that a sampler drawing z from
qz p(z)
0
0
z 0 qz p(z )

zâˆ¼P

(14)

and then accepting with probability eâˆ’ qzâˆ’1 p(x|Î¸z ) will draw from p(z|x). To prove this, we begin by computing the
probability of this sampler r(z) to return a particular value z. The sampler returnsP
z when it (a) samples and
Paccepts z, or (b)
samples any value, rejects it to proceed to next iteration of sampling. Using Î³ = z0 qz0 p(z 0 ) and Î³T = z0 p(x|Î¸z0 )p(z 0 )
to denote normalization for proposal and true posterior respectively, we have:
r(z) =

X
qz p(z) âˆ’ âˆ’1
qz0 p(z 0 )
e qz p(x|Î¸z ) +
(1 âˆ’ eâˆ’ qzâˆ’1
r(z)
0 p(x|Î¸z 0 ))
Î³
Î³
0
z

eâˆ’
r(z) X
eâˆ’ X
=
p(z)p(x|Î¸z ) +
qz0 p(z 0 ) âˆ’ r(z)
p(x|Î¸z0 )p(z 0 )
Î³
Î³
Î³
0
0
z

z

(15)

eâˆ’
eâˆ’
p(z)p(x|Î¸z ) + r(z) âˆ’ r(z)
Î³T
=
Î³
Î³
p(z)p(x|Î¸z )
r(z) =
Î³T
Hence the procedure will draw from the true posterior p(z|x).
B.2. Clusters Arranged in Cover Tree
We now extend the above proof strategy when the clusters are arranged in a cover tree, thereby proving the correctness of
our rejection sampler in Sec. 3.2.2.

Canopy â€” Fast Sampling with Cover Trees

Similar to previous case, we approximate p(x|Î¸z ) for z in level i by some qz such that
eâˆ’i p(x|Î¸z ) â‰¤ qz â‰¤ ei p(x|Î¸z ).

(16)

Note that approximation error i now depends on the location of the cluster in the cover tree. To be specific, if the cluster z
is located at level i, then i = 2i kÏ†Ì„(x)k. Also, we assume the path to reach the node z starting from its (grand) parent at
level Ä±Ì‚ is given by T = [T (Ä±Ì‚), T (Ä±Ì‚ âˆ’ 1), ..., T (i)], with T (i) = z.
To prove the correctness of our rejection sampler in Sec. 3.2.1, we simply show that probability of this sampler to return a
particular value z is equal to the true posterior. The sampler returns z when it (a) reaches the corresponding node in the
cover tree and accepts it, or (b) rejects or exits to proceed to next iteration of sampling. So, the probability of this sampler to
return z is given by:
+
r(z)
E
(17)
r(z) =
A(z)
|{z}
| {z }
Probability of the
sampler rejecting or exiting

Probability of the
sampler accepting z

We calculate
these individual terms beginning with the probability of sampler accepting z. Using Î³ as defined in (10) and
P
Î³T = z0 p(x|Î¸z0 )p(z 0 ), we have:
ï£®

ï£¹

ï£º
ï£¯
ï£º
ï£¯ Ä±Ì‚ 

ï£º
ï£¯
i0 âˆ’1
0
0
0
Y
e Î²(Ä±Ì‚, T (Ä±Ì‚))p(x|Î¸T (Ä±Ì‚) ) ï£¯
e
Î²(i âˆ’ 1, T (i âˆ’ 1))p(x|Î¸T (i0 âˆ’1) )
p(T (i ))p(x|Î¸T (i0 ) )
ï£º
A(z) =
1âˆ’ 0
ï£º
ï£¯
ï£¯0
Î³
e i Î²(i0 , T (i0 ))p(x|Î¸T (i0 ) ) ei0 Î²(i0 , T (i0 ))p(x|Î¸T (i0 ) ) âˆ’ p(T (i0 ))p(x|Î¸T (i0 ) ) ï£º
ï£º
|
{z
} ï£¯|i =i+1
{z
}
{z
}
|
|
ï£»
ï£° {z }
Selecting the first parent (Step 4)
Ä±Ì‚

The loop
(Step 5)

Rejecting the nodes (Step 5iii)

Selecting the next node (Step 5ii)

Ã—

p(z)p(x|Î¸z )
ei Î²(i, T (i))p(x|Î¸T (i) )
|
{z
}
Accepting node z

#
Ä±Ì‚
e Î²(Ä±Ì‚, T (Ä±Ì‚))p(x|Î¸T (Ä±Ì‚) ) Y ei0 âˆ’1 Î²(i0 âˆ’ 1, T (i0 âˆ’ 1))p(x|Î¸T (i0 âˆ’1) )
p(z)p(x|Î¸z )
=

0
0

0
i
i
0
Î³
e Î²(i , T (i ))p(x|Î¸T (i ) )
e Î²(i, T (i))p(x|Î¸T (i) )
i0 =i+1
 i

Ä±Ì‚
e Î²(Ä±Ì‚, T (Ä±Ì‚))p(x|Î¸T (Ä±Ì‚) ) e Î²(i, T (i))p(x|Î¸T (i) )
p(z)p(x|Î¸z )
=


i
Ä±Ì‚
Î³
e Î²(Ä±Ì‚, T (Ä±Ì‚))p(x|Î¸T (Ä±Ì‚) ) e Î²(i, T (i))p(x|Î¸T (i) )
Ä±Ì‚

=

p(z)p(x|Î¸z )
Î³

"

(by telescoping)
(18)

Next, the probability of rejecting or exiting from the sampler is one minus probability of accepting any node z, i.e.
X
E =1âˆ’
A(z 0 )
z 0 âˆˆZ

X p(z 0 )p(x|Î¸z0 )
Î³
z 0 âˆˆZ
Î³T
=1âˆ’
Î³
=1âˆ’

(19)

Plugging back the acceptance and exit probabilities into (17):
r(z) = A(z) + r(z)E


p(z)p(x|Î¸z )
Î³T
=
+ r(z) 1 âˆ’
Î³
Î³
p(z)p(x|Î¸z )
Î³T
=
+ r(z) âˆ’ r(z)
Î³
Î³
p(z)p(x|Î¸z )
r(z) =
Î³T

(20)

Canopy â€” Fast Sampling with Cover Trees

(a) Expansion rate

(b) Separation property

(c) Covering property

Figure 6. Illustration of various properties of covering tree.

Hence the procedure will draw from the true posterior p(z|x).
The above describes a rejection sampler that keeps on upper-bounding the probability of accepting a particular parameter or
any of its children. It is as aggressive as possible at retaining tight lower bounds on the acceptance probability such that
not too much effort is wasted in traversing the cover tree to he bottom. In other words, we attempt to reject as quickly as
possible. Some computational considerations are in order:
D
E
1. The computationally most expensive part is to compute the inner products Ï†Ìƒ(x), Î¸Ìƒz .
2. As soon as we compute this value for a particular Î¸Ìƒz we cache it at the corresponding vertex of the cover tree.
3. To avoid expensive bookkeeping we attach to each vertex two variables: the value of the last compute inner product
and the observation ID of x that it is associated with. +

C. Cover Trees
Cover Trees (Beygelzimer et al., 2006) and their improved version (Izbicki & Shelton, 2015) form a hierarchical data
structure that allows fast retrieval in logarithmic time. The key properties for the purpose of this paper are that it allows for
O(n log n) construction time, O(log n) retrieval, and that it only depends polynomially on the expansion rate (Karger &
Ruhl, 2002) of the underlying space, which we refer to as c. Moreover, the degree of all internal nodes is well controlled,
thus giving guarantees for retrieval (as exploited in (Beygelzimer et al., 2006)), and for sampling (as we will be using in this
paper).
The expansion rate of a set, due to (Karger & Ruhl, 2002) captures several key properties.
Definition 2 (Expansion Rate) Denote by BÏ (r) a ball of radius of r centered at Ï. Then a set S has a (l, c) expansion
rate iff all r > 0 and Ï âˆˆ S satisfy
|BÏ (r) âˆ© S| â‰¥ l =â‡’ |BÏ (2r) âˆ© S| â‰¤ c |BÏ (r) âˆ© S| .

(21)

In the following we set l = O(log |S|), thus referring to c simply as the expansion rate of S.
Cover trees are defined as an infinite succession of levels Si with i âˆˆ Z. Each level i contains (a nested subset of) the data
with the following properties:
â€¢
â€¢
â€¢
â€¢

Nesting property: Si âŠ† Siâˆ’1 .
Separation property: All x, x0 âˆˆ Si satisfy kx âˆ’ x0 k â‰¥ 2i .
All x âˆˆ Siâˆ’1 have a parent in x0 âˆˆ Si , possibly with x = x0 , with kx âˆ’ x0 k â‰¤ 2i .
As a consequence, the subtree for any x âˆˆ Si has distance at most 2i+1 from x.

Clearly we need to reperesent each x only once, namely in terms of Si with the largest i for which x âˆˆ Si holds. This data
structure has a number of highly desirable properties, as proved in (Beygelzimer et al., 2006). We list the most relevant ones
below:
â€¢ The depth of the tree in terms of its explicit representation is at most O(c2 log n).

Canopy â€” Fast Sampling with Cover Trees

â€¢ The maximum degree of any node is O(c4 ).
â€¢ Insertion & removal take at most O(c6 log n) time.
â€¢ Retrieval of the nearest neighbor takes at most O(c12 log n) time.
â€¢ The time to construct the tree is O(c6 n log n).
The fast lookup of cover tree is built upon the implicit assumption in terms of the distinguishability of parameters Î¸z , which
we also borrow in Canopy. This is related to the issue that if we had many choices of Î¸z that, a-priori, all looked quite
relevant yet distinct, we would have no efficient means of evaluating them short of testing all by brute force. Note that this
could be achieved, e.g. by using the fast hash approximation of a sampler in (Ahmed et al., 2012). This is complementary to
the present paper.

D. Theoretical Analysis
Some more conclusions we can make about the algorithm Canopy I:
Remark 3 (Rejection Sampler) The same reasoning yields a rejection sampler since
ïš¾Ì„+1
p(z|xÌ„)
â‰¥ eâˆ’kÏ†(x)âˆ’Ï†(xÌ„)kkÎ¸z k â‰¥ eâˆ’2 L .
p(z|x)

(22)

Here we may bound each term (and the normalization) in computing p(z|x) appropriately.
Remark 4 The efficiency of the sampler increases as the sample size m increases. In particular,
an increase of m by O(c4 )
âˆš
is guaranteed to decrease ïš¾Ì„ by 1, thus increasing the acceptance probability Ï€ from Ï€ to Ï€. This follows from the fact that
each node in the cover tree has at most O(c4 ) children.
Remark 5 There is no need to build a cover tree to a level beyond ïš¾Ì„ since we do not exploit the improvement. This could be
used to remove the logarithmic dependence O(n log n) in constructing the cover tree and reduce it to O(nïš¾Ì„).

E. Feature Extraction
E.1. Denoising Autoencoder for MNIST
The autoencoder consists of an encoder with fully connected layers of size (28x28)-1000-500-250-30 and a symmetric
decoder. The thirty units in the code layer were linear and all the other units were logistic. The network was trained on the 8
million images using mean square error loss.
E.2. Denoising Autoencoder for CIFAR100
The autoencoder consists of an encoder with convolutional layers of size (3x32x32)-(64, 5, 5)-(32, 5, 5)-(16, 4, 4) and having
a 2x2 max pooling after each convolutional layer. The decoder is symmetric with max pooling replaced by upsampling. The
256 units in the code layer were linear and all the other internal units were RelU while the final layer was sigmoid. The
network was trained on the 50 thousand images using mean square error loss.
E.3. ResNet for ImageNet
We use the state of the art deep convolutional neural network (DCNN), based on the ResNet (â€Residual Networkâ€)
architecture (He et al., 2015; 2016). ResNet consists of small building blocks of layers which learn the residual functions
with reference to the input. It is demonstrated that ResNet is able to train networks that are substantially deeper without the
problem of noisy backpropagation gradient. For feature extraction We use a 200 layer ResNet that is trained on a task of
classification on ImageNet. In the process, the network learned which high-level visual features (and combinations of those
features) are important. After training the model, we remove the final classification layer of the network and extract from the
next-to-last layer of the DCNN, as the representation of the input image which is of dimension 2048.

Canopy â€” Fast Sampling with Cover Trees

F. Further Experimental Results

Clusters
10

100

Clusters
10

100

Clusters
100

500

Clusters
100

500

Method
EM
SEM
Canopy I
Canopy II

s/iter
39.588 Â± 1.801
7.124 Â± 0.241
7.453 Â± 0.255
7.534 Â± 0.320

EM
SEM
Canopy I
Canopy II

512.185 Â± 13.295
10.085 Â± 0.162
6.882 Â± 0.174
6.483 Â± 0.298

Method
EM
SEM
Canopy I
Canopy II

s/iter
6.595 Â± 0.230
0.943 Â± 0.037
0.932 Â± 0.027
1.008 Â± 0.053

EM
SEM
Canopy I
Canopy II

56.640 Â± 1.060
4.006 Â± 0.050
1.220 Â± 0.025
1.015 Â± 0.029

Method
EM
SEM
Canopy I
Canopy II

MNIST8m - Direct
Random I
Random II
LLH
Purity
LLH
Purity
3.04 Ã—107
32.39%
3.05 Ã—107
30.76%
3.04 Ã—107
32.33%
3.03 Ã—107
30.65%
1.49 Ã—107
42.12%
1.49 Ã—107
40.51%
1.49 Ã—107
42.85%
1.49 Ã—107
40.69%

KMeans++
LLH
Purity
3.04 Ã—107
30.81%
3.04 Ã—107
30.61%
1.49 Ã—107
40.41%
1.49 Ã—107
40.95%

CoverTree
LLH
Purity
3.05 Ã—107
30.50%
3.04 Ã—107
31.69%
1.50 Ã—107
42.84%
1.50 Ã—107
42.59%

3.27 Ã—107
3.34 Ã—107
2.02 Ã—107
1.91 Ã—107

3.28 Ã—107
3.34 Ã—107
2.01 Ã—107
1.90 Ã—107

3.32 Ã—107
3.33 Ã—107
2.02 Ã—107
1.90 Ã—107

53.20%
3.26 Ã—107
53.24%
53.19%
3.34 Ã—107
53.21%
53.39%
2.04 Ã—107
53.53%
60.19%
1.90 Ã—107
61.09%
MNIST8m - Embedding
Random I
Random II
LLH (Ã—107 ) Purity LLH (Ã—107 ) Purity
-4.35 Ã—105
58.43%
-4.36 Ã—105
63.14%
-4.35 Ã—105
58.43%
-4.35 Ã—105
62.05%
-4.35 Ã—105
58.78%
-4.36 Ã—105
61.61%
-4.35 Ã—105
58.78%
-4.35 Ã—105
62.30%
-3.93 Ã—105
-3.93 Ã—105
-3.96 Ã—105
-3.97 Ã—105

52.45%
52.42%
53.88%
60.61%

KMeans++
LLH (Ã—107 ) Purity
-4.35 Ã—105
63.19%
-4.36 Ã—105
61.44%
-4.35 Ã—105
64.46%
-4.36 Ã—105
61.69%

53.10%
53.52%
52.69%
60.29%

CoverTree
LLH (Ã—107 ) Purity
-4.34 Ã—105
63.22%
-4.35 Ã—105
60.58%
-4.35 Ã—105
58.78%
-4.35 Ã—105
58.78%

-3.94 Ã—105
-3.94 Ã—105
-3.97 Ã—105
-3.97 Ã—105

s/iter
78.019 Â± 10.702
1.055 Â± 0.095
1.027 Â± 0.095
1.190 Â± 0.099

83.95%
-3.94 Ã—105
82.33%
83.99%
-3.93 Ã—105
83.37%
83.44%
-3.96 Ã—105
83.20%
82.77%
-3.97 Ã—105
83.21%
CIFAR100 - Direct
Random I
Random II
LLH
Purity
LLH
Purity
2.86 Ã—106
14.27%
3.03 Ã—106
13.31%
2.93 Ã—106
14.08%
2.93 Ã—106
14.12%
3.20 Ã—106
12.98%
3.36 Ã—106
12.43%
2.99 Ã—106
12.87%
3.08 Ã—106
13.23%

KMeans++
LLH
Purity
3.09 Ã—106
13.84%
2.86 Ã—106
14.75%
3.21 Ã—106
13.55%
3.28 Ã—106
13.72%

CoverTree
LLH
Purity
3.09 Ã—106
14.19%
3.00 Ã—106
14.90%
3.25 Ã—106
12.91%
3.08 Ã—106
12.87%

EM
SEM
Canopy I
Canopy II

407.764 Â± 18.160
6.486 Â± 0.613
2.745 Â± 0.225
1.908 Â± 0.152

3.37 Ã—106
3.39 Ã—106
3.38 Ã—106
3.17 Ã—106

3.27 Ã—106
3.36 Ã—106
3.45 Ã—106
3.19 Ã—106

3.31 Ã—106
3.22 Ã—106
3.44 Ã—106
3.19 Ã—106

Method
EM
SEM
Canopy I
Canopy II

s/iter
12.589 Â± 0.255
0.491 Â± 0.022
0.315 Â± 0.014
0.313 Â± 0.124

25.19%
3.31 Ã—106
24.70%
25.14%
3.30 Ã—106
24.33%
22.35%
3.50 Ã—106
22.14%
22.68%
3.18 Ã—106
22.83%
CIFAR100 - Embedding
Random I
Random II
LLH
Purity
LLH
Purity
5.45 Ã—105
12.38%
5.50 Ã—105
12.14%
5.46 Ã—105
12.21%
5.53 Ã—105
11.57%
5.01 Ã—105
12.34%
5.04 Ã—105
11.96%
5.00 Ã—105
12.50%
5.02 Ã—105
11.97%

KMeans++
LLH
Purity
5.50 Ã—105
12.25%
5.45 Ã—105
12.72%
4.99 Ã—105
13.16%
4.99 Ã—105
13.01%

CoverTree
LLH
Purity
5.46 Ã—105
12.59%
5.47 Ã—105
12.68%
5.06 Ã—105
12.30%
5.02 Ã—105
12.29%

EM
SEM
Canopy I
Canopy II

62.520 Â± 1.135
2.276 Â± 0.112
0.963 Â± 0.061
0.333 Â± 0.101

6.94 Ã—105
6.92 Ã—105
6.25 Ã—105
6.20 Ã—105

6.86 Ã—105
6.85 Ã—105
6.14 Ã—105
6.12 Ã—105

6.86 Ã—105
6.85 Ã—105
6.24 Ã—105
6.18 Ã—105

19.17%
18.97%
20.07%
22.26%

6.96 Ã—105
6.93 Ã—105
6.21 Ã—105
6.16 Ã—105

18.93%
18.64%
19.19%
21.61%

83.44%
83.05%
83.48%
82.66%

26.03%
26.16%
24.03%
24.91%

21.13%
21.16%
21.57%
23.18%

-3.94 Ã—105
-3.95 Ã—105
-3.96 Ã—105
-3.97 Ã—105

82.77%
83.44%
83.22%
82.66%

25.59%
25.39%
22.31%
22.71%

21.05%
21.20%
20.04%
22.25%

Table 1. Comparison of ESCA, Canopy I and Canopy II on cluster purity and loglikelihood on real, benchmark datasetsâ€“MNIST8m and
CIFAR-100. Additionally, standard deviations are shown for 5 runs.

F.1. Image Clustering
We sample images from varied sized clusters, as described below, to study the semantic concept they usually represent: (a)
> 10k members: As our dataset is extracted from Flickr, a photo sharing platform, it is heavily biased towards everyday
objects like humans, flowers, birds, etc. We found several consistent clusters containing people (sitting, standing, crowd). (b)
> 5 but < 10k members: These contains less common semantic groups like swings, transmission lines, etc, out of which
some are absent as explicit concepts in underlying Resnet model. (c) < 5 members: We found around 15% small sized
clusters which are typically outliers containing less than 5 images. Fig. 7 contains more examples.

Canopy â€” Fast Sampling with Cover Trees

Figure 7. Illustration of concepts captured by clustering images in the feature space extracted by ResNet (He et al., 2015; 2016). Figure
shows four closest images of seven more randomly selected clusters (one in each row) possibly denoting the semantic concepts of â€˜electrical
transmission linesâ€™, â€˜image with textâ€™, â€˜lego toysâ€™, â€˜lighteningâ€™, â€˜Auroraâ€™, â€˜buggyâ€™ and â€˜eyesâ€™. Few of the concepts are discovered by
clustering as Resnet received supervision only for 1000 categories (for example does not include label â€˜lighteningâ€™, â€˜thunderâ€™, or â€˜stormâ€™).
Full set of 1000 imagenet label can be seen at http://image-net.org/challenges/LSVRC/2014/browse-synsets.

Canopy â€” Fast Sampling with Cover Trees

G. Graphical Explanation
We now present insights about our approach graphically.
2/37

3/37

Motivation

Inference Strategy

ï‚„

They are used in diverse fields ranging from text, images,
to user modelling and content recommendations.

ï‚„

Inference is often slow
8.19E+03

-10000

2.05E+03

-12500

5.12E+02

-15000

1.28E+02

-17500

3.20E+01

EM

ESCA

Canopy I

Canopy II

ï‚„

Inference using Gibbs sampling, stochastic EM, or
stochastic variational methods requires drawing from

Log-likelihood

Latent variable models (LVM), such as Mixture Models,
Latent Dirichlet Allocation, are popular tools in statistical
data analysis.

Time (s/iter)

ï‚„

z
Global

-20000

4/37

5/37

Inference Strategy

Insights

ï‚„

Inference using Gibbs sampling, stochastic EM, or
stochastic variational methods requires drawing from

ï‚„

Assume exponential family, i.e.

ï‚„

Local

For example assume we have following data:

z
Global

Local

6/37

7/37

Insights

Insights

ï‚„

For example assume we have following data:

ï‚„

For example assume we have following data:

ï‚„

Two key observations

ï‚„

Two key observations

ï‚„
ï‚„

Points close by will have similar posteriors
No need to consider clusters far away

ï‚„
ï‚„

ï‚„

Points close by will have similar posteriors
No need to consider clusters far away

Two tools to exploit the observations
ï‚„
ï‚„

Cover trees
Metropolis Hasting sampling

Canopy â€” Fast Sampling with Cover Trees

8/37

9/37

Cover Tree

Cover Tree

ï‚„

Cover tree is a hierarchical data structure

ï‚„

Cover tree is a hierarchical data structure

ï‚„

Covering property:

10/37

11/37

Cover Tree

Computational Cost of Cover Trees

ï‚„

Cover tree is a hierarchical data structure

ï‚„

Covering property:

ï‚„

Separating property:

ï‚„

Does not depend on the dimension of the data

ï‚„

c: Expansion rate of data or Hausdorff dimension
(special case of fractal dimension)

12/37

13/37

Insights

Metropolis Hasting Sampling

ï‚„

For example assume we have following data:

ï‚„

Two key observations
ï‚„
ï‚„

ï‚„

ï‚„

Enables us to construct sound sampler that incorporates
our intuitions

Points close by will have similar posteriors
No need to consider clusters far away

Accept/
Reject

Two tools to exploit the observations
ï‚„
ï‚„

Cover trees
Metropolis Hasting sampling

An easy to draw
distribution

Acceptance
probability

Sample
from p
Only need to
look at a few
probabilities!

Canopy â€” Fast Sampling with Cover Trees

14/37

15/37

How to Design a Good Proposal?

How to Design a Good Proposal?

ï‚„

For example assume we have following data:

ï‚„

For example assume we have following data:

ï‚„

Suppose for each point x we can find surrogates

16/37

17/37

How to Design a Good Proposal?

Outline

ï‚„

For example assume we have following data:

ï‚„

Background
ï‚„
ï‚„
ï‚„

ï‚„
ï‚„

Suppose for each point x we can find surrogates

ï‚„

Then

ï‚„

ï‚„
ï‚„
ï‚„

Canopy: Proposed Method
ï‚„

becomes a good proposal for

Moderate number of clusters
Large number of clusters

Experimental Results
ï‚„

Compute alias table and re-use for many points
Cost for sampling from proposal given alias table is O(1)

Latent Variable Models
Cover tree
Metropolis Hastings

ï‚„

Synthetic data
Images

18/37

19/37

Canopy I â€“ Method 1

Canopy I â€“ Method 2

ï‚„

Data:

Build a cover tree on data points â€“ Cost

Cover Tree:

ï‚„

Build a cover tree on data points â€“ Cost

ï‚„

Pick an accuracy level having

Data:

elements

Cover Tree:

1

1

2
3

4

6
5

7

8

2
9

3

4

6
5

7

8

9

Canopy â€” Fast Sampling with Cover Trees

20/37

21/37

Canopy I â€“ Method 3

Canopy I â€“ Method 4

ï‚„

Build a cover tree on data points â€“ Cost

ï‚„

Pick an accuracy level having

Data:

elements

Cover Tree:

ï‚„

Build a cover tree on data points â€“ Cost

ï‚„

Pick an accuracy level having

Data:

elements

Cover Tree:

1

1

2
3

4

6
5

7

8

2
9

Surrogates:

22/37

23/37

Canopy I â€“ Method 5

Canopy I â€“ Method 6

ï‚„

Build a cover tree on data points â€“ Cost

ï‚„

Pick an accuracy level

ï‚„

Build alias tables for

Data:

having

ï‚„

3

4

6
5

7

8

For each observation x perform Metropolis-Hastings

elements

â€“ Cost
Cover Tree:

Data:

Sample from

1
2
Surrogates:

3

4

6
5

7

8

9

Surrogates:

24/37

25/37

Canopy I â€“ Method 7

Canopy I â€“ Method 8

ï‚„

For each observation x perform Metropolis-Hastings

Data:

Sample from

Surrogates:

ï‚„

For each observation x perform Metropolis-Hastings

Data:

Surrogates:

Propose in O(1)

Sample from

Accept/Reject

Propose in O(1)

9

Canopy â€” Fast Sampling with Cover Trees

26/37

27/37

Canopy I â€“ Method 9

Canopy I â€“ Method 10

ï‚„

For each observation x perform Metropolis-Hastings

ï‚„

For each observation x perform Metropolis-Hastings
ï‚„

Data:

Data:

Sample from

Accept/Reject

Surrogates:

For exponential families:

Sample from

Accept/Reject

Surrogates:

Propose in O(1)

Propose in O(1)

28/37

29/5

Large Number of Clusters

Canopy II â€“ Method 1

ï‚„

Using first insight, cost reduced

ï‚„

Build a cover tree on cluster parameters â€“ Cost

ï‚„

When moderate number of clusters, e.g.

ï‚„

Pick an accuracy level

ï‚„
ï‚„
ï‚„

Choose
Then alias table will be used at least K times â€“ full amortization!
Total cost
Cluster Parameters:

ï‚„

ï‚„
ï‚„

ï‚„
ï‚„

Cover Tree:

When there many clusters, e.g.

1

Either high overhead of memory and computation,
Or granularity in x that is less precise than desired

2

3

4

Use second insight: not all clusters are relevant

8

Apply cover trees not only to observations but also to the
clusters themselves!

30/5

5
9

6
B

A

7

C

E

D

F

31/5

Canopy II â€“ Method 2
ï‚„

The nodes at the selected
accuracy level act as coarse
approximation to the posterior

2

(Sec 3.2.2 of paper)

3

4
8

ï‚„

Canopy II â€“ Method 3

1

5
9

A

6
B

C

ï‚„
7

D

E

F

1

The nodes at the selected
accuracy level act as coarse
approximation to the posterior

ï‚„

Treat this as a proposal for a
rejection sampler

ï‚„

(Sec 3.2.2 of paper)

2

3

4
8

5
9

A

6
B

C

7
D

E

F

Canopy â€” Fast Sampling with Cover Trees

32/5

33/5

Canopy II â€“ Method 4
ï‚„

Canopy II â€“ Method 5

1

The nodes at the selected
accuracy level act as coarse
approximation to the posterior

ï‚„

Treat this as a proposal for a
rejection sampler

ï‚„

Sample from the proposal

ï‚„

(Sec 3.2.2 of paper)

2

3

4
8

5
9

6
B

A

C

ï‚„

If the proposed sample is
accepted, exit

ï‚„

Else descend down the tree,
and obtain a finer proposal
around the region of interest

ï‚„

(Sec 3.2.2 of paper)

7
D

E

F

34/5

1
2

3

4
8

5
9

6
B

A

C

7
D

E

F

35/5

Canopy II â€“ Method 6
ï‚„

ï‚„

ï‚„

Canopy II â€“ Method 7

1

If the proposed sample is
accepted, exit

2

3

4

Else descend down the tree,
and obtain a finer proposal
around the region of interest

8

5
9

A

ï‚„

6
B

C

7
D

E

F

(Sec 3.2.2 of paper)

36/5

Sampler is as aggressive as
possible in rejecting early on
such that not much effort is
wasted in traversing the tree

ï‚„

The deeper we descend into the
tree, the less likely we reject

ï‚„

In worst case the cost is

1
2

3

4
8

5
9

A

6
B

C

7
D

âˆž

37/5

Canopy II â€“ Full Picture
ï‚„

Canopy II â€“ Descending both Trees
Clusters

Using both the trees allows to
deal with an aggregate of
clusters and data

This leads to a much smaller
observation group

ï‚„

Employ a MH
scheme as before

ï‚„

We propose from a
distribution where
both observations
and clusters are
grouped

8
4
3

2

5

1

7

6

Data

9

ï‚„

ï‚„

1

ï‚„

2
3

ï‚„

6
5

Recursively descend in both the trees while sampling

7

9

Until number of observations for a given cluster is too small
Then use the rejection sampler as describer earlier

ï‚„

Finally perform a MH accept/reject step

ï‚„

This reduces total cost

ï‚„

Acceptance probabilities are as high as in previous case

E

F

