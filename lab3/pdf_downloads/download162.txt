Supplementary Materials for
Understanding Synthetic Gradients and Decoupled Neural Interfaces

A. Relation to critic methods
Instead of estimating the gradient directly, one could estimate loss instead (thus use some trainable Ï†(h|Î¸) â‰ˆ
E[L|h]) and then use its gradient wrt. to its inputs (âˆ‚Ï†/âˆ‚h)
as a surrogate for the synthetic gradient. These kind
of approaches are known in Reinforcement Learning as
critic methods (Fairbank, 2014; Heess et al., 2015), but
in terms of gradient approximation they do not guarantee
any alignment between these signals if only critic is a nonlinear function. As an example lets consider a function
Ï†(h(xi )|Î¸) = L(h(xi )) for every xi , such that it is constant (in terms of its output) in some  balls around each
xi . As a consequence gradients of Ï† are 0 everywhere, yet
as a critic it receives no learning signal (since loss is approximated perfectly). This example shows that in general
alignment between critic gradient and true gradient can be
arbitrary, and completely independent from the loss error
itself.

B. Additional examples
Critical points
We can show an example of SG introducing new critical
points. Consider a small one-dimensional training dataset
{âˆ’2, âˆ’1, 1, 2} âŠ‚ R, and let us consider a simple system
where the model f : R â†’ R is parametrised with two
scalars, a and b and
P4 produces ax + b. We train it to minimise L(a, b) = i=1 |axi + b|. This has a unique minimum which is obtained for a = b = 0, and standard gradient based methods will converge to this solution. Let us
now attach a SG module betweenf and L. This module
produces a (trainable) scalar value c âˆˆ R (thus it produces
a single number, independent from the input). Regardless
of the value of a, we have a critical point of the SG module
when b = 0 and c = 0. However, solutions with a = 1
and c = 0 are clearly not critical points of the original system. Figure 6 shows the loss surface and the fitting of SG
module when it introduces new critical point.

Figure 6. Left: The loss surface with a white marker represents
critical point of the original optimisation and white line a set of
critical points of SG based one. Right: A situation when SG finds
a solution d = 0 which introduces new critical point, which is not
a critical point of the original problem.

loss. If one chooses the learning rate of the SG module
using line search, then in every iteration there exists small
enough, positive learning rate of the main network such
that it converges to the global solution.
Proof. Let X = {xs }Ss=1 âˆˆ RdÃ—S be the data, let
{ys }Ss=1 âˆˆ R1Ã—S be the labels. Throughout the proof k
will be the iteration of training.
We denote by 1 âˆˆ R1Ã—S a row vector in which every element is 1. We also follow the standard convention of including the bias in the weight matrix by augmenting the
data X with one extra coordinate always equal to 1. Thus,
we denote XÌ„ = (XT |1T )T , XÌ„ âˆˆ R(d+1)Ã—S and xÌ„s -the
columns of XÌ„. Using that convention, the weight matrix is
Wk âˆˆ R1Ã—(d+1) . We have
psk := Wk xÌ„s ,
S

L=

n

1X s
1X s
2
2
(y âˆ’ psk ) =
(y âˆ’ Wk xÌ„s ) .
2 s=1
2 i=1

Our aim is to find
arg min L.
W,b

C. Proofs
Theorem 1 Let us consider linear regression trained with
a linear SG module attached between its output and the

We use
S

X âˆ‚L âˆ‚ps
âˆ‚L
âˆ‚L âˆ‚p
=
=
=
âˆ‚W
âˆ‚p âˆ‚W s=1 âˆ‚ps âˆ‚W

Understanding Synthetic Gradients and DNIs
S
S
X
âˆ‚L s X s
xÌ„
=
(y âˆ’ Wk xÌ„s ) (xÌ„s )T
s
âˆ‚p
s=1
s=1


âˆ‚L
= p1 âˆ’ y 1 , . . . , pS âˆ’ y S
âˆ‚p
We will use the following parametrization of the synthetic
g k = (Î±k +1)pk âˆ’(Î²k +1)y+Î³k 1. The reason
gradient âˆ‡L
for using this form instead of simply ak pk + bk y + ck 1 is
that we are going to show that under DNI this synthetic gradient will converge to the â€œreal gradientâ€ âˆ‚L
âˆ‚p , which means
showing that lim (Î±k , Î²k , Î³k ) = (0, 0, 0). Thanks to this
kâ†’âˆ

choice of parameters Î±k , Î²k , Î³k we have the simple expression for the error
2


âˆ‚L 
g
 =

Ek = âˆ‡Lk âˆ’
âˆ‚p 2
k(Î±k + 1)pk âˆ’ (Î²k + 1)y + Î³k 1âˆ’
2
p1k âˆ’ y 1 , . . . , pSk âˆ’ y S 2 =


 Î±k p1k âˆ’ Î²k y 1 + Î³k , . . . , Î±k pSk âˆ’ Î²k y S + Î³k 2
2
Parameters Î±k , Î²k , Î³k will be updated using the gradient
descent minimizing the error E. We have
S

X
âˆ‚E
(Î±k psk âˆ’ Î²k y s + Î³k )psk
=
âˆ‚Î±
s=1
S
X
âˆ‚E
(Î±k psk âˆ’ Î²k y s + Î³k )y s
=âˆ’
âˆ‚Î²
s=1
S

X
âˆ‚E
(Î±k psk âˆ’ Î²k y s + Î³k ).
=
âˆ‚Î³
s=1
As prescribed in Jaderberg et al. (2016), we start our iterative procedure from the synthetic gradient being equal to
zero and we update the parameters by adding the (negative)
gradient multiplied by a learning rate Î½. This means that we
apply the iterative procedure:
Î±0 = âˆ’1, Î²0 = âˆ’1, Î³0 = 0
Wk+1 =Wk âˆ’ Âµ

S
X

((Î±k + 1)psk âˆ’

s=1

(Î²k + 1)ys + Î³k ) (xÌ„s )T
Î±k+1 =Î±k âˆ’ Î½

S
X
(Î±k psk âˆ’ Î²k y s + Î³k )psk
s=1

Î²k+1

S
X
=Î²k + Î½
(Î±k psk âˆ’ Î²k y s + Î³k )y s
s=1

Î³k+1 =Î³k âˆ’ Î½

S
X
s=1

(Î±k psk

s

âˆ’ Î²k y + Î³k ).

Using matrix notation
Wk+1 = Wk âˆ’ Âµ((Î±k + 1)pk âˆ’ (Î²k + 1)y + Î³k 1)XÌ„T

Î±k+1 = Î±k âˆ’ Î½ Î±k kpk k22 âˆ’ Î²k hy, pk i + Î³k h1, pk i

Î²k+1 = Î²k + Î½ Î±k hpk , yi âˆ’ Î²k kyk22 + Î³k h1, yi
Î³k+1 = Î³k âˆ’ Î½ (Î±k h1, pk i âˆ’ Î²k h1, yi + SÎ³k )
Note, that the subspace given by Î± = Î² = Î³ = 0 is invariant under this mapping. As noted before, this corresponds
to the synthetic gradient being equal to the real gradient.
Proving the convergence of SG means showing, that a trajectory starting from Î±0 = âˆ’1, Î²0 = âˆ’1, Î³0 = 0 converges to W = W0 , Î± = Î² = Î³ = 0, where W0 are
the â€œtrueâ€ weigts of the linear regression. We are actually going to prove more, we will show that W = W0 ,
Î± = Î² = Î³ = 0 is in fact a global attractor, i.e. that any
trajectory converges to that point. Denoting Ï‰ = (Î±, Î², Î³)t
we get
Wk+1 = Wk âˆ’ Âµ((Î±k + 1)pk âˆ’ (Î²k + 1)y + Î³k 1)XÌ„T

T  T

Ï‰k+1 = Ï‰k âˆ’ Î½ pTk | âˆ’ yT |1T
pk | âˆ’ yT |1T Ï‰k

T
Wk+1 = Wk âˆ’ Âµ(pk âˆ’ y)XÌ„T âˆ’ ÂµÏ‰kT pTk | âˆ’ yT |1T XÌ„T

T  T

Ï‰k+1 = Ï‰k âˆ’ Î½ pTk | âˆ’ yT |1T
pk | âˆ’ yT |1T Ï‰k .


Denoting by Ak = pTk | âˆ’ yT |1T we get
Wk+1 = Wk âˆ’ Âµ(pk âˆ’ y)XÌ„T âˆ’ ÂµÏ‰ T ATk XÌ„T
Ï‰k+1 = Ï‰k âˆ’ Î½ATk Ak Ï‰k .
Multiplying both sides of the first equation by XÌ„ we obtain
Wk+1 XÌ„ = Wk XÌ„ âˆ’ Âµ(pk âˆ’ y)XÌ„T XÌ„ âˆ’ ÂµÏ‰ T ATk XÌ„T XÌ„
Ï‰k+1 = Ï‰k âˆ’ Î½ATk Ak Ï‰k .
Denote B = XÌ„T XÌ„. We get
pk+1

=

pk âˆ’ Âµpk B + ÂµyB âˆ’ ÂµÏ‰kT ATk B

Ï‰k+1

=

Ï‰k âˆ’ Î½ATk Ak Ï‰k .

Denoting ek = (y âˆ’ pk )T we get
ek+1

= ek âˆ’ ÂµBek + ÂµBAk Ï‰k

Ï‰k+1

= Ï‰k âˆ’ Î½ATk Ak Ï‰k .

We will use the symbol Î¾ = Ak Ï‰k . Then
ek+1
Î¾k+1

= ek âˆ’ ÂµBek + ÂµBÎ¾k
= Î¾k âˆ’ Î½Ak ATk Î¾k .

(1)

Every vector v can be uniquely expressed as a sum v =
v âŠ¥ + v k with XÌ„v âŠ¥ = 0 and v k = XÌ„T Î¸ for some Î¸ (v k
is a projection of v onto the linear subspace spanned by

Understanding Synthetic Gradients and DNIs

s

the columns of XÌ„). Applying this decomposition to ek =
k
eâŠ¥
k + ek we get
eâŠ¥
k+1
k

âŠ¥
âŠ¥
= eâŠ¥
k âˆ’ Âµ(Bek ) + Âµ(BÎ¾k )
k

ek+1

= ek âˆ’ Âµ(Bek )k + Âµ(BÎ¾k )k

Î¾k+1

= Î¾k âˆ’ Î½Ak ATk Î¾k .

Note now, that as B = XÌ„T XÌ„, for any vector v there is
(Bv)âŠ¥ = 0, and (Bv)k = Bv (because the operator v 7â†’
v k is a projection). Moreover, Bv = Bv k . Therefore
eâŠ¥
k+1

=

eâŠ¥
k

ek+1

=

ek âˆ’ Âµ(Bek ) + Âµ(BÎ¾k )k

Î¾k+1

=

Î¾k âˆ’ Î½Ak ATk Î¾k .

k

k

k

The value eâŠ¥
k does not change. Thus, we will be omitting
the first equation. Note, that eâŠ¥
k is â€œthe residueâ€, the smallest error that can be obtained by a linear regression.
k
For the sake of visual appeal we will denote f = ek
fk+1

=

fk âˆ’ ÂµBfk + ÂµBÎ¾k

Î¾k+1

=

Î¾k âˆ’ Î½Ak ATk Î¾k .

Taking norms and using ku + vk â‰¤ kuk + kvk we obtain
kfk+1 k2

â‰¤

kfk âˆ’ ÂµBfk k2 + ÂµkBÎ¾k k2

kÎ¾k+1 k22

=

kÎ¾k k22 âˆ’ 2Î½kATk Î¾k k22 + Î½ 2 kAk ATk Î¾k k22 .

1âˆ’
âˆš

kATk Î¾k k22 kATk Î¾k k22
kÎ¾k k2 â‰¤
kAk ATk Î¾k k22 kÎ¾k k22

1 âˆ’ h â‰¤ 1 âˆ’ 21 h we get
p
k{fk+1 } âŠ• {Î¾k+1 }kâŠ• â‰¤ 1 âˆ’ 2Âµb + Âµ2 kBk2 kfk k2 +


kATk Î¾k k22 kATk Î¾k k22
1âˆ’
+ Âµ kÎ¾k k2
2kAk ATk Î¾k k22 kÎ¾k k22
p
b
Note, that 1 âˆ’ 2Âµb + Âµ2 kBk2 < 1 for 0 < Âµ â‰¤ kBk
2.
Thus, for


b
kATk Î¾k k22 kATk Î¾k k22
Âµ < min
,
1
âˆ’
,
kBk2
2kAk ATk Î¾k k22 kÎ¾k k22

Using

for every pair {fk+1 } âŠ• {Î¾k+1 } 6= {0} âŠ• {0} (and if they
are zeros then we already converged) there is
k{fk+1 } âŠ• {Î¾k+1 }kâŠ• < k{fk } âŠ• {Î¾k }kâŠ• .
Therefore, by Theorem 2, the error pair {fk+1 } âŠ• {Î¾k+1 }
has to converge to 0, which ends the proof in the case
Ak ATk Î¾k 6= 0. It remains to investigate what happens if
Ak ATk Î¾k = 0.
We start by observing that either Î¾k = 0 or ATk Î¾k 6= 0 and
Ak ATk Î¾k 6= 0. This follows directly from the definition
Î¾k = Ak Ï‰k . Indeed, if Î¾k 6= 0 there is 0 < kAk Ï‰k k22 =
Ï‰kT ATk Î¾k and analogously 0 < kATk Î¾k k = Î¾kT Ak ATk Î¾k .

Observe that kfk âˆ’ ÂµBfk k22 = kfk k22 âˆ’ 2Âµfk Bfk +
Âµ2 kBfk k22 . As B is a constant matrix, there exists a constant b > 0 such that v T Bv â‰¥ bkvk22 for any v satisfying
v k = v. Therefore kfk âˆ’ ÂµBfk k22 â‰¤ kfk k22 âˆ’ 2Âµbkfk k22 +
Âµ2 kBk2 kfk k22 . Using that and kBÎ¾k k2 â‰¤ kBkkÎ¾k k2 we
get
p
1 âˆ’ 2Âµb + Âµ2 kBk2 kfk k2 + ÂµkBkkÎ¾k k2
kfk+1 k2 â‰¤

In case Î¾k = 0 there
p is k{fk+1 } âŠ• {Î¾k+1 }kâŠ• =
kp fk+1 k2
<
1 âˆ’ 2Âµb + Âµ2 kBk2 kfk k2
=
2
2
1 âˆ’ 2Âµb + Âµ kBk k{fk } âŠ• {Î¾k }kâŠ• and the theorem follows.

kÎ¾k+1 k22

nâ†’âˆ

=

kÎ¾k k22 âˆ’ 2Î½kATk Î¾k k22 + Î½ 2 kAk ATk Î¾k k22 .

Let us assume that Ak ATk Î¾k 6= 0. In that case the righthand side of the second equation is a quadratic function is
2
kAT
k Î¾k k 2
Î½, whose minimum value is attained for Î½ = kAk A
T Î¾ k2 .
k k 2
For so-chosen Î½ we have
p
kfk+1 k2 â‰¤
1 âˆ’ 2Âµb + Âµ2 kBk2 kfk k2 + ÂµkBkkÎ¾k k2


kATk Î¾k k22 kATk Î¾k k22
2
kÎ¾k+1 k2 =
1âˆ’
kÎ¾k k22 .
kAk ATk Î¾k k22 kÎ¾k k22
Consider a space {f } âŠ• {Î¾} (concatenation of vectors) with
a norm k{f } âŠ• {Î¾}kâŠ• = kf k2 + kÎ¾k2 .

Theorem 2. Let B be a finite-dimensional Banach space.
Let f : B â†’ B be a continuous map such that for every
x âˆˆ B there is kf (x)k < kxk. Then for every x there is
lim f n (x) = 0.
Proof. Let Ï‰(x) = {y : âˆƒi1 <i2 <... lim f in (x) = y}.
nâ†’âˆ

Because kf (x)k < kxk, the sequence x, f (x), f 2 (x), . . .
is contained in a ball of a radius kxk, which due to a finite dimensionality of B is a compact set. Thus, Ï‰(x)
is nonempty. Moreover, from the definition, Ï‰(x) is a
closed set, and therefore it is a compact set. Let y0 =
inf yâˆˆÏ‰(x) kyk â€“ which we know exists, due to the compactness of Ï‰(x) and the continuity of k Â· k (WeierstraÃŸ
theorem). But for every y âˆˆ Ï‰(x) there is f (y) âˆˆ Ï‰(x),
thus there must be y0 = 0. By definition, for every Îµ, there
exists n0 such that kf n0 (x)k < Îµ. Therefore, for n > n0
kf n (x)k < Îµ. Therefore, f n (x) must converge to 0.

k{fk+1 } âŠ• {Î¾k+1 }kâŠ• â‰¤
p

1 âˆ’ 2Âµb + Âµ2 kBk2 kfk k2 + ÂµkBkkÎ¾k k2 +

Proposition 2. Let us assume that a SG module is trained
in each iteration in such a way that it -tracks true gradient,

Understanding Synthetic Gradients and DNIs

i.e. that kSG(h, y) âˆ’ âˆ‚L/âˆ‚hk â‰¤ . If kâˆ‚h/âˆ‚Î¸<h k is upper
bounded by some K and there exists a constant Î´ âˆˆ (0, 1)
such that in every iteration K â‰¤ kâˆ‚L/âˆ‚Î¸<h k 1âˆ’Î´
1+Î´ , then
the whole training process converges to the solution of the
original problem.
Proof. Directly from construction we get that kâˆ‚L/âˆ‚Î¸<h âˆ’
Ë† âˆ‚Î¸
Ë† <h k = k(âˆ‚L/âˆ‚hâˆ’SG(h, y))âˆ‚h/âˆ‚Î¸<h k â‰¤ K thus
âˆ‚L/
in each iteration there exists such a vector e, that kek â‰¤ K
Ë† âˆ‚Î¸
Ë† <h = âˆ‚L/âˆ‚Î¸<h + e. Consequently, we get
and âˆ‚L/
a model trained with noisy gradients, where the noise of
the gradient is bounded in norm by K so, directly from
assumptions, it is also upper bounded by kâˆ‚L/âˆ‚Î¸<h k 1âˆ’Î´
1+Î´
and we we get that the direction followed is sufficient for
convergence as this means that cosine between true gradient and synthetic gradient is uniformly bounded away (by
Î´) from zero (Zoutendijk, 1970; Gratton et al., 2011). At
the same time, due to Proposition 1, we know that the assumptions do not form an empty set as the SG module can
stay in an  neighborhood of the gradient, and both norm
of the synthetic gradient and kâˆ‚h/âˆ‚Î¸<h k can go to zero
around the true critical point.

the noise is equal to eâˆ‚h/âˆ‚Î¸<h we get that
keâˆ‚h/âˆ‚Î¸<h k â‰¤ kekkâˆ‚h/âˆ‚Î¸<h k < 1/3kâˆ‚L/âˆ‚Î¸<h k,
which is equivalent to error for Î¸<h being upper bounded
by (1 âˆ’ Î´)/(1 + Î´)kâˆ‚L/âˆ‚hk for Î´ = 0.5 which matches
assumptions of Proposition 2, thus leading to the convergence of the model considered. If at any moment we lose
track of the gradient again â€“ the same mechanism kicks in Âµ goes down for as long as the inequality (2) does not hold
again (and it has to at some point, given Î½ is positive and
small enough).

D. Technical details
All experiments were performed using TensorFlow (Abadi
et al., 2016). In all the experiments SG loss is the MSE
between synthetic and true gradients. Since all SGs considered were linear, weights were initialized to zeros so
initially SG produces zero gradients, and it does not affect
convergence (since linear regression is convex).
Datasets

Corollary 1. For a deep linear model and an MSE objective, trained with a linear SG module attached between
two of its hidden layers, there exist learning rates in each
iteration such that it converges to the critical point of the
original problem.

Each of the artificial datasets is a classification problem,
consisting of X sampled from k-dimensional Gaussian distribution with zero mean and unit standard deviation. For
k = 2 we sample 100 points and for k = 100 we sample
1000. Labels y are generated in a way depending on the
dataset name:

Proof. Denote the learning rate of the main model by Âµ
and learning rate of the SG module by Î½ > 0 and put Âµ =
 max(0, kek âˆ’ 1/(3kâˆ‚h/âˆ‚Î¸<h k)kâˆ‚L/âˆ‚Î¸<h k), where  is
a small learning rate (for example found using line search)
and e is the error SG will make in the next iteration. The
constant 1/3 appears here as it is equal to (1 âˆ’ Î´)/(1 + Î´)
for Î´ = 0.5 which is a constant from Proposition 2, which
we will need later on. Norm of e consists of the error fitting
term LSG which we know, and the term depending on the
previous Âµ value, since this is how much the solution for the
SG problem evolved over last iteration. In such a setting,
the main model changes iff

â€¢ lineark - we randomly sample an origin-crossing hyperplane (by sampling its parameters from standard
Gaussians) and label points accordingly,

kekkâˆ‚h/âˆ‚Î¸<h k < 1/3kâˆ‚L/âˆ‚Î¸<h k.

(2)

First of all, this takes place as long as Î½ is small enough
since the linear SG is enough to represent âˆ‚L/âˆ‚h with arbitrary precision (Proposition 1) and it is trained to do so
in a way that always converges (as it is a linear regression
fitted to a linear function). So in the worst case scenario
for a few first iterations we choose very small Âµ (it always
exists since in the worst case scenario Âµ = 0 agrees with
the inequality). Furthermore, once this happens we follow
true gradient on Î¸>h and a noisy gradient on Î¸<h . Since

â€¢ noisyk - we label points according to lineark and then
randomly swap labels of 10% of samples,
â€¢ randomk - points are labeled completely randomly.
We used one-hot encoding of binary labels to retain compatibility with softmax-based models, which is consistent
with the rest of experiments. However we also tested
the same things with a single output neuron and regular
sigmoid-based network and obtained analogous results.
Optimisation
Optimisation is performed using the Adam optimiser (Kingma & Ba, 2014) with a learning rate of
3e âˆ’ 5. This applies to both main model and to SG module.
Artificial datasets
Table 2 shows results for training linear regression (shallow
MSE), 10 hidden layer deep linear regression (deep MSE),

Understanding Synthetic Gradients and DNIs

Figure 7. (top) Representation Dissimilarity Matrices for a label ordered sample from MNIST dataset pushed through 20-hidden layer
deep relu networks trained with backpropagation (top row), a single SG attached between layers 11 and 12 (2nd row), SG between
every pair of layers (3rd row), and the DFA model (4th row). Notice the moment of appearance of dark blue squares on a diagonal in
each learning method, which shows when a clear inner-class representation has been learned. For visual confidence off block diagonal
elements are semi transparent. (bottom) L2 distance between diagonal elements at a given layer and the same elements at layer 20.
Dotted lines show where SGs are inserted. With a single SG module we can see that there is the representation is qualitatively different
for the first part of the network (up to layer 11) and the rest. For fully unlocked model the representation constantly evolves through
all the layers, as opposed to backprop which has a nearly constant representation correlation from layer 9 forward. Also due to DFA
mathematical formulation it tries to solve the task as early as possible thus leading to nearly non-evolving representation correlation after
the very first layer.

logistic regression (shallow log loss) and 10 hidden layer
deep linear classifier (deep log loss). Since all these problems (after proper initialisation) converge to the global optima, we report the difference between final loss obtained
for SG enriched models and the true global optimum.
MNIST experiments
Networks used are simple feed forward networks with h
layers of 512 hidden relu units followed by batch normalisation layers. The final layer is a regular 10-class softmax
layer. Inputs were scaled to [0, 1] interval, besides that there
was no preprocessing applied.
Representational Dissimilarity Matrices
In order to build RDMs for a layer h we sample 400 points
(sorted according to their label) from the MNIST dataset,
{xi }400
i=1 and record activations on each of these points,
hi = h(xi ). Then we compute a matrix RDM such that
RDMij = 1 âˆ’ corr(hi , hj ). Consequently a perfect RDM
is a block diagonal matrix, thus elements of the same class
have a representation with high correlation and the representations of points from two distinct classes are not correlated. Figure 7 is the extended version of the analogous
Figure 3 from the main paper where we show RDMs for

backpropagation, a single SG, SG in-between every two
layers, and also the DFA model, when training 20 hidden
layer deep relu network.
Linear classifier/regression probes
One way of checking the degree to which the actual classification problem is solved at every layer of a feedforward
network is to attach linear classifiers to every hidden layer
and train them on the main task without backpropagating
through the rest of the network. This way we can make a
plot of train accuracy obtained from the representation at
each layer. As seen in Figure 8 (left) there is not much of
the difference between such analysis for backpropagation
and a single SG module, confirming our claim in the paper
that despite different representations in both sections of SG
based module - they are both good enough to solve the main
problem. We can also that DFA tries to solve the classification problem bottom-up as opposed to up-bottom â€“ notice
that for DFA we can have 100% accuracy after the very first
hidden layer, which is not true even for backpropagation.
We also introduced a new kind of linear probe, which tries
to capture how much computation (non-linear transformations) are being used in each layer. To achieve this, we attach a linear regressor module after each hidden layer and

Understanding Synthetic Gradients and DNIs

dataset

model

MSE

log loss

linear2
linear100
noisy2
noisy100
random2
random100
noisy2
noisy100
random2
random100

shallow
shallow
shallow
shallow
shallow
shallow
deep
deep
deep
deep

0.00000
0.00002
0.00000
0.00002
0.00000
0.00004
0.00000
0.00001
0.00000
0.00001

0.03842
0.08554
0.00036
0.00442
0.00000
0.00003
0.00000
0.00293
0.00000
0.00004

Table 2. Differences in final losses obtained for various models/datasets when trained with SG as compared to model trained
with backpropagation. Bolded entries denote experiments which
converged to a different solution. lineark is k dimensional, linearly separable dataset, noisy is linearly separable up to 10% label noise, and random has completely random labeling. Shallow
models means linear ones, while deep means 10 hidden layer deep
linear models. Reported differences are averaged across 10 different datasets from the same distributions.

Figure 8. Left: Training accuracy at each linear classifier probe.
Right: MSE for each linear regressor probe.

regress it (with MSE) to the input of the network. This
is obviously label agnostic approach, but measures how
non-linear the transformations are up to the given hidden
layer. Figure 8 (right) again confirms that with a single SG
we have two parts of the network (thus results are similar
to RDM experiments) which do have slightly different behaviour, and again show clearly that DFA performs lots of
non-linear transformations very early on compared to all
other methods.
Loss estimation
In the main paper we show how SG modules using both activations and labels are able to implicitly describe the loss
surface reasonably well for most of the training, with different datasets and losses. For completeness, we also include the same experiment for SG modules which do not
use label information (Figure 9 (a) - (d)) as well as a module which does not use activations at all6 (Figure 9 (e) (h))). There are two important observations here: Firstly,
6

This is more similar to a per-label stale gradient model.

none of these two approaches provide a loss estimation fidelity comparable with the full SG (conditioned on both
activations and labels). This gives another empirical confirmation for correct conditioning of the module. Secondly,
models which used only labels did not converge to a good
solutions after 100k iterations, while without the label SG
was able to do so (however it took much longer and was far
noisier).

References
Abadi, MartÄ±Ìn, Agarwal, Ashish, Barham, Paul, Brevdo,
Eugene, Chen, Zhifeng, Citro, Craig, Corrado, Greg S,
Davis, Andy, Dean, Jeffrey, Devin, Matthieu, et al. Tensorflow: Large-scale machine learning on heterogeneous
distributed systems. arXiv preprint arXiv:1603.04467,
2016.
Fairbank, M. Value-gradient learning. PhD thesis, City
University London, UK, 2014.
Gratton, Serge, Toint, Philippe L, and TroÌˆltzsch, Anke.
How much gradient noise does a gradient-based linesearch method tolerate. Technical report, Citeseer, 2011.
Heess, N, Wayne, G, Silver, D, Lillicrap, T P, Erez, T,
and Tassa, Y. Learning continuous control policies by
stochastic value gradients. In Advances in Neural Information Processing Systems 28: Annual Conference on
Neural Information Processing Systems 2015, December
7-12, 2015, Montreal, Quebec, Canada, pp. 2944â€“2952,
2015.
Jaderberg, Max, Czarnecki, Wojciech Marian, Osindero,
Simon, Vinyals, Oriol, Graves, Alex, and Kavukcuoglu,
Koray. Decoupled neural interfaces using synthetic gradients. arXiv preprint arXiv:1608.05343, 2016.
Kingma, Diederik and Ba, Jimmy.
method for stochastic optimization.
arXiv:1412.6980, 2014.

Adam: A
arXiv preprint

Zoutendijk, G. Nonlinear programming, computational
methods. Integer and nonlinear programming, 143(1):
37â€“86, 1970.

Understanding Synthetic Gradients and DNIs

Every layer SG

Single SG

Every layer SG

Train iteration

Single SG

b) log loss, noisy linear data, no label conditioning

c) MSE, randomly labeled data, no label conditioning

d) log loss, randomly labeled data, no label conditioning

e) MSE, noisy linear data, only label conditioning

f) log loss, noisy linear data, only label conditioning

g) MSE, randomly labeled data, only label conditioning

h) log loss, randomly labeled data, only label conditioning

Train iteration

Train iteration

Train iteration

a) MSE, noisy linear data, no label conditioning

Figure 9. Visualisation of the true loss and the loss extracted from the SG module. In each block left plot shows an experiment with
a single SG attached and the right one with a SG after each hidden layer. Note, that in this experiment the final loss is actually big,
thus even though the loss reassembles some part of the noise surface, the bright artifact lines are actually keeping it away from the true
solution.

